<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2018%2F08%2F08%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%26%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%2FMachineLearning_180808103540%2F</url>
    <content type="text"><![CDATA[MachineLearning.md—D:\HEXO\blog\source\_posts\机器学习&amp;人工智能 html{font-family: sans-serif;-ms-text-size-adjust: 100%;-webkit-text-size-adjust: 100%}body{margin: 0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display: block}audio,canvas,progress,video{display: inline-block;vertical-align: baseline}audio:not([controls]){display: none;height: 0}[hidden],template{display: none}a{background: transparent}a:active,a:hover{outline: 0}abbr[title]{border-bottom: 1px dotted}b,strong{font-weight: bold}dfn{font-style: italic}h1{font-size: 2em;margin: 0.67em 0}mark{background: #ff0;color: #000}small{font-size: 80%}sub,sup{font-size: 75%;line-height: 0;position: relative;vertical-align: baseline}sup{top: -0.5em}sub{bottom: -0.25em}img{border: 0}svg:not(:root){overflow: hidden}figure{margin: 1em 40px}hr{box-sizing: content-box;height: 0}pre{overflow: auto}code,kbd,pre,samp{font-family: monospace, monospace;font-size: 1em}button,input,optgroup,select,textarea{color: inherit;font: inherit;margin: 0}button{overflow: visible}button,select{text-transform: none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance: button;cursor: pointer}button[disabled],html input[disabled]{cursor: default}button::-moz-focus-inner,input::-moz-focus-inner{border: 0;padding: 0}input{line-height: normal}input[type="checkbox"],input[type="radio"]{box-sizing: border-box;padding: 0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height: auto}input[type="search"]{-webkit-appearance: textfield;box-sizing: content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance: none}fieldset{border: 1px solid #c0c0c0;margin: 0 2px;padding: 0.35em 0.625em 0.75em}legend{border: 0;padding: 0}textarea{overflow: auto}optgroup{font-weight: bold}table{border-collapse: collapse;border-spacing: 0}td,th{padding: 0}*{box-sizing: border-box}input,select,textarea,button{font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"}body{min-width: 1020px;font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";color: #333;background-color: #fff}a{color: #4183c4;text-decoration: none}a:hover,a:active{text-decoration: underline}hr,.rule{height: 0;margin: 15px 0;overflow: hidden;background: transparent;border: 0;border-bottom: 1px solid #ddd}hr:before,.rule:before{display: table;content: ""}hr:after,.rule:after{display: table;clear: both;content: ""}h1,h2,h3,h4,h5,h6{margin-top: 15px;margin-bottom: 15px;line-height: 1.1}h1{font-size: 30px}h2{font-size: 21px}h3{font-size: 16px}h4{font-size: 14px}h5{font-size: 12px}h6{font-size: 11px}small{font-size: 90%}blockquote{margin: 0}.lead{margin-bottom: 30px;font-size: 20px;font-weight: 300;color: #555}.text-muted{color: #999}.text-danger{color: #bd2c00}.text-emphasized{font-weight: bold;color: #333}ul,ol{padding: 0;margin-top: 0;margin-bottom: 0}ol ol,ul ol{list-style-type: lower-roman}ul ul ol,ul ol ol,ol ul ol,ol ol ol{list-style-type: lower-alpha}dd{margin-left: 0}tt,code{font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;font-size: 12px}pre{margin-top: 0;margin-bottom: 0;font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace}#realtime .status{overflow: visible;position: absolute;top: -5px;left: 0;background: url("/public/images/github-status.png");width: 26px;height: 26px;display: block;margin: 0 5px 0 0}#realtime .up{background-position: 0 0}#realtime .problem{background-position: 0 -53px}#realtime .down{background-position: 0 -26px}.container{max-width: 920px;margin: 0 auto 20px auto}#header{background: #FAFAFA;background: -moz-linear-gradient(#FAFAFA, #EAEAEA);background: -webkit-linear-gradient(#FAFAFA, #EAEAEA);-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr='#fafafa', endColorstr='#eaeaea')";border-bottom: 1px solid #CACACA;box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4),0 0 10px rgba(0, 0, 0, 0.1)}#markup{padding: 3px}#markup article{padding-top: 30px}.markdown-body{overflow: hidden;font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;font-size: 16px;line-height: 1.6;word-wrap: break-word}.markdown-body>*:first-child{margin-top: 0 !important}.markdown-body>*:last-child{margin-bottom: 0 !important}.markdown-body .absent{color: #c00}.markdown-body .anchor{position: absolute;top: 0;left: 0;display: block;padding-right: 6px;padding-left: 30px;margin-left: -30px}.markdown-body .anchor:focus{outline: none}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position: relative;margin-top: 1em;margin-bottom: 16px;font-weight: bold;line-height: 1.4}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{display: none;color: #000;vertical-align: middle}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{padding-left: 8px;margin-left: -30px;text-decoration: none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{display: inline-block}.markdown-body h1 tt,.markdown-body h1 code,.markdown-body h2 tt,.markdown-body h2 code,.markdown-body h3 tt,.markdown-body h3 code,.markdown-body h4 tt,.markdown-body h4 code,.markdown-body h5 tt,.markdown-body h5 code,.markdown-body h6 tt,.markdown-body h6 code{font-size: inherit}.markdown-body h1{padding-bottom: 0.3em;font-size: 2.25em;line-height: 1.2;border-bottom: 1px solid #eee}.markdown-body h1 .anchor{line-height: 1}.markdown-body h2{padding-bottom: 0.3em;font-size: 1.75em;line-height: 1.225;border-bottom: 1px solid #eee}.markdown-body h2 .anchor{line-height: 1}.markdown-body h3{font-size: 1.5em;line-height: 1.43}.markdown-body h3 .anchor{line-height: 1.2}.markdown-body h4{font-size: 1.25em}.markdown-body h4 .anchor{line-height: 1.2}.markdown-body h5{font-size: 1em}.markdown-body h5 .anchor{line-height: 1.1}.markdown-body h6{font-size: 1em;color: #777}.markdown-body h6 .anchor{line-height: 1.1}.markdown-body p,.markdown-body blockquote,.markdown-body ul,.markdown-body ol,.markdown-body dl,.markdown-body table,.markdown-body pre{margin-top: 0;margin-bottom: 16px}.markdown-body hr{height: 4px;padding: 0;margin: 16px 0;background-color: #e7e7e7;border: 0 none}.markdown-body ul,.markdown-body ol{padding-left: 2em}.markdown-body ul.no-list,.markdown-body ol.no-list{padding: 0;list-style-type: none}.markdown-body ul ul,.markdown-body ul ol,.markdown-body ol ol,.markdown-body ol ul{margin-top: 0;margin-bottom: 0}.markdown-body li>p{margin-top: 16px}.markdown-body dl{padding: 0}.markdown-body dl dt{padding: 0;margin-top: 16px;font-size: 1em;font-style: italic;font-weight: bold}.markdown-body dl dd{padding: 0 16px;margin-bottom: 16px}.markdown-body blockquote{padding: 0 15px;color: #777;border-left: 4px solid #ddd}.markdown-body blockquote>:first-child{margin-top: 0}.markdown-body blockquote>:last-child{margin-bottom: 0}.markdown-body table{display: block;width: 100%;overflow: auto;word-break: normal;word-break: keep-all}.markdown-body table th{font-weight: bold}.markdown-body table th,.markdown-body table td{padding: 6px 13px;border: 1px solid #ddd}.markdown-body table tr{background-color: #fff;border-top: 1px solid #ccc}.markdown-body table tr:nth-child(2n){background-color: #f8f8f8}.markdown-body img{max-width: 100%;box-sizing: border-box}.markdown-body span.frame{display: block;overflow: hidden}.markdown-body span.frame>span{display: block;float: left;width: auto;padding: 7px;margin: 13px 0 0;overflow: hidden;border: 1px solid #ddd}.markdown-body span.frame span img{display: block;float: left}.markdown-body span.frame span span{display: block;padding: 5px 0 0;clear: both;color: #333}.markdown-body span.align-center{display: block;overflow: hidden;clear: both}.markdown-body span.align-center>span{display: block;margin: 13px auto 0;overflow: hidden;text-align: center}.markdown-body span.align-center span img{margin: 0 auto;text-align: center}.markdown-body span.align-right{display: block;overflow: hidden;clear: both}.markdown-body span.align-right>span{display: block;margin: 13px 0 0;overflow: hidden;text-align: right}.markdown-body span.align-right span img{margin: 0;text-align: right}.markdown-body span.float-left{display: block;float: left;margin-right: 13px;overflow: hidden}.markdown-body span.float-left span{margin: 13px 0 0}.markdown-body span.float-right{display: block;float: right;margin-left: 13px;overflow: hidden}.markdown-body span.float-right>span{display: block;margin: 13px auto 0;overflow: hidden;text-align: right}.markdown-body code,.markdown-body tt{padding: 0;padding-top: 0.2em;padding-bottom: 0.2em;margin: 0;font-size: 85%;background-color: rgba(0,0,0,0.04);border-radius: 3px}.markdown-body code:before,.markdown-body code:after,.markdown-body tt:before,.markdown-body tt:after{letter-spacing: -0.2em;content: "\00a0"}.markdown-body code br,.markdown-body tt br{display: none}.markdown-body del code{text-decoration: inherit}.markdown-body pre>code{padding: 0;margin: 0;font-size: 100%;word-break: normal;white-space: pre;background: transparent;border: 0}.markdown-body .highlight{margin-bottom: 16px}.markdown-body .highlight pre,.markdown-body pre{padding: 16px;overflow: auto;font-size: 85%;line-height: 1.45;background-color: #f7f7f7;border-radius: 3px}.markdown-body .highlight pre{margin-bottom: 0;word-break: normal}.markdown-body pre{word-wrap: normal}.markdown-body pre code,.markdown-body pre tt{display: inline;max-width: initial;padding: 0;margin: 0;overflow: initial;line-height: inherit;word-wrap: normal;background-color: transparent;border: 0}.markdown-body pre code:before,.markdown-body pre code:after,.markdown-body pre tt:before,.markdown-body pre tt:after{content: normal}.markdown-body kbd{display: inline-block;padding: 3px 5px;font-size: 11px;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb}.codehilite{background: #ffffff}.codehilite .c{color: #999988;font-style: italic}.codehilite .err{color: #a61717;background-color: #e3d2d2}.codehilite .k{color: #000000;font-weight: bold}.codehilite .o{color: #000000;font-weight: bold}.codehilite .cm{color: #999988;font-style: italic}.codehilite .cp{color: #999999;font-weight: bold}.codehilite .c1{color: #999988;font-style: italic}.codehilite .cs{color: #999999;font-weight: bold;font-style: italic}.codehilite .gd{color: #000000;background-color: #ffdddd}.codehilite .gd .x{color: #000000;background-color: #ffaaaa}.codehilite .ge{color: #000000;font-style: italic}.codehilite .gr{color: #aa0000}.codehilite .gh{color: #999999}.codehilite .gi{color: #000000;background-color: #ddffdd}.codehilite .gi .x{color: #000000;background-color: #aaffaa}.codehilite .go{color: #888888}.codehilite .gp{color: #555555}.codehilite .gs{font-weight: bold}.codehilite .gu{color: #aaaaaa}.codehilite .gt{color: #aa0000}.codehilite .kc{color: #000000;font-weight: bold}.codehilite .kd{color: #000000;font-weight: bold}.codehilite .kp{color: #000000;font-weight: bold}.codehilite .kr{color: #000000;font-weight: bold}.codehilite .kt{color: #445588;font-weight: bold}.codehilite .m{color: #009999}.codehilite .s{color: #d14}.codehilite .na{color: #008080}.codehilite .nb{color: #0086B3}.codehilite .nc{color: #445588;font-weight: bold}.codehilite .no{color: #008080}.codehilite .ni{color: #800080}.codehilite .ne{color: #990000;font-weight: bold}.codehilite .nf{color: #990000;font-weight: bold}.codehilite .nn{color: #555555}.codehilite .nt{color: #000080}.codehilite .nv{color: #008080}.codehilite .ow{color: #000000;font-weight: bold}.codehilite .w{color: #bbbbbb}.codehilite .mf{color: #009999}.codehilite .mh{color: #009999}.codehilite .mi{color: #009999}.codehilite .mo{color: #009999}.codehilite .sb{color: #d14}.codehilite .sc{color: #d14}.codehilite .sd{color: #d14}.codehilite .s2{color: #d14}.codehilite .se{color: #d14}.codehilite .sh{color: #d14}.codehilite .si{color: #d14}.codehilite .sx{color: #d14}.codehilite .sr{color: #009926}.codehilite .s1{color: #d14}.codehilite .ss{color: #990073}.codehilite .bp{color: #999999}.codehilite .vc{color: #008080}.codehilite .vg{color: #008080}.codehilite .vi{color: #008080}.codehilite .il{color: #009999} .markdown-body hr{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC")} 机器学习 基础概念 训练集 :用于训练机器学习算法的数据样本集合 为算法输入大量已分类数据作为算法的训练集 特征（属性） : 通常是训练样本集的列，是独立测量得到的结果，多个特征联系起来在一起共同组成一个训练样本 特征类型 数值型，可以使用十进制数字 目标变量 分类算法中目标变量的类型通常是标称型的，被称为类别 回归算法的类型通常为连续型的 知识表示 检查机器是否已经学会了所分配的任务 监督学习 内容：分类 &amp; 回归 目的：进行预测，对目标变量的分类信息进行预测 回归 主要用于预测数值型数据 无监督学习 特点：无类别信息，也不会给定目标值 聚类 : 将数据集合分成由类似的对象组成的多个类的过程 密度估计 : 将寻找描述数据统计值的过程 Day_1 步骤一 —— 导入必需数据科学库 在进行数据分析，需要两个必须常用库 —— pandas 、 Numpy import numpy as np import matplotlib.pyplot as plt import pandas as pd 步骤二 —— 设置工作目录，导入数据集 数据集一般为.csv格式，且通常为表格形式。每一行都有对应的数据记录。每一个数据集都会包括两部分，独立变量（independent variable）和依赖变量（dependent variable)。 我们使用pandas中的read_csv的方式来读取数据集的内容，然后可以在Dataframe中分离矩阵和相关和不相关的向量 数据科学中很重要的一点就是建立metrics（度量，指标）。每一列都可以是一个metric。 而metrics主要包括两部分：independent variable 和 dependent variable。 getwd() setwd(&quot;/working directory&quot;) dataset = pd.read_csv(filepath_or_buffer=&quot; &quot;) # create 独立变量vector X = dataset.iloc[ : , : -1].values # 除了最后一列全是自变量 # create 依赖变量vecto Y = dataset.iloc[ : , 3].values # 最后一列作为应变量 View(dataset) 解释 iloc表示取数据集中的某些行和某些列 逗号前表示行，逗号后表示列 这里表示取所有行，列取除了最后一列的所有列，因为列是应变量 机器学习的目的就是需要通过独立变量来预测非独立变量（prediction）。独立变量不会被影响而非独立变量可能被独立变量影响。 步骤三 —— 缺失值处理 关于缺失值（missing value）的处理，在sklearn的preprocessing包中包含了对数据集中缺失值的处理，主要是应用Imputer类进行处理 进行处理的数据集中包含缺失值一般步骤如下： 使用字符串'nan'来代替数据集中的缺失值； 将该数据集转换为浮点型便可以得到包含np.nan的数据集； 使用sklearn.preprocessing.Imputer类来处理使用np.nan对缺失值进行编码过的 from sklearn.preprocessing import Imputer imputer = Imputer(missing_values= &quot;NaN&quot;, strategy= &quot;mean&quot;, axis= 0) imputer = imputer.fit(X[ : , 1: 3]) # (inclusive column 1, exclusive column 3, means col 1 &amp; 2) X[ : , 1: 3] = imputer.transform(X[ : , 1: 3]) # 将imputer 应用到数据 注意在data science中我们可以用NaN代替空值，但是在ML中必须要求数据为numeric。所以我们可以用mean来代替空值。 步骤四 —— 分类数据编码 分类数据一般包含标签分类值，而不是数据值。可能的变量通常限制在固定数据集中。单纯的变量值不能在数学模型等式中使用，所以我们需要对分类数据编码成数字。 作法： 从sklearn.preprocessing中导入LabelEncoder类 from sklearn.preprocessing import LabelEncoder, OneHotEncoder labelencoder_X = LabelEncoder() # 标准化标签，将标签值统一转换成range(标签值个数-1)范围内 X[ : , 0] = labelencoder_X.fit_transform(X[ : , 0]) #不包括index行 简单来说 LabelEncoder 是对不连续的数字或者文本进行编号 再创建一个虚拟变量 (变量dummy化) dummy variable是用0或1表示某个类别是否出现,适用于出现bool类型的结果 OneHotEncoder用于处理分类变量，将变量的特征值转换为稀疏矩阵 onehotencoder = Onehotencoder(categorical_features = [0]) X = onehotencoder.fit_transform(X).toarray() labelencoder_Y = LabelEncoder() Y = labelencoder_Y.fit_transform(Y) 步骤五 —— 将数据集分成 测试集 和 训练集 将数据集分为两个部分，一个训练集，另一个用来测试所建立的模型的表现。 通常分配数据比例为 80/20 。 接下来采用从sklearn.model_selection库中导入train_test_split()类 from sklearn.model_selection import train_test_split X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size= 0.2, random_state= 0) 注意：原来的cross_validation模块被弃用了，改为支持model_selection这个模块 步骤六 —— 特征缩放 (Feature scaling) feature scaling（特征缩放）的思想就是将所选特征的value都缩放到一个大致相似的范围 通常来说，大部分机器学习算法都采用欧氏距离来计算两地的距离。特征在不同的量级、单位、排列上的极度不同会产生问题。高量级的数据的欧式距离的计算量会很大。 由于每个变量的范围不同，如果两个变量之间差距太大，会导致距离对结果产生影响。所以我们要对数据进行一定的标准化改变。最简单的方式是将数据缩放至[0.1]或者[-1,1]之间： 为使得特征标准化或Z-score统一化，需要导入 sklearn.preprocessing中的StandardScalar 代码如下： from sklearn.preprocessing import StandardScalar sc_X = StandardScalar() X_train = sc_X.fit_transform(X_train) X_test = sc_X.fit_transform(X_test) 第一天的学习结束啦，开心😄 Day_2 简单线性回归 概述 使用一个简单的特征来预测将来值 线性回归是一种基于非独立变量X来预测独立变量Y的方法。它假设两个变量线性相关，因此，我们需要找出X与Y的线性关系 如何寻找最合适的线来拟合 在回归模型中，如果我们能够找到能使预测误差最小的线来拟合，则回归线的误差也会最小化。 我们应该试图将以观察到的值与我们预测值之间的距离最小化。 y = bo + b1*x1 步骤一、处理数据 运用第一天的五个步骤 Import the Libraries Import the DataSet Check for Missing Data Split the DataSet Feature Scaling import pandas as pd import numpy as np import matplotlib.pyplot as plt dataset = pd.read_csv(&#39;studentscores.csv&#39;) X = dataset.iloc[ : , : 1 ].values Y = dataset.iloc[ : , 1 ].values from sklearn.cross_validation import train_test_split X_train, X_test, Y_train, Y_test = train_test_split( X, Y, test_size = 1/4, random_state = 0) 使用matplotlib.pyplot绘制图 注意：这里我们没有进行特征缩放，这是因为一般Python的library会自动进行feature scaling，所以我们不需要自己动手 步骤二、训练训练集的简单线性回归模型 下面我们将通过训练集的X_train与y_train 计算出符合训练集的曲线 为了训练数据集，我们将使用sklearn.linear_model调用LinearRegression,使用regressor对象 我们将使用LinearRegression类，fit()方法将对象拟合到数据集中。 from sklearn.linear_model import LinearRegression regressor = LinearRegression() regressor = regressor.fit(X_train, Y_train) # 通过train集找到曲线 步骤三、预测结果 我们将从训练集中预测结果,将输出保存在向量Y_pred.为了预测结果，我们将使用在上一步中在regressor中使用的LinearRegression类方法 Y_pred = regressor.predict(X_test) 将测试集的X_test 带入得到的曲线中，得到预测的结果y_pred，目的是为了将预测结果y_pred与测试集中的y_test进行比较，看看是否符合分布，从而确定预测是否准确 步骤四、数据可视化 最后一步为将我们的结果可视化。我们将使用matplotlib.pyplot库来制作训练集结果和测试集结果的扩散图(scatter plot)，来观察我们的模型对结果值的预测情况 可视化训练结果 plt.scatter(X_train, Y_train, color= &#39;red&#39;) plt.plot(X_train, regressor.predict(X_train), color= &#39;blue&#39;) ply.title(&quot; &quot;) #显示整个图标的标题 plt.xlabel(&quot; &quot;) # 显示X坐标的标题 plt.ylabel(&quot; &quot;) # 显示Y坐标的标题 plt.show() 可视化测试结果 # Import the test results plt.scatter(X_test, Y_test, color= &quot;red&quot;) plt.plot(X_test, regressor.predict(X_test), color= &quot;blue&quot;) ply.title(&quot; &quot;) #显示整个图标的标题 plt.xlabel(&quot; &quot;) # 显示X坐标的标题 plt.ylabel(&quot; &quot;) # 显示Y坐标的标题 plt.show() 第2️天的学习结束啦，开心😄 Day_3 多重线性回归 概述 多重线性回归(Multiple Linear Regression)将会不只有一个自变量，并且每个自变量拥有自己的系数且符合线性回归。 多重线性回归试图使用两个或者以上的特征建立模型来适应观察线性数据。其实多重线性回归建立的步骤与简单线性回归相似。 你可以用它来找出哪一个因素对预测的输出有着最大的影响，以及不同的变量是如何相互关联的。 y = bo + b1x1 + b2x2 + ... + bnxn 需要满足的条件 满足线性性(linearity) ：独立变量和非独立变量需要满足线性性 应保持误差的同方差（常方差 Homoscedasticity） 多元正态性(Multivariate normality)：多元回归假设残差是正态分布的 错误的独立性(independence of errors) ：每一个变量产生的错误将会独立的影响预测结果，不会对其他变量产生影响 缺乏多重共线性(lack of multicollinearity)：假设在数据中很少或没有多重共线性，当特征（或独立变量）彼此不独立时发生多重共线性。 虚拟变量 在回归模型中，具有固定和无序数量值的数据值,在回归预测中我们需要所有的数据都是numeric的，但是会有一些非numeric的数据，例如性别 (男/女)，这些值会被虚拟变量代替。变量包含例如 0/1的值，，来代替表示2代表分类值的存在与否 虚拟变量陷阱 虚拟变量陷阱是两个或多个变量高度相关的场景。 通俗来理解(intuitively)，就是一个变量必须被其余变量所预测。直观地说，有一个重复(duplicate)的范畴：如果我们放弃男性范畴，它在女性范畴中是固有定义的（零女性值表示男性，反之亦然vice-versa）。 再通俗地理解，就拿性别来说，其实一个虚拟变量就够了，比如 1 的时候是“男”， 0 的时候是"非男"，即为女。如果设置两个虚拟变量“男”和“女”，语义上来说没有问题，可以理解，但是在回归预测中会多出一个变量，多出的这个变量将会对回归预测结果产生影响。 &nbsp;&nbsp;&nbsp;部分文字信息来自Dykin' Blog 虚拟变量陷阱的解决方法： 删除分类变量中的一个——如果有M个类别，在模型中使用M-1，可以忽略掉的值作为参考值。 y = bo + b1x1 + b2x2 + b3D1 注释--建立模型(stepwise Regression) 有多种方法来选择适当的变量，例如： 前向选择(前进法Forward Selection) 逆向消除(后退法Backward Elimination) 双向比较(bi-directional comparision) Backward Elimination: 首先包含了所有的feature，然后每个feature都尝试去删除，测试删除的哪个feature对模型准确性有最大的提升，最终删掉对模型提升最高的一个特征。如此类推，直到删除feature并不能提升模型为止。 开始今天的学习 预处理数据 运用第一天的处理步骤 Import the libraries Import the DataSet Check for Missing Data Encode Categorical Data Make Dummy Variables if necessary and avoid dummy variable trap Feature Scaling will be taken care by the Library 3 代码如下： import pandas as pd import numpy as np import matplotlib.pyplot as plt dataset = pd.read_csv(&#39;50_Starups.csv&#39;) X = dataset.iloc[ : , :-1].values Y = dataset.iloc[ : , 4].values # Encoding Categorical data from sklearn.preprocessing import LabelEncoder, OneHotencoder labelencoder = LabelEncoder() X[ : , 3] = labelencoder.fit_transform(X[ : , 3]) onehotencoder = Onehotencoder(categorical_features= [3]) X =onehotencoder.fit_transform(X).toarray() # Avoiding Dummy Variable Trap X = X[ : , 1: ] #从1 开始，并非0 # Splitting the dataset into the Training set and Test set from sklearn.cross_validation import train_test_split X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state = 0) 将模型拟合到训练集 (Fitting our model to the trainning set) 这个步骤和简单线性回归完全相同。 我们将使用 sklearn.linear_model库中的LinearRegression类来拟合训练集，然后创建一个LinearRegression的regressor对象，再对对象使用fit()方法来处理。 # Fitting Multiple Linear Regression to the Training set from sklearn.linear_model import LinearRegression regressor = LinearRegression() regressor.fit(X_train, Y_train) 预测测试集的结果 在这个步骤中，我们将预测从测试集观察到的结果。使用Y_pred来储存输出，最后使用predict()方法，来预测我们在上一步骤中训练的结果 # Predicting the test set results Y_pred = regressor.predict(X_test) plt.scatter(np.arange(10),y_test, color = &#39;red&#39;,label=&#39;y_test&#39;) plt.scatter(np.arange(10),y_pred, color = &#39;blue&#39;,label=&#39;y_pred&#39;) plt.legend(loc=2) plt.show() 第3天的学习结束啦，明天也要坚持哟😄 Day_4 逻辑效果(logistic regression) 概述 逻辑回归在某些书中也被称为对数几率回归,逻辑回归适合于处理分类问题，目的在于预测当前对象属于哪个分类组，它给出了一个0到1之间的离散二进制结果。 一个非常典型的例子就是一个人到底会不会为即将到来的选举投票 疑问 它是如何工作的？？？ 逻辑回归通过依赖于它的基本逻辑函数估计概率，来测量因变量（我们想要预测的标签）和一个或多个独立变量（我们的特征）之间的关系。 Sigmoid Function (S型曲线函数) SigMoid函数是一个S形曲线，它可以取任何实数，并将其映射到0到1之间的值，但绝对不受这些限制。 \phi (z) = \dfrac{1}{1 + e^{-z}} 进行预测 概率必须转化为二进制值(binary)，以便实际进行预测。这是Logistic函数的任务，也称为乙状函数(Sigmoid function)。0和1之间的值将使用阈值分类器(threshold classifier)转换成0和1。 逻辑 vs 线性 逻辑回归给你一个离散(discrete [dɪˈskri:t] )的结果，但线性回归给出了一个连续(continuous)的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sass]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%89%8D%E7%AB%AF%2Fsass%2F</url>
    <content type="text"><![CDATA[Sass (Syntactically Awesome StyleSheets)Sass 是对 CSS 的扩展，让 CSS 语言更强大、优雅。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F29%2F%E5%89%8D%E7%AB%AF%2FJavaScript_180729165832%2F</url>
    <content type="text"><![CDATA[JavaScript.md—D:\HEXO\blog\source\_posts\前端 html{font-family: sans-serif;-ms-text-size-adjust: 100%;-webkit-text-size-adjust: 100%}body{margin: 0}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display: block}audio,canvas,progress,video{display: inline-block;vertical-align: baseline}audio:not([controls]){display: none;height: 0}[hidden],template{display: none}a{background: transparent}a:active,a:hover{outline: 0}abbr[title]{border-bottom: 1px dotted}b,strong{font-weight: bold}dfn{font-style: italic}h1{font-size: 2em;margin: 0.67em 0}mark{background: #ff0;color: #000}small{font-size: 80%}sub,sup{font-size: 75%;line-height: 0;position: relative;vertical-align: baseline}sup{top: -0.5em}sub{bottom: -0.25em}img{border: 0}svg:not(:root){overflow: hidden}figure{margin: 1em 40px}hr{box-sizing: content-box;height: 0}pre{overflow: auto}code,kbd,pre,samp{font-family: monospace, monospace;font-size: 1em}button,input,optgroup,select,textarea{color: inherit;font: inherit;margin: 0}button{overflow: visible}button,select{text-transform: none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance: button;cursor: pointer}button[disabled],html input[disabled]{cursor: default}button::-moz-focus-inner,input::-moz-focus-inner{border: 0;padding: 0}input{line-height: normal}input[type="checkbox"],input[type="radio"]{box-sizing: border-box;padding: 0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height: auto}input[type="search"]{-webkit-appearance: textfield;box-sizing: content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance: none}fieldset{border: 1px solid #c0c0c0;margin: 0 2px;padding: 0.35em 0.625em 0.75em}legend{border: 0;padding: 0}textarea{overflow: auto}optgroup{font-weight: bold}table{border-collapse: collapse;border-spacing: 0}td,th{padding: 0}*{box-sizing: border-box}input,select,textarea,button{font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"}body{min-width: 1020px;font: 13px/1.4 Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";color: #333;background-color: #fff}a{color: #4183c4;text-decoration: none}a:hover,a:active{text-decoration: underline}hr,.rule{height: 0;margin: 15px 0;overflow: hidden;background: transparent;border: 0;border-bottom: 1px solid #ddd}hr:before,.rule:before{display: table;content: ""}hr:after,.rule:after{display: table;clear: both;content: ""}h1,h2,h3,h4,h5,h6{margin-top: 15px;margin-bottom: 15px;line-height: 1.1}h1{font-size: 30px}h2{font-size: 21px}h3{font-size: 16px}h4{font-size: 14px}h5{font-size: 12px}h6{font-size: 11px}small{font-size: 90%}blockquote{margin: 0}.lead{margin-bottom: 30px;font-size: 20px;font-weight: 300;color: #555}.text-muted{color: #999}.text-danger{color: #bd2c00}.text-emphasized{font-weight: bold;color: #333}ul,ol{padding: 0;margin-top: 0;margin-bottom: 0}ol ol,ul ol{list-style-type: lower-roman}ul ul ol,ul ol ol,ol ul ol,ol ol ol{list-style-type: lower-alpha}dd{margin-left: 0}tt,code{font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;font-size: 12px}pre{margin-top: 0;margin-bottom: 0;font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace}#realtime .status{overflow: visible;position: absolute;top: -5px;left: 0;background: url("/public/images/github-status.png");width: 26px;height: 26px;display: block;margin: 0 5px 0 0}#realtime .up{background-position: 0 0}#realtime .problem{background-position: 0 -53px}#realtime .down{background-position: 0 -26px}.container{max-width: 920px;margin: 0 auto 20px auto}#header{background: #FAFAFA;background: -moz-linear-gradient(#FAFAFA, #EAEAEA);background: -webkit-linear-gradient(#FAFAFA, #EAEAEA);-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr='#fafafa', endColorstr='#eaeaea')";border-bottom: 1px solid #CACACA;box-shadow: 0 1px 0 rgba(255, 255, 255, 0.4),0 0 10px rgba(0, 0, 0, 0.1)}#markup{padding: 3px}#markup article{padding-top: 30px}.markdown-body{overflow: hidden;font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;font-size: 16px;line-height: 1.6;word-wrap: break-word}.markdown-body>*:first-child{margin-top: 0 !important}.markdown-body>*:last-child{margin-bottom: 0 !important}.markdown-body .absent{color: #c00}.markdown-body .anchor{position: absolute;top: 0;left: 0;display: block;padding-right: 6px;padding-left: 30px;margin-left: -30px}.markdown-body .anchor:focus{outline: none}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position: relative;margin-top: 1em;margin-bottom: 16px;font-weight: bold;line-height: 1.4}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{display: none;color: #000;vertical-align: middle}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{padding-left: 8px;margin-left: -30px;text-decoration: none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{display: inline-block}.markdown-body h1 tt,.markdown-body h1 code,.markdown-body h2 tt,.markdown-body h2 code,.markdown-body h3 tt,.markdown-body h3 code,.markdown-body h4 tt,.markdown-body h4 code,.markdown-body h5 tt,.markdown-body h5 code,.markdown-body h6 tt,.markdown-body h6 code{font-size: inherit}.markdown-body h1{padding-bottom: 0.3em;font-size: 2.25em;line-height: 1.2;border-bottom: 1px solid #eee}.markdown-body h1 .anchor{line-height: 1}.markdown-body h2{padding-bottom: 0.3em;font-size: 1.75em;line-height: 1.225;border-bottom: 1px solid #eee}.markdown-body h2 .anchor{line-height: 1}.markdown-body h3{font-size: 1.5em;line-height: 1.43}.markdown-body h3 .anchor{line-height: 1.2}.markdown-body h4{font-size: 1.25em}.markdown-body h4 .anchor{line-height: 1.2}.markdown-body h5{font-size: 1em}.markdown-body h5 .anchor{line-height: 1.1}.markdown-body h6{font-size: 1em;color: #777}.markdown-body h6 .anchor{line-height: 1.1}.markdown-body p,.markdown-body blockquote,.markdown-body ul,.markdown-body ol,.markdown-body dl,.markdown-body table,.markdown-body pre{margin-top: 0;margin-bottom: 16px}.markdown-body hr{height: 4px;padding: 0;margin: 16px 0;background-color: #e7e7e7;border: 0 none}.markdown-body ul,.markdown-body ol{padding-left: 2em}.markdown-body ul.no-list,.markdown-body ol.no-list{padding: 0;list-style-type: none}.markdown-body ul ul,.markdown-body ul ol,.markdown-body ol ol,.markdown-body ol ul{margin-top: 0;margin-bottom: 0}.markdown-body li>p{margin-top: 16px}.markdown-body dl{padding: 0}.markdown-body dl dt{padding: 0;margin-top: 16px;font-size: 1em;font-style: italic;font-weight: bold}.markdown-body dl dd{padding: 0 16px;margin-bottom: 16px}.markdown-body blockquote{padding: 0 15px;color: #777;border-left: 4px solid #ddd}.markdown-body blockquote>:first-child{margin-top: 0}.markdown-body blockquote>:last-child{margin-bottom: 0}.markdown-body table{display: block;width: 100%;overflow: auto;word-break: normal;word-break: keep-all}.markdown-body table th{font-weight: bold}.markdown-body table th,.markdown-body table td{padding: 6px 13px;border: 1px solid #ddd}.markdown-body table tr{background-color: #fff;border-top: 1px solid #ccc}.markdown-body table tr:nth-child(2n){background-color: #f8f8f8}.markdown-body img{max-width: 100%;box-sizing: border-box}.markdown-body span.frame{display: block;overflow: hidden}.markdown-body span.frame>span{display: block;float: left;width: auto;padding: 7px;margin: 13px 0 0;overflow: hidden;border: 1px solid #ddd}.markdown-body span.frame span img{display: block;float: left}.markdown-body span.frame span span{display: block;padding: 5px 0 0;clear: both;color: #333}.markdown-body span.align-center{display: block;overflow: hidden;clear: both}.markdown-body span.align-center>span{display: block;margin: 13px auto 0;overflow: hidden;text-align: center}.markdown-body span.align-center span img{margin: 0 auto;text-align: center}.markdown-body span.align-right{display: block;overflow: hidden;clear: both}.markdown-body span.align-right>span{display: block;margin: 13px 0 0;overflow: hidden;text-align: right}.markdown-body span.align-right span img{margin: 0;text-align: right}.markdown-body span.float-left{display: block;float: left;margin-right: 13px;overflow: hidden}.markdown-body span.float-left span{margin: 13px 0 0}.markdown-body span.float-right{display: block;float: right;margin-left: 13px;overflow: hidden}.markdown-body span.float-right>span{display: block;margin: 13px auto 0;overflow: hidden;text-align: right}.markdown-body code,.markdown-body tt{padding: 0;padding-top: 0.2em;padding-bottom: 0.2em;margin: 0;font-size: 85%;background-color: rgba(0,0,0,0.04);border-radius: 3px}.markdown-body code:before,.markdown-body code:after,.markdown-body tt:before,.markdown-body tt:after{letter-spacing: -0.2em;content: "\00a0"}.markdown-body code br,.markdown-body tt br{display: none}.markdown-body del code{text-decoration: inherit}.markdown-body pre>code{padding: 0;margin: 0;font-size: 100%;word-break: normal;white-space: pre;background: transparent;border: 0}.markdown-body .highlight{margin-bottom: 16px}.markdown-body .highlight pre,.markdown-body pre{padding: 16px;overflow: auto;font-size: 85%;line-height: 1.45;background-color: #f7f7f7;border-radius: 3px}.markdown-body .highlight pre{margin-bottom: 0;word-break: normal}.markdown-body pre{word-wrap: normal}.markdown-body pre code,.markdown-body pre tt{display: inline;max-width: initial;padding: 0;margin: 0;overflow: initial;line-height: inherit;word-wrap: normal;background-color: transparent;border: 0}.markdown-body pre code:before,.markdown-body pre code:after,.markdown-body pre tt:before,.markdown-body pre tt:after{content: normal}.markdown-body kbd{display: inline-block;padding: 3px 5px;font-size: 11px;line-height: 10px;color: #555;vertical-align: middle;background-color: #fcfcfc;border: solid 1px #ccc;border-bottom-color: #bbb;border-radius: 3px;box-shadow: inset 0 -1px 0 #bbb}.codehilite{background: #ffffff}.codehilite .c{color: #999988;font-style: italic}.codehilite .err{color: #a61717;background-color: #e3d2d2}.codehilite .k{color: #000000;font-weight: bold}.codehilite .o{color: #000000;font-weight: bold}.codehilite .cm{color: #999988;font-style: italic}.codehilite .cp{color: #999999;font-weight: bold}.codehilite .c1{color: #999988;font-style: italic}.codehilite .cs{color: #999999;font-weight: bold;font-style: italic}.codehilite .gd{color: #000000;background-color: #ffdddd}.codehilite .gd .x{color: #000000;background-color: #ffaaaa}.codehilite .ge{color: #000000;font-style: italic}.codehilite .gr{color: #aa0000}.codehilite .gh{color: #999999}.codehilite .gi{color: #000000;background-color: #ddffdd}.codehilite .gi .x{color: #000000;background-color: #aaffaa}.codehilite .go{color: #888888}.codehilite .gp{color: #555555}.codehilite .gs{font-weight: bold}.codehilite .gu{color: #aaaaaa}.codehilite .gt{color: #aa0000}.codehilite .kc{color: #000000;font-weight: bold}.codehilite .kd{color: #000000;font-weight: bold}.codehilite .kp{color: #000000;font-weight: bold}.codehilite .kr{color: #000000;font-weight: bold}.codehilite .kt{color: #445588;font-weight: bold}.codehilite .m{color: #009999}.codehilite .s{color: #d14}.codehilite .na{color: #008080}.codehilite .nb{color: #0086B3}.codehilite .nc{color: #445588;font-weight: bold}.codehilite .no{color: #008080}.codehilite .ni{color: #800080}.codehilite .ne{color: #990000;font-weight: bold}.codehilite .nf{color: #990000;font-weight: bold}.codehilite .nn{color: #555555}.codehilite .nt{color: #000080}.codehilite .nv{color: #008080}.codehilite .ow{color: #000000;font-weight: bold}.codehilite .w{color: #bbbbbb}.codehilite .mf{color: #009999}.codehilite .mh{color: #009999}.codehilite .mi{color: #009999}.codehilite .mo{color: #009999}.codehilite .sb{color: #d14}.codehilite .sc{color: #d14}.codehilite .sd{color: #d14}.codehilite .s2{color: #d14}.codehilite .se{color: #d14}.codehilite .sh{color: #d14}.codehilite .si{color: #d14}.codehilite .sx{color: #d14}.codehilite .sr{color: #009926}.codehilite .s1{color: #d14}.codehilite .ss{color: #990073}.codehilite .bp{color: #999999}.codehilite .vc{color: #008080}.codehilite .vg{color: #008080}.codehilite .vi{color: #008080}.codehilite .il{color: #009999} .markdown-body hr{background:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC")} JavaScript : 描述HTML文档属性。JavaScript语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情 JS入门初级 插入JS JS文件不能直接运行，需嵌入到HTML文件中执行 JavaScript代码可以放在html文件中任何位置，但是我们一般放在网页的head或者body部分。 在HTML文档中插入 在&lt;script type="text/javascript"&gt;&lt;/script&gt;标签内插入JS脚本 在HTML中引入JS外部文件 插入方法：&lt;script src="script.js"&gt;&lt;/script&gt; 注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等） JS代码注释 单行注释，在注释内容前加符号 “//”。 多行注释以"/*"开始，以"*/"结束。 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;单行注释使用&#39;//&#39;&quot;); // 我是注释，该语句功能在网页中输出内容 /* 多行注释 养成书写注释的良好习惯 */ &lt;/script&gt; JS文本标签 一. document.write() 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。 示例： &lt;script&gt; var str=&quot;hello&quot;; document.write(str+&quot;world&quot;+&quot;&lt;br&gt;&quot;); &lt;/script&gt; 二. .getElementById()函数 document.getElementById(),获取DOM节点 用.getElementById()函数 获取到id的所有标签,而获去标签的目的 往往是对这些标签进行操作，假如是文本标签，就可以进行改变字体颜色、大小等操作 实例： 修改p1的文档属性和输出 hello &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;hello&quot;); document.getElementById(&quot;p1&quot;).style.color=&quot;blue&quot;; &lt;/script&gt; 解释： document.write("hello") : 打印在网页中——网页输出 alert("hello") : 打印在对话框里————调试输出 console.log("hello") : 打印在控制台———控制台输出 三、 JS警告(alert 消息对话框) 语法： alert(字符串或变量) 须知: 在点击对话框"确定"按钮前，不能进行任何其它操作。 消息对话框通常可以用于调试程序 四、 JS确认(confirm 消息对话框) 用途：向用户确认是否要执行某项操作时，可以添加 语法： confirm(str) 返回值： Boolean 值 当用户点击"确定"按钮时，返回true 当用户点击"取消"按钮时，返回false confirm 消息对话框通常用于允许用户做选择的动作。弹出对话框(包括一个确定按钮和一个取消按钮)。 实例： 通过confirm返回的布尔值进行下一步操作 &lt;script type=&quot;text/javascript&quot;&gt; var test=confirm(&quot;hello&quot;); if(test=true) { document.write(&quot;you&quot;) ;} else { document.write(&quot;me&quot;); } &lt;/script&gt; 注意: 消息对话框是排它的，即用户在点击对话框按钮前，不能进行任何其它操作。 五、 JS提问 (prompt 消息对话框) 语法： prompt(str1,str2); 其中 str1: 要显示在消息对话框中的文本，不可修改 ； str2：文本框中的内容，可以修改，分两次显示 点击确定按钮，文本框中的内容将作为函数返回值 点击取消按钮，将返回null JavaScript变量 变量是用于存储某种/某些数值的存储器 JS 定义变量： var 变量名 注意：变量必须使用字母、下划线(_)或者美元符($)开始 例子： var my_test; my_test=&quot;javascript&quot;; var my_num= &quot;26&quot;; 注意：变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。另外，变量是弱类型的。 内嵌变量的另一写法与调用 语法：var test={ fun_name:function(){} } &lt;script type=&quot;text/javascript&quot;&gt; var i={ alertWord:function(){ var j=confirm(&quot;准备好了？&quot;); if(j===true){alert(&quot;恭喜您，已经掌握此技能。&quot;)} else{alert(&quot;请重新学习课程内容吆，直到实践编写代码与实践要求一致!&quot;)} },} &lt;/script&gt; &lt;form &gt; &lt;input type=&quot;button&quot; onclick=&quot;i.alertWord()&quot; value=&quot;请点击确认&quot; /&gt; &lt;/form&gt; JavaScript判断语句 基本判断 语法： if(条件1) { 条件1成立时执行的代码 } else if(条件2){ 执行条件3成立的代码 } else { 条件都不成立时执行的代码 } 三元运算符（条件?真成立:假成立） switch case 每一种case情况下都要加break，如果不加break，不管后面的代码是否成立都会被执行 JS函数 定义： function 函数名() { 函数代码; } 函数调用:函数定义好后，是不能自动执行的，所以需调用它,只需直接在需要的位置写函数就ok了 实例： 嵌入式网页调用函数,onlick使用 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;函数调用&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function contxt() //定义函数 { alert(&quot;调用函数!&quot;); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input type=&quot;button&quot; value=&quot;点击我&quot; onclick=&quot;contxt()&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; JS--新窗口 (window.open/close) open() 方法可以查找一个已经存在或者新建的浏览器窗口 语法： window.open([URL], [窗口名称], [参数字符串]) 参数说明： URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。 窗口名称：可选参数，被打开窗口的名称。 该名称由字母、数字和下划线字符组成。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 name 不能包含有空格。 注意：参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。 参数列表 实例：打开百度，在另一页面打开，页面大小自行设定，无工具栏 &lt;script type=&quot;text/javascript&quot;&gt; window.open(&quot;http://www.baidu.com&quot;, &quot;_blank&quot;, &quot;width=300,height=200,toolbar=no&quot;) &lt;/script&gt; close()关闭窗口 用法： window.close(); 或 &lt;窗口对象&gt;.close(); //关闭指定的窗口 实例:关闭新建的窗口。 &lt;script type=&quot;text/javascript&quot;&gt; var mywin=window.open(&#39;http://www.imooc.com&#39;); //将新打的窗口对象，存储在变量mywin中 mywin.close(); &lt;/script&gt; 初识DOM DOM(Document Object Model):文本对象模型定义访问和处理HTML文档的标准方法。 DOM将HTML文档呈现为带有元素、属性和文本的树结构 实例： 简单的DOM节点层次图 常见的DOM节点 元素节点： html 、body、p 文本节点： 向用户展示的内容，例如 &lt;li&gt; 中的JS,DOM,CSS等文本 属性节点： 元素属性，如 &lt;a&gt;标签属性 href 通过ID获取元素 获取对象标签 标签的id属性值是唯一的，可以通过getElementById("id")来获取 语法：document.getElementById("id") 注意：获取的元素是一个对象，若对元素进行操作，则需要通过它的属性或方法 一般标签返回值为： null 或 [object.HTMLParagraphElement] 解释： 结果为null是因为，JavaScript没有找到id名为“con”的标签，所以返回null 结果为[object HTMLParagraphElement]，则说明JavaScript找到了id名为“con”的标签，以对象的形式返回该标签 获取标签元素的内容 innerHTML属性用于获取或替换HTML元素的内容 **语法：Object.innerHTML 解释： Object是获取的元素对象，如通过 document.getElementById("id")获取 实例： &lt;script type=&quot;text/javascript&quot;&gt; var mycon= document.getElementById(&quot;con&quot;); document.write(&quot;p标签内容&quot;+mycon.innerHTML); &lt;/script&gt; 注意:如果将mycon的内容进行修改，则HTML原文档中的mycon对应的对象内容也会随之改变 改变HTML样式 基本样式 HTML DOM 允许 JS 改变HTML的元素样式 语法：Object.style.property=new style; 基本属性表 width、height设置需要加上px 实例： 改变 p 标签的背景颜色 &lt;p id=&quot;con&quot;&gt;Hello world!&lt;/p&gt; &lt;script&gt; var mycon=document.getElementById(&quot;con&quot;); mycon.style.backgroundColor = &#39;green&#39;; &lt;/script&gt; 显示和隐藏(display属性) 网页中的显示和隐藏的效果均可以通过display属性设置 语法：Object.style.display= value value取值 用处 none 该元素会被隐藏 block 该元素会被显示为块级元素 示例： 设置隐藏段落内容按钮 &lt;script type=&quot;text/javascript&quot;&gt; function hide() { document.getElementById(&quot;con&quot;).style.display =&quot;none&quot;; } &lt;/script&gt; &lt;p id=&quot;con&quot;&gt;这是要隐藏的段落内容&lt;/p&gt; &lt;form &gt; &lt;input type=&quot;button&quot; onclick=&quot;hide()&quot; value=&quot;隐藏段落内容&quot;&gt; &lt;/form&gt; 控制类名 (className属性) className属性可以设置或返回元素的class属性 语法：Oject.className=classname 用处： 获取元素的class属性 为网页的某个元素指定一个css样式 示例： 搭配css设置修改元素的样式 &lt;style&gt; body{ font-size:16px;} .one{ border:1px solid #eee; width:230px; height:50px; background:#ccc; color:red; } .two{ border:1px solid #ccc; width:230px; height:50px; background:#9CF; color:blue; } &lt;/style&gt; &lt;body&gt; &lt;p id=&quot;con&quot; class=&quot;one&quot;&gt;JavaScript样式&lt;/p&gt; &lt;form&gt; &lt;input type=&quot;button&quot; onclick=&quot;change_style()&quot; value=&quot;点击修改样式&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; var mycon=document.getElementById(&quot;con&quot;); function change_style() { mycon.className=&quot;two&quot;; } &lt;/script&gt; &lt;/body&gt; 重新设置JS属性 语法：Object.removeAttribute("style"); 实例：定义"取消设置"的函数 提示: 使用confirm()确定框，来确认是否取消设置。 //定义&quot;取消设置&quot;的函数 function 取消设置() { var bool = confirm(&quot;确定要重新设置？&quot;) if (bool == true) { 文本.removeAttribute(&quot;style&quot;); } } 实例运用 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;txttent-Type&quot; txttent=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;javascript&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{font-size:12px;} #txt{ height:400px; width:600px; border:#333 solid 1px; padding:5px;} p{ line-height:18px; text-indent:2em;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h2 id=&quot;con&quot;&gt;JavaScript课程&lt;/H2&gt; &lt;div id=&quot;txt&quot;&gt; &lt;h5&gt;JavaScript为网页添加动态效果并实现与用户交互的功能。&lt;/h5&gt; &lt;p&gt;1. JavaScript入门篇，让不懂JS的你，快速了解JS。&lt;/p&gt; &lt;p&gt;2. JavaScript进阶篇，让你掌握JS的基础语法、函数、数组、事件、内置对象、BOM浏览器、DOM操作。&lt;/p&gt; &lt;p&gt;3. 学完以上两门基础课后，在深入学习JavaScript的变量作用域、事件、对象、运动、cookie、正则表达式、ajax等课程。&lt;/p&gt; &lt;/div&gt; &lt;form&gt; &lt;!--当点击相应按钮，执行相应操作，为按钮添加相应事件--&gt; &lt;input type=&quot;button&quot; value=&quot;改变颜色&quot; onclick=&quot;set.changeColor()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;改变宽高&quot; onclick=&quot;set.changeSize()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;隐藏内容&quot; onclick=&quot;set.objHide()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;显示内容&quot; onclick=&quot;set.objShow()&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;取消设置&quot; onclick=&quot;set.offSet()&quot;&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; var txt=document.getElementById(&quot;txt&quot;); var set={ changeColor:function(){ txt.style.color=&quot;red&quot;; txt.style.backgroundColor=&quot;#ccc&quot;; }, changeSize:function(){ txt.style.width=&quot;300px&quot;; txt.style.height=&quot;300px&quot;; }, objHide:function(){ txt.style.display=&quot;none&quot;; }, objShow:function(){ txt.style.display=&quot;block&quot;; }, offSet:function(){ var message=confirm(&quot;你确定要重置所有设置么？&quot;); if(message==true){ txt.removeAttribute(&#39;style&#39;); } } } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6入门]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%89%8D%E7%AB%AF%2FES6%2F</url>
    <content type="text"><![CDATA[前端之旅：ES6入门]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Hailstone序列 For computing the Hailstone sequence (a.k.a. 3n+1 problem), the Hailstone(n) program Hailstone问题（又名3n+1问题）中Hailstone(n) 解决 解释：其中运用了三元运算符，(n % 2) == 1 则为True , (n % 2) == 0 则为False. 结论： 不能证明对于任意的n，序列都有穷；同时也不能找到一个反例 计算模型DSA ： Data Science + Algorithm 数据结构 + 算法 度量成本: 运行时间 + 所需存储空间 观察 问题实例的规模，往往是决定计算成本的主要因素 通常规律 规模越近，计算成本也越近 规模度量值的定义 T(n) = max { T(P) | |P| = n }]]></content>
      <categories>
        <category>计算基础</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言]]></title>
    <url>%2F2018%2F07%2F26%2FC%E8%AF%AD%E8%A8%80%2FC%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[易错点 C语言输出需要使用双引号 switch 语句只会根据条件语句进行case、default的选择执行 continue只能用在循环体内 范例： 水仙花数 12345678910111213141516171819202122#include &lt;stdio.h&gt;int main()&#123; //定义三位数num,个位数sd,十位数td,百位数hd int num, sd, td, hd; //循环所有三位数 for(num=100;num&lt;1000;num++) &#123; //获取三位数字num百位上的数字 hd =num/100; //获取三位数字num十位上的数字 td =num%100/10; //获取三位数字num个位上的数字 sd =num%10; //水仙花数的条件是什么？ if(num==hd*hd*hd+td*td*td+sd*sd*sd) &#123; printf("水仙花数字：%d\n", num); &#125; &#125; return 0; &#125; 范例： 输出下图 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; int i, j, k; for(i=1; i&lt;5; i++) &#123; /* 观察每行的空格数量，补全循环条件 */ for( j=i ; j&lt;5 ; j++ ) &#123; printf(" "); //输出空格 &#125; /* 观察每行*号的数量，补全循环条件 */ for( k=0 ; k&lt;2*i-1 ; k++ ) &#123; printf("*"); //每行输出的*号 &#125; printf("\n"); //每次循环换行 &#125; return 0;&#125; 每一行的*数目为: 2i-1 范例：判断是否为闰年 判断闰年的标准是：能整除4且不能整除100 或者能整除400 switch 语句会根据 condition来选择case的条件执行,若喜欢能执行多个case，则把符合condition的case放置第一位，然后不要使用break语句，直到执行完最后一个希望执行的case，再添加break 实例：使用switch语句和if…else语句，计算2008年8月8日这一天，是该年中的第几天。 方案一 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main() &#123; int year = 2008; int month = 8; int day = 8; int i,j; if(year%100==0&amp;&amp;year%400==0||year%4==0&amp;&amp;year%100!=0)i=1; else i=0; switch(month) &#123; case 1:j=day;break; case 2:j=31+ day;break; case 3:j=31+ 28+ day;break; case 4:j=31+ 28+ 31+ day;break; case 5:j=31+ 28+ 31+ 30+ day;break; case 6:j=31+ 28+ 31+ 30+ 31+ day;break; case 7:j=31+ 28+ 31+ 30+ 31+ 30+ day;break; case 8:j=31+ 28+ 31+ 30+ 31+ 30+ 31+day;break; case 9:j=31+ 28+ 31+ 30+ 31+ 30+ 31+ 31+ day;break; case 10:j=31+ 28+ 31+ 30+ 31+ 30+ 31+ 31+ 30+day;break; case 11:j=31+ 28+ 31+ 30+ 31+ 30+ 31+ 31+ 30+ 31+day;break; case 12:j=31+ 28+ 31+ 30+ 31+ 30+ 31+ 31+ 30+ 31+ 30+ day;break; &#125; if(i==1)j+=1; printf("%d年%d月%d日是该年的第%d天",year,month,day,j); return 0;&#125; 方案二 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int main() &#123; /* 定义需要计算的日期 */ int year = 2008; int month = 8; int day = 8; /* * 请使用swtich语句，if...else语句完成本题 * 如有想看小编思路的，可以点击左侧任务中的“不会了怎么办” * 小编还是希望大家独立完成哦~ */ int date = 0; switch (month) &#123; case 12: date += 30; case 11: date += 31; case 10: date += 30; case 9: date += 31; case 8: date += 31; case 7: date += 30; case 6: date += 31; case 5: date += 30; case 4: date += 31; case 3: if(year%400 != 0 &amp;&amp; year%4 == 0)&#123; date += 29; &#125;else&#123; date += 28;&#125; case 2: date += 31; default: date += 8,printf("2008年8月8日是该年的第%d天",date);break; &#125; return 0;&#125; goto语句goto语句是一种无条件分支语句，goto 语句的使用格式为： goto 语句标号; 语句标号是一个标识符，该标识符一般用英文大写并遵守标识符命名规则，这个标识符加上一个“:”一起出现在函数内某处，执行goto语句后，程序将跳转到该标号处并执行其后的语句。 示例： goto语句通常不用，主要因为它将使程序层次不清，且不易读，但在特定情况下，可以使用goto语句来提高程序的执行速度，所以还是少用为妙。 函数自创函数 注意:自定义函数尽量放在main函数之前，如果要放在main函数后面的话，需要在main函数之前先声明自定义函数，声明格式为：[数据类型说明] 函数名称（[参数]）;示例：1234567891011121314#include &lt;stdio.h&gt;/* 自定义整型函数 sayLove() */int sayLove()&#123; //在这里输入输出语句printf，输出内容为I Love imooc printf("I Love imooc"); return 0;&#125;/* 主函数 */int main()&#123; sayLove(); return 0;&#125;#### 函数调用语法：函数名（[参数]）;[]中可以是常数，变量或其它构造类型数据及表达式，个参数之间用逗号分隔。参数：形参与实参 形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量 在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹函数返回值 return 表达式 或者为： return (表达式); 没有返回值的函数，返回类型为void注意：void函数中可以有执行代码块，但是不能有返回值，另void函数中如果有return语句，该语句只能起到结束函数运行的功能。其格式为：return;### 递归使用一、 猴子第一天摘下N个桃子，当时就吃了一半，还不过瘾，就又多吃了一个。第二天又将剩下的桃子吃掉一半，又多吃了一个。以后每天都吃前一天剩下的一半零一个。到第10天在想吃的时候就剩一个桃子了,问第一天共摘下来多少个桃子？并反向打印每天所剩桃子数。123456789101112131415161718#include &lt;stdio.h&gt;/* 定义获取单词数量的函数 */int getWordNumber(int n)&#123; if(n == 1) &#123; return 1; //第一天只会1个单词,即返回最后一天的数量 &#125; else&#123; return getWordNumber(n-1)+n ; //到第天会的单词数量 &#125;&#125;int main()&#123; int num = getWordNumber(10); //获取会了的单词数量 printf("小明第10天记了:%d个单词。\n", num); return 0;&#125;二、有5个人坐在一起，问第5个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第3个人，又说比第2人大两岁。问第2个人，说比第1个人大两岁。最后 问第1个人，他说是10岁。请问第5个人多大？1234567891011#include &lt;stdio.h&gt; int dfs(int n) &#123; return n == 1 ? 10 : dfs(n - 1) + 2; // 三则运算符&#125;int main() &#123; printf("第5个人的年龄是%d岁", dfs(5)); return 0;&#125;## 局部与全局### 初解全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。程序会优先寻找函数内部变量，如果没找到再在全局变量寻找。123456789101112int main()&#123; int x = 10; if(x&gt;0) &#123; int x = 100; x /= 2; printf("if语句内, x=%d\n", x); &#125; printf("main方法内, x=%d\n", x); return 0;&#125;输出：12if语句内, x=50main方法内, x=10### 变量存储类别C语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式 静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。 动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形式参数；自动变量；函数调用时的现场保护和返回地址等。存储类别又分为四类： 自动（auto） 静态（static）* 寄存器的（register）和外部的（extern）自动变量 用关键字auto定义的变量为自动变量，auto可以省略，auto不写则隐含定为“自动存储类别”，属于动态存储方式. 静态变量static 用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。 静态变量可以记忆变量的变化之后的值 示例如下： 外部变量extern 用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%89%8D%E7%AB%AF%2FJavaScript%2F</url>
    <content type="text"><![CDATA[JavaScript : 描述HTML文档属性。JavaScript语句是发给浏览器的命令。这些命令的作用是告诉浏览器要做的事情 JS入门初级插入JS JS文件不能直接运行，需嵌入到HTML文件中执行 JavaScript代码可以放在html文件中任何位置，但是我们一般放在网页的head或者body部分。而且JavaScript引擎有在行末自动添加分号的机制。 在HTML文档中插入 在&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;标签内插入JS脚本 在HTML中引入JS外部文件 插入方法：&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt; 注意: javascript作为一种脚本语言可以放在html页面中任何位置，但是浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面，因为初始化都要求提前进行（如给页面body设置css等）—### JS代码注释 单行注释，在注释内容前加符号 “//”。 多行注释以&quot;/*&quot;开始，以&quot;*/&quot;结束。12345678&lt;script type="text/javascript"&gt; document.write("单行注释使用'//'"); // 我是注释，该语句功能在网页中输出内容 /* 多行注释 养成书写注释的良好习惯 */&lt;/script&gt;—### JS数据结构#### 数组定义： var arr_name=new Array(); var arrayObj = new Array([size]);: 创建一个数组并指定长度，注意不是上限，是长度 var myarray= new Array(8);: 创建数组，存储8个数据。 var name=[&quot;zhangsan&quot;,&quot;lisi&quot;];: 创建一个数组并赋值* var name=new Array(&quot;zhangsan&quot;,&quot;lisi&quot;);注意： 创建的新数组是空数组，没有值，如输出，则显示undefined。 虽然创建数组时，指定了长度，但实际上数组都是变长的 如果设置了数组长度，那么代码在执行的时候会在初始时就给数组分配一个空间，以后的每次给数组赋值就会更加快捷。 示例：1234567var myarr=new Array(); //定义数组myarr[0]=80; myarr[1]=60;myarr[2]=99;document.write("第一个人的成绩是:"+myarr[0]);document.write("第二个人的成绩是:"+myarr[1]);document.write("第三个人的成绩是:"+myarr[2]); 多种用法一、数组元素的添加 push() 、 unshift() 、 splice() arrayObj. push([item1 [item2 [. . . [itemN ]]]]);:将一个或多个新元素添加到数组结尾，并返回数组新长度 arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]);:将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度 arrayObj.splice(insertPos,0,[item1[, item2[, . . . [,itemN]]]]);:将一个或多个新元素插入到数组的指定位置，插入位置的元素自动后移，返回””。 二、数组元素的删除 pop() 、 shift() 、 splice() arrayObj.pop();:移除最后一个元素并返回该元素值 arrayObj.shift();:移除最前一个元素并返回该元素值，数组中元素自动前移 arrayObj.splice(deletePos,deleteCount);:删除从指定位置deletePos开始的指定数量deleteCount的元素，数组形式返回所移除的元素 三、数组的截取和合并 arrayObj.slice(start, [end]);: 以数组的形式返回数组的一部分，注意不包括 end对应的元素，如果省略 end 将复制 start 之后的所有元素 arrayObj.concat([item1[, item2[, . . . [,itemN]]]]);:将多个数组（也可以是字符串，或者是数组和字符串的混合）连接为一个数组，返回连接好的新的数组 四、数组的拷贝 arrayObj.slice(0);:返回数组的拷贝数组，注意是一个新的数组，不是指向 arrayObj.concat();:返回数组的拷贝数组，注意是一个新的数组，不是指向 五、数组元素的排序 arrayObj.sort();: 对数组元素排序，返回数组地址 arrayObj.reverse();: 反转元素（最前的排到最后、最后的排到最前），返回数组地址 六、数组元素的字符串化 arrayObj.join(separator);: 返回字符串(这个字符串将数组的每一个元素值连接在一起)中间用 separator 隔开 成员数量(数组属性length) 如果我们想知道数组的大小，只需引用数组的一个属性length。Length属性表示数组的长度，即数组中元素的个数。 语法：myarray.length; 显示数组长度 document.write(arr.length); 注意:，JavaScript数组的length属性是可变的#### 二维数组的表示语法二维数组的表示: myarray[ ][ ]##### 二维数组的定义方法一、 采用两重内外循环的方式来定义二维数组,分别定义一维、二维数组1234567var myarr=new Array(); //先声明一维 for(var i=0;i&lt;2;i++)&#123; //一维长度为2 myarr[i]=new Array(); //再声明二维 for(var j=0;j&lt;3;j++)&#123; //二维长度为3 myarr[i][j]=i+j; // 赋值，每个数组元素的值为i+j &#125; &#125;二、 直接对二维数组进行赋值1var Myarr = [[0 , 1 , 2 ],[1 , 2 , 3]]三、示例(小A’,’女’,21,’大一’), (‘小B’,’男’,23,’大三’),(‘小C’,’男’,24,’大四’), (‘小D’,’女’,21,’大一’)1234567var infos = [ ['小A','女',21,'大一'], ['小B','男',23,'大三'], ['小C','男',24,'大四'], ['小C','男',24,'大四'], ['小D','女',21,'大一'],];#### JS—MAP&gt;最新的ES6规范引入了新的数据类型Map。要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器：1234'use strict';var m = new Map();var s = new Set();console.log('你的浏览器支持Map和Set！');##### MapMap是一组键值对的结构，具有极快的查找速度。示例：获取学生成绩 | 用法集合12345var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95m.set('Adam', 67); // 添加新的key-valuem.has('Adam'); // 是否存在key 'Adam': truem.delete('Adam'); // 删除key 'Adam'##### SetSet和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。示例：创建集合 | 用法集合12345var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3s.add(4);s; // Set &#123;1, 2, 3, 4&#125; 向Set添加元素s.delete(3); // 向Set删除元素重复的元素在Set中会被自动过滤12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, "3"&#125;&gt; Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。##### 迭代对象 iterable为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。具有iterable类型的集合可以通过新的for ... of循环来遍历。测试你的浏览器是否支持：12345'use strict';var a = [1, 2, 3];for (var x of a) &#123;&#125;console.log('你的浏览器支持for ... of');使用for ... of循环遍历集合，用法如下：123456789101112var a = ['A', 'B', 'C'];var s = new Set(['A', 'B', 'C']);var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);for (var x of a) &#123; // 遍历Array console.log(x);&#125;for (var x of s) &#123; // 遍历Set console.log(x);&#125;for (var x of m) &#123; // 遍历Map console.log(x[0] + '=' + x[1]);&#125;更好的方式是直接使用iterable内置的forEach方法，它接收一个函数，每次迭代就自动回调该函数。以Array为例：123456789'use strict';var a = ['A', 'B', 'C'];a.forEach(function (element, index, array) &#123; // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index);&#125;);&gt; forEach()方法是ES5.1标准引入的，你需要测试浏览器是否支持。Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：1234var s = new Set(['A', 'B', 'C']);s.forEach(function (element, sameElement, set) &#123; console.log(element);&#125;);Map的回调函数参数依次为value、key和map本身：1234var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);m.forEach(function (value, key, map) &#123; console.log(value);&#125;);—### JS文本标签 一. document.write()&gt; 可用于直接向 HTML 输出流写内容。简单的说就是直接在网页中输出内容。示例：1234&lt;script&gt; var str="hello"; document.write(str+"world"+"&lt;br&gt;");&lt;/script&gt; 二. .getElementById()函数 document.getElementById(),获取DOM节点&gt; 用.getElementById()函数 获取到id的所有标签,而获去标签的目的 往往是对这些标签进行操作，假如是文本标签，就可以进行改变字体颜色、大小等操作实例： 修改p1的文档属性和输出 hello1234&lt;script type="text/javascript"&gt; document.write("hello"); document.getElementById("p1").style.color="blue";&lt;/script&gt; 解释： document.write(&quot;hello&quot;) : 打印在网页中——网页输出 alert(&quot;hello&quot;) : 打印在对话框里————调试输出* console.log(&quot;hello&quot;) : 打印在控制台———控制台输出 三、 JS警告(alert 消息对话框) 语法：alert(字符串或变量)须知:1. 在点击对话框”确定”按钮前，不能进行任何其它操作。2. 消息对话框通常可以用于调试程序 四、 JS确认(confirm 消息对话框)&gt; 用途：向用户确认是否要执行某项操作时，可以添加 语法：confirm(str)返回值： Boolean 值 当用户点击”确定”按钮时，返回true 当用户点击”取消”按钮时，返回false&gt; confirm 消息对话框通常用于允许用户做选择的动作。弹出对话框(包括一个确定按钮和一个取消按钮)。实例： 通过confirm返回的布尔值进行下一步操作123456789&lt;script type="text/javascript"&gt; var test=confirm("hello"); if(test=true) &#123; document.write("you") ;&#125; else &#123; document.write("me"); &#125;&lt;/script&gt;注意: 消息对话框是排它的，即用户在点击对话框按钮前，不能进行任何其它操作。 五、 JS提问 (prompt 消息对话框)语法：prompt(str1,str2);&gt; 其中 str1: 要显示在消息对话框中的文本，不可修改 ；str2：文本框中的内容，可以修改，分两次显示 点击确定按钮，文本框中的内容将作为函数返回值 点击取消按钮，将返回null—## JavaScript变量&gt; 变量是用于存储某种/某些数值的存储器### 定义变量JS 定义变量： var 变量名 变量名取法须知： 开头不能为数字 开头不能为除($)外的特殊符号，如(% + / 等)* 开头中间不能使用除( $)外的特殊符号，如(% + / 等)* 不能使用JS关键字作为变量名注意：变量必须使用字母、下划线(_)或者美元符($)开始例子：123var my_test;my_test="javascript";var my_num= "26";注意：变量虽然也可以不声明，直接使用，但不规范，需要先声明，后使用。另外，变量是弱类型的。 内嵌变量的另一写法与调用**语法：var test={ fun_name:function(){} }1234567891011&lt;script type="text/javascript"&gt; var i=&#123; alertWord:function()&#123; var j=confirm("准备好了？"); if(j===true)&#123;alert("恭喜您，已经掌握此技能。")&#125; else&#123;alert("请重新学习课程内容吆，直到实践编写代码与实践要求一致!")&#125; &#125;,&#125;&lt;/script&gt;&lt;form &gt; &lt;input type="button" onclick="i.alertWord()" value="请点击确认" /&gt;&lt;/form&gt;注意： 在函数里面声明的变量，加var 就是局部变量，只能在此函数内使用，超出范围调用这个变量是不存在的。在函数里面没加var就是全局变量了 在函数外不论有没有用var声明的变量都是全局变量，整个JS代码范围内都可以调用它。 JS变量作用域在JavaScript中，用var申明的变量实际上是有作用域的。若在函数体内申明变量，则该变量的作用域为整个函数体，而在函数外不可引用该变量 关于嵌套函数的变量 注意在嵌套函数中，内部的函数可以访问外部函数的变量，而外部函数不能访问内部变量而且JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找，如下例：123456789function foo() &#123; var x = 1; function bar() &#123; var x = 'A'; console.log('x in bar() = ' + x); // 'A' &#125; console.log('x in foo() = ' + x); // 1 bar();&#125;### 变量提升JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部举例子：1234567function foo() &#123; var x = 'Hello, ' + y; console.log(x); var y = 'Bob';&#125;foo();在代码中，y虽然在后面申明，但是var x =&quot;hello,&quot; + y并不会报错，但是显示console.log(x);结果为hello, undefined,这是因为JS引擎提升Y变量的申明，但是不会提升Y的赋值### 全局作用域不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：示例：alert(window.course); ### 局部作用域 由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的： 12345678'use strict';function foo() &#123; for (var i=0; i&lt;100; i++) &#123; // &#125; i += 100; // 仍然可以引用变量i&#125;; 然而为了解决块级作用域，ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量 123for (let i=0; i&lt;100; i++) &#123; sum += i; &#125; ### 常量 ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域： 12const PI = 3.1415926PI = 3 ; // 在某些浏览器中不会报错，但无效果 ### 解构赋值 从ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。 **解构赋值**可以忽略某些元素,如下例： 12let [, , z] = ['i', 'love', 'you']; // 忽略前两个元素，只对z赋值第三个元素z; // 'you' ### 使用场景 解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量： 12var x=1, y=2;[x, y] = [y, x] --- ## JavaScript判断语句 **基本判断** 语法： 1234567if(条件1)&#123; 条件1成立时执行的代码 &#125;else if(条件2)&#123; 执行条件3成立的代码&#125;else&#123; 条件都不成立时执行的代码 &#125; **三元运算符** （条件?真成立:假成立） **switch case** &gt;每一种case情况下都要加break，如果不加break，不管后面的代码是否成立都会被执行 **自加与自减符号** 12mynum = mynum + 1;//等同于mynum++mynum = mynum - 1;//等同于mynum-- **逻辑与操作符** | 逻辑操作符 | 意思 | 示例 | |-----|-----|-----| | &amp;&amp; | 与 |A &amp;&amp; B| | || | 或 |A || B| |!| 非 |!(A)| **操作符的优先级** * 除法、乘法等操作符的优先级比加法和减法高 * 若改变运算顺序，需添加括号的方法来改变优先级 * 操作符之间的优先级（高到低）: **算术操作符 → 比较操作符 → 逻辑操作符 → &quot;=&quot;赋值符号** --- ## JS函数 定义： 1234function 函数名()&#123; 函数代码;&#125; **函数调用:**函数定义好后，是不能自动执行的，所以需调用它,只需直接在需要的位置写函数就ok了 实例： 嵌入式网页调用函数,onlick使用 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;函数调用&lt;/title&gt; &lt;script type="text/javascript"&gt; function contxt() //定义函数 &#123; alert("调用函数!"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input type="button" value="点击我" onclick="contxt()" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; **函数参数获取** ES6标准引入了rest参数，函数举例如下： 1234567891011121314151617function foo(a, b, ...rest) &#123; console.log('a = ' + a); console.log('b = ' + b); console.log(rest);&#125;foo(1, 2, 3, 4, 5);// 结果:// a = 1// b = 2// Array [ 3, 4, 5 ]foo(1);// 结果:// a = 1// b = undefined// Array [] &gt;rest参数只能写在最后，前面用…标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest如果参数没有传满，rest参数会接收一个空数组(并不是undefined`)默认参数与传入参数 设置默认参数，若用户自己传入参数，则替代默认参数 方法： 三则运算符 ： var_1 = var_1?var_1:num ; if判断语句： if(var_1 == undefined) { var_1 = num ;} 函数返回值 return的多行写法: 12345function foo() &#123; return &#123; // 这里不会自动加分号，因为&#123;表示语句尚未结束 name: "keith" &#125;;&#125; JS–新窗口 (window.open/close) open() 方法可以查找一个已经存在或者新建的浏览器窗口 语法：window.open([URL], [窗口名称], [参数字符串]) 参数说明： URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。 窗口名称：可选参数，被打开窗口的名称。 该名称由字母、数字和下划线字符组成。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。 name 不能包含有空格。 注意：参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。 参数列表 实例：打开百度，在另一页面打开，页面大小自行设定，无工具栏 123&lt;script type="text/javascript"&gt; window.open("http://www.baidu.com", "_blank", "width=300,height=200,toolbar=no")&lt;/script&gt; close()关闭窗口 用法：window.close(); 或 &lt;窗口对象&gt;.close(); //关闭指定的窗口 实例:关闭新建的窗口。1234&lt;script type="text/javascript"&gt; var mywin=window.open('http://www.imooc.com'); //将新打的窗口对象，存储在变量mywin中 mywin.close();&lt;/script&gt; 初识DOMDOM(Document Object Model):文本对象模型定义访问和处理HTML文档的标准方法。 DOM将HTML文档呈现为带有元素、属性和文本的树结构 实例： 简单的DOM节点层次图 常见的DOM节点 元素节点： html 、body、p 文本节点： 向用户展示的内容，例如 &lt;li&gt; 中的JS,DOM,CSS等文本 属性节点： 元素属性，如 &lt;a&gt;标签属性 href 通过ID获取元素获取对象标签 标签的id属性值是唯一的，可以通过getElementById(“id”)来获取 语法：document.getElementById(&quot;id&quot;) 注意：获取的元素是一个对象，若对元素进行操作，则需要通过它的属性或方法 一般标签返回值为： null 或 [object.HTMLParagraphElement] 解释： 结果为null是因为，JavaScript没有找到id名为“con”的标签，所以返回null 结果为[object HTMLParagraphElement]，则说明JavaScript找到了id名为“con”的标签，以对象的形式返回该标签 获取标签元素的内容 innerHTML属性用于获取或替换HTML元素的内容 **语法：Object.innerHTML 解释： Object是获取的元素对象，如通过 document.getElementById(“id”)获取 实例：1234&lt;script type="text/javascript"&gt; var mycon= document.getElementById("con"); document.write("p标签内容"+mycon.innerHTML);&lt;/script&gt; 注意:如果将mycon的内容进行修改，则HTML原文档中的mycon对应的对象内容也会随之改变 改变HTML样式基本样式 HTML DOM 允许 JS 改变HTML的元素样式 语法：Object.style.property=new style; 基本属性表 width、height设置需要加上px 实例： 改变 p 标签的背景颜色12345&lt;p id="con"&gt;Hello world!&lt;/p&gt;&lt;script&gt; var mycon=document.getElementById("con"); mycon.style.backgroundColor = 'green';&lt;/script&gt; 显示和隐藏(display属性) 网页中的显示和隐藏的效果均可以通过display属性设置 语法：Object.style.display= value value取值 用处 none 该元素会被隐藏 block 该元素会被显示为块级元素 示例： 设置隐藏段落内容按钮12345678910&lt;script type="text/javascript"&gt; function hide() &#123; document.getElementById("con").style.display ="none"; &#125;&lt;/script&gt;&lt;p id="con"&gt;这是要隐藏的段落内容&lt;/p&gt;&lt;form &gt; &lt;input type="button" onclick="hide()" value="隐藏段落内容"&gt;&lt;/form&gt; 控制类名 (className属性) className属性可以设置或返回元素的class属性 语法：Oject.className=classname 用处： 获取元素的class属性 为网页的某个元素指定一个css样式 示例： 搭配css设置修改元素的样式123456789101112131415161718192021222324252627282930&lt;style&gt; body&#123; font-size:16px;&#125; .one&#123; border:1px solid #eee; width:230px; height:50px; background:#ccc; color:red; &#125; .two&#123; border:1px solid #ccc; width:230px; height:50px; background:#9CF; color:blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;p id="con" class="one"&gt;JavaScript样式&lt;/p&gt; &lt;form&gt; &lt;input type="button" onclick="change_style()" value="点击修改样式"&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt; var mycon=document.getElementById("con"); function change_style() &#123; mycon.className="two"; &#125; &lt;/script&gt;&lt;/body&gt; 重新设置JS属性语法：Object.removeAttribute(&quot;style&quot;); 实例：定义”取消设置”的函数 提示:使用confirm()确定框，来确认是否取消设置。 1234567//定义"取消设置"的函数 function 取消设置() &#123; var bool = confirm("确定要重新设置？"); if (bool == true) &#123; 文本.removeAttribute("style"); &#125; &#125; 实例运用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="txttent-Type" txttent="text/html; charset=utf-8" /&gt;&lt;title&gt;javascript&lt;/title&gt;&lt;style type="text/css"&gt;body&#123;font-size:12px;&#125;#txt&#123; height:400px; width:600px; border:#333 solid 1px; padding:5px;&#125;p&#123; line-height:18px; text-indent:2em;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2 id="con"&gt;JavaScript课程&lt;/H2&gt; &lt;div id="txt"&gt; &lt;h5&gt;JavaScript为网页添加动态效果并实现与用户交互的功能。&lt;/h5&gt; &lt;p&gt;1. JavaScript入门篇，让不懂JS的你，快速了解JS。&lt;/p&gt; &lt;p&gt;2. JavaScript进阶篇，让你掌握JS的基础语法、函数、数组、事件、内置对象、BOM浏览器、DOM操作。&lt;/p&gt; &lt;p&gt;3. 学完以上两门基础课后，在深入学习JavaScript的变量作用域、事件、对象、运动、cookie、正则表达式、ajax等课程。&lt;/p&gt; &lt;/div&gt; &lt;form&gt; &lt;!--当点击相应按钮，执行相应操作，为按钮添加相应事件--&gt; &lt;input type="button" value="改变颜色" onclick="set.changeColor()"&gt; &lt;input type="button" value="改变宽高" onclick="set.changeSize()"&gt; &lt;input type="button" value="隐藏内容" onclick="set.objHide()"&gt; &lt;input type="button" value="显示内容" onclick="set.objShow()"&gt; &lt;input type="button" value="取消设置" onclick="set.offSet()"&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt; var txt=document.getElementById("txt"); var set=&#123; changeColor:function()&#123; txt.style.color="red"; txt.style.backgroundColor="#ccc"; &#125;, changeSize:function()&#123; txt.style.width="300px"; txt.style.height="300px"; &#125;, objHide:function()&#123; txt.style.display="none"; &#125;, objShow:function()&#123; txt.style.display="block"; &#125;, offSet:function()&#123; var message=confirm("你确定要重置所有设置么？"); if(message==true)&#123; txt.removeAttribute('style'); &#125; &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS循环 do while结构的基本原理和while结构是基本相同的，但是它保证循环体至少被执行一次。因为它是先执行代码，后判断条件，如果条件为真，继续循环。 123do&#123; 循环语句 &#125;while(判断条件) JS对象 JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。 示例：描述一个对象，可使用KV键值对的方式 12345var Keithxodoy=&#123; name: "keith", age: "18", school: "hust"&#125;; 注意：最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。 一、访问属性 访问属性是通过 . 操作符完成的 示例： 12Keithxodoy.name;Keithxodoy['name']; 由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性 123Keithxodoy.sex; // undefinedKeithxodoy.sex=male; // 赋予对象一个sex属性Keithxodoy.sex; // male 二、删除属性 delete 123Keithxodoy.sex; // maledelete Keithxodoy.sex // 删除对象的sex属性Keithxodoy.sex; // undefined 注意删除一个不存在的school属性也不会报错 三、检测对象是否拥有某一属性 in 12Keithxodoy.sex; // male'sex' in Keithxodoy; // true 补充：判断一个属性是否是对象自身拥有的，而不是继承得到的 hasOwnProperty(&quot; &quot;) 12Keithxodoy.sex; // maleKeithxodoy.hasOwnProperty("sex") // true Q&amp;A 如果访问一个不存在的属性会返回什么呢？ 答： JavaScript规定，访问不存在的属性不报错，而是返回undefined 如果in判断一个属性存在，这个属性是否一定属于对象？ 答： 不一定是对象的，它可能是对象继承得到。例如 toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以所有对象也都拥有toString属性。 JS函数1234function 函数名( )&#123; 函数体;&#125; 函数调用 第一种情况:在&lt;script&gt;标签内调用。 第二种情况:在HTML文件中调用，如通过点击按钮后调用定义好的函数。 JS事件什么是事件？ JavaScript 创建动态页面。事件是可以被 JavaScript 侦测到的行为。例如用户点击按钮，就发生一个鼠标单击onclick()事件。 鼠标单击事件(onclick)onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。 123456789101112131415&lt;head&gt; &lt;script type="text/javascript"&gt; function add2()&#123; var numa,numb,sum; numa=6; numb=8; sum=numa+numb; document.write("两数和为:"+sum); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;input name="button" type="button" value="点击提交" onclick="add2()" /&gt; &lt;/form&gt;&lt;/body&gt; 鼠标经过事件（onmouseover）鼠标经过事件，当鼠标移到一个对象上时，该对象就触发onmouseover事件，并执行onmouseover事件调用的程序。 12345678910&lt;script type="text/javascript"&gt; function message()&#123; confirm("请输入密码后，再单击确定!"); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form&gt;密码:&lt;input name="password" type="password" &gt;&lt;input name="确定" type="button" value="确定" onmouseover="message()" /&gt;&lt;/form&gt; 鼠标移开事件（onmouseout）鼠标移开事件，当鼠标移开当前对象时，执行onmouseout调用的程序。 123&lt;form&gt; &lt;a href="http://www.baidu.com" onmouseout="message()"&gt;点击我&lt;/a&gt;&lt;/form&gt; 光标聚焦事件（onfocus）当网页中的对象获得聚点时，执行onfocus调用的程序就会被执行。 如下代码, 当将光标移到文本框内时，即焦点在文本框内，触发onfocus 事件，并调用函数message()。 onfocus是光标聚焦，光标就是打字时闪烁的那条线，点击下拉菜单不会产生光标聚焦，而点击框里（要打字了）就会产生。 失焦事件（onblur）onblur事件与onfocus是相对事件，当光标离开当前获得聚焦对象的时候，触发onblur事件，同时执行被调用的程序。 内容选中事件（onselect）选中事件，当文本框或者文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。 需要双击文本框 文本框内容改变事件（onchange）通过改变文本框的内容来触发onchange事件，同时执行被调用的程序。 改变文本框内容后，光标离开文本框后，网页才会出现提示 加载事件（onload）事件会在页面加载完成后，立即发生，同时执行被调用的程序。 注意：1. 加载页面时，触发onload事件，事件写在&lt;body&gt;标签内。 123&lt;body onload="message()"&gt; 欢迎学习JavaScript。&lt;/body&gt; 卸载事件（onunload）当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。 注意：不同浏览器对onunload事件支持不同。 代码如下 12345678910&lt;script type="text/javascript"&gt; window.onunload = onunload_message; function onunload_message()&#123; alert("您确定离开该网页吗？"); &#125; &lt;/script&gt; &lt;/head&gt;&lt;body&gt; 欢迎学习JavaScript。&lt;/body&gt; 疑问解构赋值用法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Basic_Distinguish]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%90%86%E8%AE%BA%2F%E6%A6%82%E5%BF%B5%E8%BE%A8%E5%88%AB%2F</url>
    <content type="text"><![CDATA[当一个类实例被创建时，__init__()方法会自动执行目的为执行一些对象的必要的初始化工作 123def __init__(self, name, symbol): self.name = name self.symbol = symbol 我们通过实现init()方法来初始化对象。当一个对象被创建，Python首先创建一个空对象并为该新对象调用__init__()方法。这个方法函数通常用来创建对象的实例变量并执行任何其他一次性处理。 注意： __init__只能返回None对象,不能返回任何实例化返回值 在其他面向对象编程中通常使用 this 12345class MyClass(object):def __new__(cls, *args, **kwargs): ...# 实例化myclass = MyClass(*args, **kwargs) 第一个参数cls是当前正在实例化的类。如果要得到当前类的实例，应当在当前类中的new()方法语句中调用当前类的父类 的new()方法。 例如，如果当前类是直接继承自object，那当前类的new()方法返回的对象应该为：123def __new__(cls, *args, **kwargs): ... return object.__new__(cls) _new_()与_init_()的区别 _new_作用于_init_之前。前者可以决定是否调用后者，或者说可以决定调用哪的init方法。Python 中的 _new_ 方法负责创建一个实例对象，_init_ 方法负责将该实例对象进行初始化 2.__init__是在类实例创建之后调用，而__new__方法正是创建这个类实例的方法,__new__产生的实例也就是__init__里面的self __new__(cls[,...}) class 参数会原封不动地传给init]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Basic]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%90%86%E8%AE%BA%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[继续（换行分隔）: \ Python解释器执行12345#！/usr/bin/python #第一行是特殊注释行，称之为组织行，用来告诉我们GUN/Linux系统应该使用哪个解释器来执行#-*-coding:utf-8-*-#FileName: #Author:#Date: Python风格==Pythonic== PEP PEP7 PEP8 PEP257OOP-Python面向对象 面向对象概述：(ObjectOriented ,OO) OOP思想 几个名词 OO:面向对象 OOA:面向对象的分析 OOD：面向对象的设计 OOI：面向对象的实现 OOP：面向对象的编程 OOA–&gt;OOD–&gt;OOI:面向对象的实现过程 变量运算符 : =/!= 运算符 &gt;（ ）运算符 &gt; not 运算符 &gt; or/and 运算符12345678910#在函数内使用全局变量num = 1def f: global num print(num) num = 200 print (num)#从非空序列中随机选择元素random.choice(sequence) 生成器 generator返回值：返回生成器。1234567891011121314151617181920# 实例# 以下实例展示了 xrange 的使用方法：# 占用内存小&gt;&gt;&gt;xrange(8)xrange(8)# 通过list方法，将生成器xrange内容给生成出来&gt;&gt;&gt; list(xrange(8))[0, 1, 2, 3, 4, 5, 6, 7]&gt;&gt;&gt; range(8) # range 使用[0, 1, 2, 3, 4, 5, 6, 7]&gt;&gt;&gt; xrange(3, 5)xrange(3, 5)&gt;&gt;&gt; list(xrange(3,5))[3, 4]&gt;&gt;&gt; range(3,5) # 使用 range[3, 4]&gt;&gt;&gt; xrange(0,6,2)xrange(0, 6, 2) # 步长为 2&gt;&gt;&gt; list(xrange(0,6,2))[0, 2, 4] yieldyield: 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面(右边)的值。在下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行，可以理解为每执行完一次迭代，yield会记住上一次迭代的位置，然后在下一次迭代开始时，从上一次位置的下一位开始，再执行yield后的命令 运用: 在一堆有规律或者有着固定顺序（类似数列）的数据中，需要按照一定规律，将数据分类时，可以使用yield生成器来完成 利用递归生成器处理嵌套问题–树状问题123456789# 解释：当展开元素为单个元素时，会引发TypeError，则只会生成该元素的生成器# 当展开多层元素时，可以分层展开，利用faltten()递归def faltten(nested): try: for sublist in nested: for element in faltten(sublist): yield element except TypeError: yield nested 123456789101112# 利用生成器检查展开对象是否为类似字符串的对象def faltten(nested): try: # 不要迭代类似字符串的对象 try: nested + '' # 通过和字符串的拼接来检查 except TypeError: pass # 对非字符串对象不做处理 else : raise TypeError # 对字符串对象进行报错 for sublist in nested: for element in faltten(sublist): yield element except TypeError: yield nested 匿名函数 – lambda 函数无固定名123sum = lambda a,b:a+bprint(sum(10,20))#变量名 = lambda 参数1，参数2，。。。: 表达式 列表列表方法 引用方法：对象.方法(参数)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495961.append -----在列表末尾追加新的对象&gt;&gt;&gt;lst =[1,2]&gt;&gt;&gt;lst.append(3)&gt;&gt;&gt;lst[1,2,3]2.count -----统计某个元素在列表中出现的次数&gt;&gt;&gt;x =[1,1,1,2,3]&gt;&gt;&gt;x.count(1)33.extend -----用新列表来拓展原有列表&gt;&gt;&gt;a= [1,2]&gt;&gt;&gt;b= [3,4]&gt;&gt;&gt;a.extend(b)&gt;&gt;&gt;a[1,2,3,4]# 该方法与原始的列表连接不同(a+b),该方法返回的是一个全新的列表# 若要添加多个元素，则在括号内用列表例如：x.extend(['a','b'])4.index -----从列表中找出某个值的第一个匹配项的索引位置&gt;&gt;&gt;x =[a,b,c]&gt;&gt;&gt;x.index(c)&gt;&gt;&gt;25.insert -----将对象插入到列表中&gt;&gt;&gt;numbers = [1,2,3,4,5]&gt;&gt;&gt;numbers.insert(3,'four') #（）逗号前 3 为插入的位置，逗号后为插入的内容&gt;&gt;&gt;numbers[1,2,3,'four',4,5]6.pop -----移除列表中的一个元素&gt;&gt;&gt;x= [1,2,3]&gt;&gt;&gt;x.pop() #若括号内为空，则默认移除最后一个元素3 #注意这里pop方法返回了元素值，且pop方法为唯一一个既能修改列表又返回元素值的列表方法&gt;&gt;&gt;x[1,2]# Tip:使用pop方法可以实现一种数据结构——栈。栈的原理如堆放盘子，只能在顶部放一个盘子# 也只能从顶部拿走一个盘子，即后进先出（LIFO)# Python没有入栈的方法，但可以用append代替，。如果入栈刚刚出栈的值，则列表不变7.remove -----用于移除列表中某个值的第一个匹配项&gt;&gt;&gt;x = [1,2,1]&gt;&gt;&gt;x.remove(1)&gt;&gt;&gt;x[2,1] #只移除第一个匹配项8.reverse ----将列表中的元素反向存放&gt;&gt;&gt;x =[1,2,3]&gt;&gt;&gt;x,reverse()&gt;&gt;&gt;x[3,2,1]# Tip:如果需要对一个序列进行反向迭代，使用reversed函数，返回一个迭代器对象9.sort -----将列表中的元素按照一定的顺序排列，无副本，只对原列表直接改变&gt;&gt;&gt;x =[2,3,1]&gt;&gt;&gt;x.sort() #虽然sort方法修改了x却返回了空值&gt;&gt;&gt;x[1,2,3]如果需要副本，可以自建&gt;&gt;&gt;x =[2,1,3]&gt;&gt;&gt;y =x[ : ] #这里【 ： 】相当于strcpy，不能直接 y = x如果使用y=x，则改变x的值，也会同时改变y，因为x为y的原列表&gt;&gt;&gt;y.sort()&gt;&gt;&gt;&gt;x[2,1,3]&gt;&gt;&gt;y[1,2,3] #既保留了原列表x,又创建了新列表y倒序 x.sort(reverse=True)10.高级排序cmp 比较&gt;&gt;&gt;x =[2,1,3]&gt;&gt;&gt;x.sort(cmp)&gt;&gt;&gt;x[1,2,3]# 这里sort方法有两个可选参数，也称为关键字参数：key 和 reverse# 此类函数不是直接来确定对象大小，而是为每个元素创建一个键，根据键来排序例：&gt;&gt;&gt;x =['abc','a','ab'] &gt;&gt;&gt;x.sort(key = len ) &gt;&gt;&gt;x ['a','ab',abc']# 另一个关键字参数reverse是布尔值&gt;&gt;&gt;x =[1,2,3]&gt;&gt;&gt;x.sort(reverse =True)&gt;&gt;&gt;x[3,2,1]11.enumerate迭代器# 将列表中的index和value以元组的形式表示出来list(enumerate（x）) 元组1.元组大部分时候通过圆括号括起来2.空元组 &gt;&gt;&gt;()3.一个值的元组 &gt;&gt;&gt;42, #元组加逗号是十分关键的 更新元组x = (1,2)x = x[ :1] +(‘0,’ )+x[1: ]xx = (1,2,3)12#优先级，索引，内容(prioroty,index,item) 构建一键多值123456789#collections模块中的defaultdict类from collections import defaultdictd = defaultdict(list)d['a'].append(1)d['a'].append(2)d = defaultdict(set)d['a'].add(1)d['a'].add(2) 字典1234oni = &#123;"name"="chen","id"=4545&#125;oni.keys() #查看键oni.values() #查看值oni.items() #查看键值 wd 为汉字编码 注意：1.字典中的键不可以重复，会返回后面的值2.字典中的键是任意可hash对象（不可变对象，如数字，元组，字符串） 格式化字符串 format:字符串格式化的一种方式 12345"我是&#123;&#125;会".format(1)"我是&#123;&#125;会".format([1,2,3])"我是&#123;&#125;会".format(&#123;1,2,3&#125;)"我是&#123;&#125;会&#123;&#125;".format(&#123;1,2,3&#125;,[1,2,3])"我是&#123;&#125;会&#123;&#125;".format(&#123;1,2,3&#125;,1) 列表推导式 帮助生成包含一组数据的列表[i+10 for i in range(10)] —&gt; [10,11, ,19] 与字符串一起使用 [&quot;10月{}日&quot;.format(i) for i in range(1,10)]—&gt;[“10月1号”，“10月2号”， ]list[0]将列表第一个元素转换 字典推导式 帮助我们快速生成包含一堆数据的字典12&#123;i+10:i for i in range(10)&#125; #&#123;10:0,11:1, ,19:9&#125;&#123;"a&#123;&#125;".format(i):10 for i in range(3)&#125; #&#123;"a&#123;0&#125;":10,,,,&#125; 三元运算 if 后面的条件成立，就把i前面的结构赋值给a，否则把else后面的结果赋值给a1a=10 if 4&gt;2 else 20 # a = 10 12345678910111213141516"let's learn %r" % "python"#格式化%可以为s,d,r,其中r可以打印任何内容#%r用来调试最好，%s和其他格式符用来向用户显示变量 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 %.xf 表示将小数中小数点后面的位数固定到x位如果小数的位数比x大，则保留x位小数eg: 12\&gt;&gt;&gt; "%.3f" % 3.1415926'3.142' 如果小数的位数比x小，则用0补足eg:12\&gt;&gt;&gt; "%.4f" % 3.1'3.1000' 浮点数四舍五入 round() :round(1.733) if __name__ == &quot;__main__&quot;作用 让Python知道该模块是作为程序运行还是导入到其他程序中 模块sys 模块 &amp; os模块分别作用 sys模块负责程序与Python解释器的交互提供了一系列函数和变量用于操控Python运行时的环境 os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口 sys模块内容sys.path : 查找模块所在的目录列表. 若要在与解释器不同路径下导入模块，则需要在解释器路径下添加路径sys.path.append(&quot;路径&quot;) sys.argv: 「argv」是「argument variable」参数变量的简写形式，一般在命令行调用的时候由系统传递给程序。这个变量其实是一个List列表，argv[0] 一般是被调用的脚本文件名或全路径，和操作系统有关，argv[1]和以后就是传入的数据了。 os模块内容 命令 命令 作用 os.linesep 在当前平台使用的行终止符 包（package) 创建一个文件夹，用于存放相关的模块，文件夹的名字即为包的名字 在文件夹中创建一个__init__.py的模块文件，内容可以为空 将相关的模块放入文件夹中 调用方法 ：import M1.module 函数1234#运行，调用，使用函数为同一个意思def print_two(*args):#*代表可以接收所有参数def print_two_again(arg1,arg2) eval()eval(): 是程序语言中的函数，功能是获取返回值，不同语言大同小异，函数原型是返回值 = eval( codeString )，如果eval函数在执行时遇到错误，则抛出异常给调用者。 语法eval(expression[, globals[, locals]])有三个参数，表达式字符串，globals变量作用域，locals变量作用域。 其中第二个和第三个参数是可选的。 如果忽略后面两个参数，则eval在当前作用域执行。实例:123a=1eval("a+1")2 如果指定globals参数12345a=1g=&#123;'a':10&#125;eval("a+1",g)11 如果指定locals参数123456a=10b=20c=20g=&#123;'a':6,'b':8&#125;l=&#123;'b':9,'c':10&#125;eval("a+b+c",g,l) Help(模块名) help(模块.函数名) 这是得到模块帮助文档的方式，所谓帮助文档就是定义函数时放在”‘ ‘“之间的东西，也被称为文档注释 name 用于检测主程序代码中的模块是被导入还是被直接执行 如果模块是被导入，则__name__的值为模块名字 如果模块是被直接执行，则__name__的值为&#39;__main__&#39; 类 新式类与旧式类: python的新式类是2.2版本引进来的，官方给的解释是：为了统一类(class)和类型(type)。在2.2之前，比如2.1版本中，类和类型是不同的，如a是ClassA的一个实例，那么a.class返回 ‘ class main.ClassA‘ ，type(a)返回总是。而引入新类后，比如ClassB是个新类，b是ClassB的实例，b.class和type(b)都是返回‘class ‘main.ClassB’ ，这样就统一了。 类的实例化12if __name__ == '__main__':Spider(param) 使用 class 关键字定义类，可以选择提供一个父类或者说基类123456789101112class Filter: def init(self): self.blocked=[] def filter(self,sequence): print ([x for x in sequence if x not in self.blocked])#Spam_Filter是Filter的子类class Spam_Filter(Filter):#重写Filter超类中的init方法 def init(self): #过滤的元素序列 self.blocked = [1] Filter是用于过滤序列的通用类1234&gt;&gt;&gt; f = Spam_Filter()&gt;&gt;&gt; f.init()&gt;&gt;&gt; f.filter([1,2,3])&gt;&gt;&gt; [2,3] Python内建 issubclass :判断一个类是否是另一个类的子类12issubclass(Spam_Filter,Filter)True 查看子类的基类 ： bases 123print (Spam_Filter.__bases__)(&lt;class __main__.Filter at 0x171e40&gt;.)#若无基类，则返回一个空序列 查看对象属于哪一个类 ： class 12print (f.__class__)&lt;class __main__.Spam_Filter at 0x1707c0&gt; 调用绑定类的方法时，使用类名Teacher.say() 继承注意: 若子类继承了父类，但是在子类中，==父类的构造方法被重写==，即__init__内容被改变， 且新的构造方法中==没有任何关于初始化父类构造方法中特性的代码==，则会发生异常 python （未）绑定方法解释 —绑定方法: 在调用一个实例的方法时，该方法的self参数会被自动绑定到实例上 因为绑定方法的缘故，若在子类中使用父类的方法，且在子类中新的构造方法没有关于初始化新特性的代码，故程序会报错 解决方案 在子类函数中直接调用类的方法，例如Bird.__init__(self),则实例就不会被绑定，就可以自由地提供需要的self参数例子 1234class songbird(Bird): def __init__(self): Bird.__init__(self） # 在子类构造函数中使用父类的构造方法 self.sound = ’squawk’ 使用Super函数在子类的构造函数中直接使用Super()函数，在python3.0之后版本中Super中可以不带任何参数 1234class songbird(Bird): def __init__(self): super().__init__() self.sound = ‘squawk’ 接口（“协议”）与内省hasattr(对象名,&#39;方法&amp;特性&#39;,None): 检测特性是否存在 getattr(对象名,&#39;方法&amp;特性&#39;,None): 直接访问特性，若特性不存在，则返回None setattr(对象名,&#39;方法&amp;特性&#39;,&#39;内容&#39;): 设置对象的特性 私有方法(成员) Python的私有不是真的私有，是一种成为name mangling的改名策略可使用对象.__classname_attribuename访问12# 在方法名前加上双下划线__即可def __func(self): 异常处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465try: a = 100 c = a+'a'except TypeError as f: print("出错"，f)except NameError as f: print("出错"，f)# else使你可以编写只有在try子句中没有遇到任何异常时才能运行的代码。# finally使您能够执行应始终运行的代码段，无论是否遇到任何异常。# 捕捉异常#若对异常不进行处理try: a = 100 c = a+'a'except: pass#对所有异常类型的处理except Exception as f: print("Exception",f)finally: print("最终输出")# 打印错误内容except (TypeError,NameError) as e: print(e)# 用一个块来捕捉异常,用元组列出try: a = 100 c = a+'a'except (TypeError,NameError): print('Error')#抛出（制造）异常a = 1b = 2c = a+braise TypeError("你就是错了")raise Exception(' ')# 屏蔽异常class MuffledCalculator: muffled = False def calc(self,expr): try: # eval()是程序语言中的函数，功能是获取返回值，不同语言大同小异 # 函数原型是返回值 = eval( codeString ) # 如果eval函数在执行时遇到错误，则抛出异常给调用者。 return eval(expr) except ZeroDivisionError: # 当给muffled赋值为True时，关闭屏蔽 if self.muffled: print 'Division by zero is illegal' else: raise# 嵌套加入else子句try: print('a')except: print('b')else: print('c')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fjson%2F</url>
    <content type="text"><![CDATA[认识json 1.全称：JavaScript Object Notation 另称：轻量级的传输文件 2.Json是一个字符串！独立于语言，独立于平台。一种保存数据的格式 作用：可以保存本地的json文件，也可以将json串进行传输 组成：{ } [ ] : , 3.Json使用了JS语法 4.Json用于交换数据 5.Json为纯字符串，字符串强制为双引号，Json的key只能为字符串 1234import jsonjson.loads() #将json转化为字典response.json()json.dumps() #将字典转化为json 1234567#读取本地的json文件path = r"C/dizhi/jsonfile.json"with open(path,"rb") as f: #用load不用loads data = json.load(f) #返回字典 print (data) 12345678#写本地jsonpath = r"C/lujing/test.json"jsondata = &#123;" ":" "," ":" "&#125;with open(path , "w") as f: json.dump(jsondata,f) 1234# 写入文件with open ('c.txt','a',encoding = 'utf-8') as f: # 将文件的格式转换为中文，ensure_ascii=False f.write(json.dumps(content, ensure_ascii=False))]]></content>
      <categories>
        <category>Data_struction</category>
      </categories>
      <tags>
        <tag>data_struction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux操作]]></title>
    <url>%2F2018%2F07%2F25%2FLinux%2Flinux%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Linux 创建 README.md 文件并写入内容echo &quot;# 菜鸟教程 Git 测试&quot; &gt;&gt; README.md 设置Linux的IP地址ifconfig eth0 ip地址 添加虚拟网卡 ifconfig eth0:1 198.168.1.1 操作技巧文件部分名称+ tab ： 自动补全文件名 知识概念文件与用户的关系 所有者 u : 只有一个，但可以交换 用户组 g ： 只有一个，可以使用文件，但不是所有者 其他人 o ： 既不属于所有者，又不是用户组 格式 ： 表示文件 d ： 表示目录 l : 表示软连接 例子 ：rw- r– r– rw- : 代表文件的所有者有读写的权限，代表最高权限，不一定需要赋予所有权限，够用就行 r– : 代表赋予用户组的权限 — : 代表赋予其他人的权限 软链接 类似 Windows快捷方式，不决定原文件的权限，只是符号链接 三种用户都有所有权限 rwx ， 文件为 l 开头 ，文件大小较小 硬链接 相当于拷贝 cp -p（保留属性） + 同步更新 一个i节点对应到了两个文件 注意 ： 硬链接不能跨分区 ，而且不能针对目录使用文件操作 r(读) w(写) x(执行) 文件覆盖 y Linux命令 命令格式 命令 -选项 -参数 例子 ： ls -la /etc命令的选项可以同时使用，且不分顺序 文件命令 作用 英文 ls 目录处理命令 list ls -a 查看目录所有文件（含隐藏文件） 可以添加目录参数 ls -l 查看文件的详细信息 ls -lh 人性化显示文件信息 ls -ld /etc 只示目录本身的信息 ls -i 查看文件的i节点 （即为文件的id信息） 目录命令 英文 作用 mkdir make directories 创建新目录 mkdir -p 递归创建新目录，并且在新目录在再进行创建，可同时创建多个 cd change directories 切换目录 . 代表当前目录 ..回到上一级目录 pwd print working directories 显示当前工作目录 rmdir remove directories 删除空目录 cp copy 拷贝目录或文件 cp -rp [原文件或目录] [目标目录] r为复制目录操作 p为保留文件属性 可以同时复制多个 mv move 目录剪切 移动 mv [绝对路径] [目标路径] 若是要剪切当前路径下的文件 可以直接 mv [文件名] [目标目录] rm remove 删除文件或名录 要慎重 rm -f 强制删除 rm -r 删除目录 rm -rf 直接删除目录 文件处理 作用 例子 touch 创建空文件 touch /root/book.list cat 浏览文件内容 可以加 -n 参数 cat -n /etc/issue tac cat 的倒序显示可以倒序显示文件内容 more 分页显示文件，适合查看长文件 less 分页浏览 head 查看文件的前n行,默认为10行 head -n 8 tail 查看文件的末尾n行 tail -f /var/log/message 动态显示问文件 链接处理 作用 例子 ln /etc/issue /tmp 默认创建硬链接 ln -s 软连接 注意事项: touch 若要创建带空格文件名的文件，可touch &quot;my love&quot;,即加上双引号 最好不要在Linux中创建带有特殊符号的文件名 cat 不太适合浏览含有非常多内容的文件 more 按 空格 ： 一页一页浏览 按 回车 ： 一行一行浏览 按 q : 退出浏览 less 可以倒回去浏览内容 pageup : 一页一页往回翻 上箭头 : 一行一行往回翻 /service ： / 斜杠可以用来搜索，按 n 可以翻看下一页 注意 cp -p 该属性可以保持复制文件或目录的信息，如创建和修改的时间等 cp -r 可以在复制文件或目录时，将文件名进行修改 mv 当前目录下的文件名 要修改成的名字 可以作为文件名修改命令 注意事项目录：/proc/ /sys/ : 为系统内存和内核，只可读，写入的数据在重启时会清除，不要往内写入文件 /tmp : 临时目录，存放临时文件，建议不要存放重要文件，重启时最好清除 /var : 动态数据保存位置，注意保存缓存，日志已经软件运行产生的文件 /usr : 系统软件资源目录，为“Unix Software Resource”的缩写，用于存放系统软件资源的目录，系统安装的软件资源基本存放在此目录 服务器： 远程服务器不允许关机，只能重启 重启时应该关闭服务 不要在服务器访问高峰运行高负载命令 ，如对大数据的处理 远程配置防火墙（过滤作用）时，不要把自己踢出服务器 其他： 指定合理的密码规范并定期更新 合理分配权限 – 用户的权限越少越好 定期备份重要数据与日志，多处存储 Linux命令若未指定目录，则默认在当前目录里执行操作]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F</url>
    <content type="text"><![CDATA[启动在管理员模式下打开cmd,输入net start mysql 连接数据库mysql -u root -p 输入数据库密码 MySQL命令 code function use database； 使用数据库 show databases ； 查看数据库 create database name ： 创建一个数据库 理解数据库关系型数据库一、关系型数据库管理系统（RDBMS） RDBMS即关系数据库管理系统(Relational Database Management System),用来存储和管理的大数据量。 所谓的关系型数据库，是建立在关系模型基础上的数据库，借助于集合代数等数学概念和方法来处理数据库中的数据。 RDBMS的特点 数据以表格的形式出现 每行为各种记录名称 每列为记录名称所对应的数据域 许多的行和列组成一张表单 若干的表单组成database RDBMS的一些术语 数据库: 数据库是一些关联表的集合。 数据表: 表是数据的矩阵。在一个数据库中的表看起来像一个简单的电子表格。 列: 一列(数据元素) 包含了相同的数据, 例如邮政编码的数据。 行：一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据。 冗余：存储两倍数据，冗余降低了性能，但提高了数据的安全性。 主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键：外键用于关联两个表。 复合键：复合键（组合键）将多个列作为一个索引键，一般用于复合索引。 索引：使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录。 参照完整性: 参照的完整性要求关系中不允许引用不存在的实体,目的是保证数据的一致性。]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7%2FHEXO%2F</url>
    <content type="text"><![CDATA[友情链接主题的配置文件_config.html links 创建博客 source– _posts 命令 ： hexo n 文件名 开启微信公众号订阅 主题设置文档 搜索wechat wechat_subscriber qocde : 微信公众号的二维码图片 description : 相关描述 设置头像旋转在主题的source文件中 sidebar-author.styl文件中修改12345678&#123;border-radius: 50%;transition: 2s all;&#125;.site-author-image: hover&#123; transform: rotate(360deg);&#125; 首页文章设置阅读全文在blog文件需要添加阅读全文的位置加上&lt;!--more--&gt; 利用md修改博客 设置博客的分类与标签 1234567 tags: - xxx - xxx categories: 分类名---# 内容]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine_Learning]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%26%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%2FMachineLearning%2F</url>
    <content type="text"><![CDATA[机器学习 基础概念 训练集 :用于训练机器学习算法的数据样本集合 为算法输入大量已分类数据作为算法的训练集 特征（属性） : 通常是训练样本集的列，是独立测量得到的结果，多个特征联系起来在一起共同组成一个训练样本 特征类型 数值型，可以使用十进制数字 目标变量 分类算法中目标变量的类型通常是标称型的，被称为类别 回归算法的类型通常为连续型的 知识表示 检查机器是否已经学会了所分配的任务 监督学习内容：分类 &amp; 回归 目的：进行预测，对目标变量的分类信息进行预测 回归 主要用于预测数值型数据 无监督学习特点：无类别信息，也不会给定目标值 聚类: 将数据集合分成由类似的对象组成的多个类的过程 密度估计: 将寻找描述数据统计值的过程 Day_1步骤一 —— 导入必需数据科学库 在进行数据分析，需要两个必须常用库 —— pandas 、 Numpy 123import numpy as npimport matplotlib.pyplot as pltimport pandas as pd 步骤二 —— 设置工作目录，导入数据集数据集一般为.csv格式，且通常为表格形式。每一行都有对应的数据记录。每一个数据集都会包括两部分，独立变量（independent variable）和依赖变量（dependent variable)。 我们使用pandas中的read_csv的方式来读取数据集的内容，然后可以在Dataframe中分离矩阵和相关和不相关的向量 数据科学中很重要的一点就是建立metrics（度量，指标）。每一列都可以是一个metric。 而metrics主要包括两部分：independent variable 和 dependent variable。 12345678getwd()setwd("/working directory")dataset = pd.read_csv(filepath_or_buffer=" ")# create 独立变量vectorX = dataset.iloc[ : , : -1].values # 除了最后一列全是自变量# create 依赖变量vectoY = dataset.iloc[ : , 3].values # 最后一列作为应变量View(dataset) 解释 iloc表示取数据集中的某些行和某些列 逗号前表示行，逗号后表示列 这里表示取所有行，列取除了最后一列的所有列，因为列是应变量 机器学习的目的就是需要通过独立变量来预测非独立变量（prediction）。独立变量不会被影响而非独立变量可能被独立变量影响。 步骤三 —— 缺失值处理关于缺失值（missing value）的处理，在sklearn的preprocessing包中包含了对数据集中缺失值的处理，主要是应用Imputer类进行处理 进行处理的数据集中包含缺失值一般步骤如下： 使用字符串’nan’来代替数据集中的缺失值； 将该数据集转换为浮点型便可以得到包含np.nan的数据集； 使用sklearn.preprocessing.Imputer类来处理使用np.nan对缺失值进行编码过的 1234from sklearn.preprocessing import Imputerimputer = Imputer(missing_values= "NaN", strategy= "mean", axis= 0)imputer = imputer.fit(X[ : , 1: 3]) # (inclusive column 1, exclusive column 3, means col 1 &amp; 2)X[ : , 1: 3] = imputer.transform(X[ : , 1: 3]) # 将imputer 应用到数据 注意在data science中我们可以用NaN代替空值，但是在ML中必须要求数据为numeric。所以我们可以用mean来代替空值。### 步骤四 —— 分类数据编码分类数据一般包含标签分类值，而不是数据值。可能的变量通常限制在固定数据集中。单纯的变量值不能在数学模型等式中使用，所以我们需要对分类数据编码成数字。作法： 从sklearn.preprocessing中导入LabelEncoder类123from sklearn.preprocessing import LabelEncoder, OneHotEncoderlabelencoder_X = LabelEncoder() # 标准化标签，将标签值统一转换成range(标签值个数-1)范围内X[ : , 0] = labelencoder_X.fit_transform(X[ : , 0]) #不包括index行&gt; 简单来说 LabelEncoder 是对不连续的数字或者文本进行编号再创建一个虚拟变量 (变量dummy化)&gt; dummy variable是用0或1表示某个类别是否出现,适用于出现bool类型的结果OneHotEncoder用于处理分类变量，将变量的特征值转换为稀疏矩阵1234onehotencoder = Onehotencoder(categorical_features = [0])X = onehotencoder.fit_transform(X).toarray()labelencoder_Y = LabelEncoder() Y = labelencoder_Y.fit_transform(Y)### 步骤五 —— 将数据集分成 测试集 和 训练集将数据集分为两个部分，一个训练集，另一个用来测试所建立的模型的表现。通常分配数据比例为 80/20 。接下来采用从sklearn.model_selection库中导入train_test_split()类12from sklearn.model_selection import train_test_splitX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size= 0.2, random_state= 0)注意：原来的cross_validation模块被弃用了，改为支持model_selection这个模块### 步骤六 —— 特征缩放 (Feature scaling)feature scaling（特征缩放）的思想就是将所选特征的value都缩放到一个大致相似的范围通常来说，大部分机器学习算法都采用欧氏距离来计算两地的距离。特征在不同的量级、单位、排列上的极度不同会产生问题。高量级的数据的欧式距离的计算量会很大。由于每个变量的范围不同，如果两个变量之间差距太大，会导致距离对结果产生影响。所以我们要对数据进行一定的标准化改变。最简单的方式是将数据缩放至[0.1]或者[-1,1]之间：为使得特征标准化或Z-score统一化，需要导入 sklearn.preprocessing中的StandardScalar代码如下：1234from sklearn.preprocessing import StandardScalarsc_X = StandardScalar()X_train = sc_X.fit_transform(X_train)X_test = sc_X.fit_transform(X_test)第一天的学习结束啦，开心😄—-## Day_2 简单线性回归### 概述 使用一个简单的特征来预测将来值线性回归是一种基于非独立变量X来预测独立变量Y的方法。它假设两个变量线性相关，因此，我们需要找出X与Y的线性关系 如何寻找最合适的线来拟合在回归模型中，如果我们能够找到能使预测误差最小的线来拟合，则回归线的误差也会最小化。我们应该试图将以观察到的值与我们预测值之间的距离最小化。线性回归一般使用最小二乘法来求解函数模型级求解 β0 和 β1y = bo + b1*x1### 步骤一、处理数据运用第一天的五个步骤 Import the Libraries Import the DataSet Check for Missing Data Split the DataSet Feature Scaling12345678910import pandas as pdimport numpy as npimport matplotlib.pyplot as pltdataset = pd.read_csv('studentscores.csv')X = dataset.iloc[ : , : 1 ].valuesY = dataset.iloc[ : , 1 ].valuesfrom sklearn.cross_validation import train_test_splitX_train, X_test, Y_train, Y_test = train_test_split( X, Y, test_size = 1/4, random_state = 0)&gt; 使用matplotlib.pyplot绘制图注意：这里我们没有进行特征缩放，这是因为一般Python的library会自动进行feature scaling，所以我们不需要自己动手### 步骤二、训练训练集的简单线性回归模型下面我们将通过训练集的X_train与y_train 计算出符合训练集的曲线为了训练数据集，我们将使用sklearn.linear_model调用LinearRegression,使用regressor对象我们将使用LinearRegression类，fit()方法将对象拟合到数据集中。123from sklearn.linear_model import LinearRegressionregressor = LinearRegression()regressor = regressor.fit(X_train, Y_train) # 通过train集找到曲线### 步骤三、预测结果我们将从训练集中预测结果,将输出保存在向量Y_pred.为了预测结果，我们将使用在上一步中在regressor中使用的LinearRegression类方法1Y_pred = regressor.predict(X_test)将测试集的X_test 带入得到的曲线中，得到预测的结果y_pred，目的是为了将预测结果y_pred与测试集中的y_test进行比较，看看是否符合分布，从而确定预测是否准确### 步骤四、数据可视化最后一步为将我们的结果可视化。我们将使用matplotlib.pyplot库来制作训练集结果和测试集结果的扩散图(scatter plot)，来观察我们的模型对结果值的预测情况 可视化训练结果123456plt.scatter(X_train, Y_train, color= 'red')plt.plot(X_train, regressor.predict(X_train), color= 'blue')ply.title(" ") #显示整个图标的标题plt.xlabel(" ") # 显示X坐标的标题plt.ylabel(" ") # 显示Y坐标的标题plt.show()* 可视化测试结果1234567# Import the test resultsplt.scatter(X_test, Y_test, color= "red")plt.plot(X_test, regressor.predict(X_test), color= "blue")ply.title(" ") #显示整个图标的标题plt.xlabel(" ") # 显示X坐标的标题plt.ylabel(" ") # 显示Y坐标的标题plt.show()第2️天的学习结束啦，开心😄—## Day_3 多重线性回归### 概述多重线性回归(Multiple Linear Regression)将会不只有一个自变量，并且每个自变量拥有自己的系数且符合线性回归。多重线性回归试图使用两个或者以上的特征建立模型来适应观察线性数据。其实多重线性回归建立的步骤与简单线性回归相似。你可以用它来找出哪一个因素对预测的输出有着最大的影响，以及不同的变量是如何相互关联的。y = bo + b1x1 + b2x2 + … + bnxn### 需要满足的条件1. 满足线性性(linearity) ：独立变量和非独立变量需要满足线性性2. 应保持误差的同方差（常方差 Homoscedasticity）3. 多元正态性(Multivariate normality)：多元回归假设残差是正态分布的4. 错误的独立性(independence of errors) ：每一个变量产生的错误将会独立的影响预测结果，不会对其他变量产生影响5. 缺乏多重共线性(lack of multicollinearity)：假设在数据中很少或没有多重共线性，当特征（或独立变量）彼此不独立时发生多重共线性。### 虚拟变量在回归模型中，具有固定和无序数量值的数据值,在回归预测中我们需要所有的数据都是numeric的，但是会有一些非numeric的数据，例如性别 (男/女)，这些值会被虚拟变量代替。变量包含例如 0/1的值，，来代替表示2代表分类值的存在与否### 虚拟变量陷阱虚拟变量陷阱是两个或多个变量高度相关的场景。通俗来理解(intuitively)，就是一个变量必须被其余变量所预测。直观地说，有一个重复(duplicate)的范畴：如果我们放弃男性范畴，它在女性范畴中是固有定义的（零女性值表示男性，反之亦然vice-versa）。再通俗地理解，就拿性别来说，其实一个虚拟变量就够了，比如 1 的时候是“男”， 0 的时候是”非男”，即为女。如果设置两个虚拟变量“男”和“女”，语义上来说没有问题，可以理解，但是在回归预测中会多出一个变量，多出的这个变量将会对回归预测结果产生影响。 &nbsp;&nbsp;&nbsp;部分文字信息来自Dykin’ Blog 虚拟变量陷阱的解决方法： 删除分类变量中的一个——如果有M个类别，在模型中使用M-1，可以忽略掉的值作为参考值。 y = bo + b1x1 + b2x2 + b3D1 注释–建立模型(stepwise Regression)有多种方法来选择适当的变量，例如： 前向选择(前进法Forward Selection) 逆向消除(后退法Backward Elimination) 双向比较(bi-directional comparision) Backward Elimination: 首先包含了所有的feature，然后每个feature都尝试去删除，测试删除的哪个feature对模型准确性有最大的提升，最终删掉对模型提升最高的一个特征。如此类推，直到删除feature并不能提升模型为止。 开始今天的学习预处理数据运用第一天的处理步骤 Import the libraries Import the DataSet Check for Missing Data Encode Categorical Data Make Dummy Variables if necessary and avoid dummy variable trap Feature Scaling will be taken care by the Library 3 代码如下： 1234567891011121314151617181920import pandas as pdimport numpy as npimport matplotlib.pyplot as pltdataset = pd.read_csv('50_Starups.csv')X = dataset.iloc[ : , :-1].valuesY = dataset.iloc[ : , 4].values# Encoding Categorical datafrom sklearn.preprocessing import LabelEncoder, OneHotencoderlabelencoder = LabelEncoder()X[ : , 3] = labelencoder.fit_transform(X[ : , 3])onehotencoder = Onehotencoder(categorical_features= [3])X =onehotencoder.fit_transform(X).toarray()# Avoiding Dummy Variable TrapX = X[ : , 1: ] #从1 开始，并非0# Splitting the dataset into the Training set and Test setfrom sklearn.cross_validation import train_test_splitX_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size = 0.2, random_state = 0) 将模型拟合到训练集 (Fitting our model to the trainning set)这个步骤和简单线性回归完全相同。 我们将使用 sklearn.linear_model库中的LinearRegression类来拟合训练集，然后创建一个LinearRegression的regressor对象，再对对象使用fit()方法来处理。 1234# Fitting Multiple Linear Regression to the Training setfrom sklearn.linear_model import LinearRegressionregressor = LinearRegression()regressor.fit(X_train, Y_train) 预测测试集的结果在这个步骤中，我们将预测从测试集观察到的结果。使用Y_pred来储存输出，最后使用predict()方法，来预测我们在上一步骤中训练的结果 1234567# Predicting the test set resultsY_pred = regressor.predict(X_test)plt.scatter(np.arange(10),y_test, color = 'red',label='y_test')plt.scatter(np.arange(10),y_pred, color = 'blue',label='y_pred')plt.legend(loc=2)plt.show() 第3天的学习结束啦，明天也要坚持哟😄 Day_4 逻辑效果(logistic regression)概述逻辑回归在某些书中也被称为对数几率回归,逻辑回归适合于处理分类问题，目的在于预测当前对象属于哪个分类组，它给出了一个0到1之间的离散二进制结果。 一个非常典型的例子就是一个人到底会不会为即将到来的选举投票 疑问它是如何工作的？？？ 逻辑回归通过依赖于它的基本逻辑函数估计概率，来测量因变量（我们想要预测的标签）和一个或多个独立变量（我们的特征）之间的关系。 Sigmoid Function (S型曲线函数)SigMoid函数是一个S形曲线，它可以取任何实数，并将其映射到0到1之间的值，但绝对不受这些限制。 图片来自维基百科 进行预测概率必须转化为二进制值(binary)，以便实际进行预测。这是Logistic函数的任务，也称为乙状函数(Sigmoid function)。0和1之间的值将使用阈值分类器(threshold classifier)转换成0和1。 逻辑 vs 线性逻辑回归给你一个离散(discrete [dɪˈskri:t] )的结果，但线性回归给出了一个连续(continuous)的结果。]]></content>
      <categories>
        <category>Machine_Learning</category>
      </categories>
      <tags>
        <tag>Machine_Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_Regex]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegex%2F</url>
    <content type="text"><![CDATA[正则表达式 Regex 1.正则表达式定义：正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符和这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑 2.需要取出来的就(.*?) 3.(. ) 贪婪模式———将标签内所有复合内容提取（.？） 非常模式——只提取有用部分 字符 作用 . 匹配所有英文字符 a[bcd]e 匹配字符集 匹配 a()e ()内bcd任意一个都可匹配 \d 匹配数字 “\D”：匹配除数字外 \s 匹配空格，换行符等 “\S”:匹配非空格，换行符 \w 匹配数字和字母 “\W”: 匹配非数字和字母 ^abc 匹配开头 abc$ 匹配结尾 （”abc”,”abcABC”,re.I) 不区分大小写的匹配 （”abc”,”abc\nABC”,re.S) 避免换行符等干扰提取内容 ab? 在a后面匹配一个或0个b ab+ 在a后面匹配至少一个b ab* 在a后面匹配至少0个b 当既要不分大小写，又要去除换行等影响，则(或运算)| re.S)```123456789101112---[TOC]### 匹配模式```Python #匹配模式有：1)re.I(re.IGNORECASE): 忽略大小写2)re.M(MULTILINE): 多行模式，改变’^’和’$’的行为3)re.S(DOTALL): 点任意匹配模式，改变’.’的行为,可匹配换行符4)re.L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定5)re.U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性6)re.X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释 123s= "&lt;div&gt;hello\nworld&lt;/div&gt;"#去除\n的影响m = re.findall(r"&lt;div&gt;(.*)&lt;/div&gt;",s,re.S) re –方法1、findall &amp; find12345678import re# re.findall(pattern, string)# pattern 表示我们希望寻找的子字符串# string 表示我们要在其中查找的主字符串content = re.findall(r'代码内容 .*?代码内容'，url.text，re.S)#若在代码内容中有特殊字符，需要被转义，例如r'&lt;script\(\)&gt;;&lt;/script&gt;'#使用re.S的作用为在代码中有许多回车与换行，若不加，则可能匹配不到内容 注意：至少两个参数，一个为正则表达式，另一个为源代码123456content = requests.get(url).content.decode('gb2312')#转义双引号start = content.find('&lt;map name=\"map_86\" id=\"map_86\"')end = content.find('&lt;/map&gt;')content = content[start:end + len('&lt;/map&gt;')].strip()print (content) 2、re.search()re.search(): 匹配的是一个模式在一个字符串中的第一个实例，然后以 re 匹配对象的形式返回它。 因为 re.search() 返回的是一个 re 匹配对象，所以我们不能直接通过 print 展示其中的内容。我们必须首先为其应用group() 函数。 group()： 函数的作用是将匹配对象转换成字符串。re.search().group() group(0)则是整个匹配的内容，返回一个实体对象group(1)则是匹配第一个括号里面的内容，取出括号里匹配的实体对象group(2)则是匹配第二个括号里面的内容，取出括号里匹配的实体对象group(0,1,2)则返回一个实体对象的元组 3、re.split()分割字符12345678import re#不保留匹配项m = re.split('\d+' , '123abc321cba')print mprint "\n"#保留匹配项,加（）m = re.split('(\d+)' , '123abc321cba')print m 4、re.sub()re.sub(): 是另一个很好用的 re 函数。顾名思义，它的功能是替换一个字符串的一部分。 有三个参数第一个是所要替换的子字符串，第二个是用来替换前者的字符串，第三个是主字符串本身12345sender = re.search("From:.*", fh)address = sender.group()email = re.sub("From", "Email", address)print(address)print(email) 改进123456789#小操作#1.以列表形式储存数据output = []#2.去除空格output.append(content[0].replace("\n",""))#3.设置爬虫休眠时间,防止爬取速度过快而被封import timetime.sleep(1) 1234567891011121314151617#如果是多次调用某个正则，则最好先编译后使用p = re.compile("^abc")m1 = re.findall("abc\nabc")m2 = re.findall("abced\nsdf")m3 = re.findall("dfsfd\nabcdf")#函数re.compile将正则表达式（以字符串书写的）转换为模式对象，可以实现更加有效的匹配。例子：import retext = "JGood is a handsome boy, he is cool, clever, and so on..."re.findall(r'\w*oo\w*', text) #查找所有包含'oo'的单词#使用compile函数：#导入re模块：import retext = “JGood is a handsome boy, he is cool, clever, and so on…”regex = re.compile(r‘’\w*oo\w*’)print regex.findall(text) #查找所有包含’oo’的单词 内容清洗(去空白字符等)123456789import reimport requestsimport html#将编译后的内容去除转义符，即清洗内容url = "www..."response = requests.get(url)pattern = re.compile("div...",re.S)body = html.unescape(response.text).replace("&lt;br/&gt;","\n")m = pattern.findall(body) 详细概念*匹配 0 个或更多个其左侧的模式的实例。也就是说它会查找重复的模式。当我们查找重复模式时，我们说我们的搜索是贪婪匹配。如果我们没有查找重复模式，我们可以说我们的搜索是非贪婪匹配或懒惰匹配。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Web_Django]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython_Web%2FDjango%2F</url>
    <content type="text"><![CDATA[Python_Web 知识内容创建项目，并了解项目目录结构选好安置目录项目位置后，打开cmd，输入 `Django-admin` 输入 `Django-admin Startproject myblog` Dir查看目录，有无myblog项目 目录层级说明manage.py 一个命令行工具，可以让我们用多种方式对Django项目进行交互init.py 一个空文件，它告诉Python这个目录应该被看做一个包settings.py 项目的配置文件（主要处理文件）urls.py 项目的url声明 （主要处理文件）wsgi.py 项目与WSGI兼容的Web服务器入口 配置数据库Django默认使用SQLite数据库在settings.py文件中通过DATABASES选项进行数据库配置 配置MySQLPython3.x中安装的是PyMySQL在__init__.py文件中写入两行代码12import pymysqlpymysql.install_as_MySQLdb() myAPP目录说明 admin.py 进行站点配置 models.py 创建模型 views.py 创建视图 创建应用 在一个项目中可以创建多个应用，每个应用进行一种业务处理 打开CMD,进入project(目录激活应用 在settings.py文件中，将myApp应用加入到INSTALLED_APPS选项中)123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myApp',] 定义模型 概述：有一个数据表就对应有一个模型 在models.py文件中定义模型 引入：from django.db import models模型类要继承models.Model类12345678910class Grades(models.Model): gname = models.CharField(max_length=20) # 字符串类型 gdate = models.DateTimeField() # 时间类型 ggirlnum = models.IntegerField() # 整型类型 gboynum = models.IntegerField() isDelete = models.BooleanField(default=False) # 布尔值类型# 在布尔值类型中可以添加默认属性default=False# 关联外键 models.ForeignKey("Grades")#说明：需要定义主键，在生成时自动添加，并且值为自动增加 在数据库中生成数据表 生成迁移文件执行 python manage.py makemigrations 在migrations目录下生成一个迁移文件，此时数据库中还没有生成数据表 执行迁移执行 python manage.py migrate相当于执行MySQL语句创建了数据表 测试数据操作 进入到python shell 执行 python manage.py shell 引入包123from myApp.models import Grades, Studentsfrom django.utils import timezonefrom datetime import * 查询所有数据 类名.objects.all() 示例： Grades.objects.all() 添加数据 本质：创建一个模型类的对象实例 示例：CMD窗口下123456grade1 = Grades()grade1.gname = "python04"grade1.gdate = datetime(year=2017, month=7, day=17)grade1.ggirlnum = 3grade1.gboynum = 70grade1.save() 查看某个对象 类名.objects(pk=索引号) 示例： 12Grades.objects.get(pk=2) # 查找单个对象,pk=2 --查找第二个Grades.objects.all() 修改某个数据 模型对象属性 = 新值 示例： 12grade2.gboynum = 60grade2.save() # 保存修改至数据库 删除数据 模型对象.delete() grade2.delete()注意：这是物理删除，数据库中的相应数据被永久删除 关联对象 示例： 1234567stu = Students()stu.sname = "Xue Yanmei"stu.sgender = Falsestu.sage = 20stu.scontend = "I am Xue Yanmei"stu.sgrade = grade1stu.save() 获得关联对象的集合 需求：猎取python04班级的所有学生 对象名.关联的类名小写_set.all() 示例：grade1.students_set.all() 需求:创建曾志伟，属于python04班级 示例： 123stu3 = grade1.students_set.create(sname=u'Zhen Zhiwei',sgender=True,scontend=u"I am Zhen Zhiwei",sage=45) 注意：这样创建的数据直接被添加到了数据库当中。 传递参数request.GET[&#39;a&#39;] Get看做是在request下的一个数组，而‘a’是一个键，则request.GET[&#39;a&#39;]对于的就是通过Get方式发送的a的值 常用命令 命令 启动命令 python manage.py runserver 端口号 常见问题处理 CSRF问题处理 当用post提交数据的时候，django会去检查是否有一个csrf的随机字符串，如果没有就会报错 当用户访问login页面的时候，会生成一个csrf的随机字符串，，并且cookie中也存放了这个随机字符串，当用户再次提交数据的时候会带着这个随机字符串提交，如果没有这个随机字符串则无法提交成功 from django.views.decorators.csrf import csrf_exempt123@csrf_exemptdef firstPageAdd(request) return render(request,"firstclass_01.html",locals())]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_Selenium]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2Fselenium%2F</url>
    <content type="text"><![CDATA[##自动化测试 12345678910import selenium.webdriverdriver = selenium.webdriver.'浏览器种类'()url = " "driver.get(url)#向url内发送内容driver.find_element_by_class_name(" ").send_keys(" ")#模拟点击的动作driver.find_element_by_id(" ").click()driver.quit() ####1、声明浏览器对象，访问页面并获取网页html（源代码） 123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')# browser.page_source是获取网页的全部html,即获取网页源代码print(browser.page_source)browser.close() 2、查找元素12345678910111213# 单个元素from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')# 三种方式返回的是相同的值input_first = browser.find_element_by_id('q')input_second = browser.find_element_by_css_selector('#q')input_third = browser.find_element_by_xpath('//*[@id="q"]')print(input_first,input_second,input_third)# 多个元素，elements多个sinput_first = browser.find_elements_by_id('q')browser.close() 123456789# 可以使用通用的方法from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')# 第一个参数传入名称，第二个传入具体的参数input_first = browser.find_element(By.ID,'q')print(input_first)browser 3、元素交互操作-搜索框传入关键词进行自动搜索12345678910111213141516171819from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.taobao.com')# 找到搜索框input = browser.find_element_by_id('q')# 传送入关键词input.send_keys('iPhone')time.sleep(5)# 清空搜索框，文本框input.clear()# 传送入关键词input.send_keys('男士内裤')# 找到搜索按钮button = browser.find_element_by_class_name('btn-search')# 点击按钮button.click()# double_click(on_element=None)# 双击Double-clicks an element. 4.截图img.screenshot_as_png 5.动作链123# 前进后退browser.back()browser.forward() 12345678910111213# 调用动作链from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()# 将source元素拖放至target元素处，参数为两个elementObjsource = browser.find_element_by_css_selector('#draggable')target = browser.find_element_by_css_selector('#droppable')# 将动作链实例化action = ActionChains(browser)# drag_and_drop(鼠标拖动)action.drag_and_drop(source,target)# 执行动作链action.perform() 1234567891011121314151617181920# 更多用法# move_to_element 鼠标移动到某一个元素上,结束elementObjActionChains(driver).move_to_element(e)# 鼠标移动到制定的坐标上，参数接受x，yActionChains(driver).move_by_offset(e['x'],e['y'])#Keys 实际是Selenium提供的一个键盘事件模块，在模拟键盘事件时需要导入Keys模块from selenium.webdriver.common.keys import Keys# key_down 模拟键盘摁下某个按键 key_up 松开某个按键，# 与sendkey连用完成一些操作，每次down必须up一次否则将出现异常# 全选&amp;复制# key_down(value, element=None)# element：要发送密钥的元素。如果没有，则将密钥发送给当前有焦点的元素。ActionChains(driver).key_down(Keys.CONTROL,dom).send_keys('a')\.send_keys('c').key_up(Keys.CONTROL)# 黏贴ActionChains(driver).key_down(Keys.CONTROL,dom1).send_keys('v')\.key_up(Keys.CONTROL).perform() 6、获取元素信息切换标签browser.switch_to.frame(&#39;iframe&#39;): switch_to.标签名(‘属性’) 获取属性123456789101112131415from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)logo = browser.find_element_by_id('zh-top-link-logo')#获取网站logoprint(logo)# 获取属性print(logo.get_attribute('class'))# 获取网页的cookiesprint(browser.get_cookies)# 删除所有的cookiesbrowser.delete_all_cookiesbrowser.close() 获取页面源码12345# selenium的page_source方法可以直接返回页面源码from selenium import webdriverdriver = webdriver.Firefox()driver.get("http://www.cnblogs.com/yoyoketang/")page = driver.page_source 获取文本值12345678from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')# 获取文本值print(input.text)browser.close() 获取Id，位置，标签名，大小12345678910from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input.id)#获取idprint(input.location)#获取位置print(input.tag_name)#获取标签名print(input.size)#获取大小browser.close() 7、等待12345678910# 隐式等待from selenium import webdriverbrowser = webdriver.Chrome()# 设置等待时间,browser.implicitly_wait(5)# 当查找元素并没有立即出现时，隐式等待将等待一段时间在查找DOM,默认时间为0url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input) 123456789101112131415# 显式等待 Explicit Waits¶from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Firefox()driver.get("http://somedomain/url_that_delays_loading")try: element = WebDriverWait(driver, 10).until( # 可以修改By.的选择，“ ”内的对象也可以改变 EC.presence_of_element_located((By.ID, "myDynamicElement")) )finally: driver.quit()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[注释：加粗+斜体删除线 为无序排列,也可以使用- 为强调 为高亮文字 使用代码块 ** **粗体文字12345678 &gt;引用 多层嵌套&gt;&gt;#### 插入图片 `![](./01.png '描述')` ![name][01] [01]: ./01.png '描述'#### 插入图片带有链接`[![](./01.png '百度')](http://www.baidu.com)` ```代码框 内容标题 定义型列表注：解释型定义Markdown: 轻量级文本标记语言，可以转换成html，pdf等格式 // 开头一个: + Tab 或 四个空格 脚注Markdown[^1][^1]: Markdown是一种纯文本标记语言（标记内容） 任务列表 选项一 选项二 [选项 表格 a b c 居中 左对齐 右对齐 ========= ============= ============ 自动邮箱链接&#120;&#120;&#120;&#x40;&#x6f;&#x75;&#116;&#x6c;&#111;&#x6f;&#107;&#x2e;&#99;&#111;&#x6d; 流程图流程1234567891011121314st=&gt;start: 开始|past:&gt; http://www.baidu.com // 开始e=&gt;end: 结束 // 结束c1=&gt;condition: 条件1:&gt;http://www.baidu.com[_parent] // 判断条件c2=&gt;condition: 条件2 // 判断条件c3=&gt;condition: 条件3 // 判断条件io=&gt;inputoutput: 输出 // 输出//----------------以上为定义参数-------------------------//----------------以下为连接参数-------------------------// 开始-&gt;判断条件1为no-&gt;判断条件2为no-&gt;判断条件3为no-&gt;输出-&gt;结束st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;ec1(no)-&gt;e // 条件1不满足-&gt;结束c2(no)-&gt;e // 条件2不满足-&gt;结束c3(no)-&gt;e // 条件3不满足-&gt;结束 演示 代码详解*流程图分为两个部分：定义参数 然后 连接参数 定义示例：123tag=&gt;type: content:&gt;url // 形参格式st=&gt;start: 开始:&gt;http://www.baidu.com[blank] //实参格式注：** st=&gt;start: 开始 的：后面保持空格** 形参 实参 含义 tag st 标签 (可以自定义) =&gt; =&gt; 赋值 type start 类型 (6种类型) content 开始 描述内容 (可以自定义) :&gt;url http://www.baidu.com[blank] 链接与跳转方式 兼容性很差 123:---: 居中:--- 左对齐---: 右对齐 6种类型 含义 start 启动end 结束operation 程序subroutine 子程序condition 条件inputoutput 输出 连接示例：12st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;e开始-&gt;判断条件1为no-&gt;判断条件2为no-&gt;判断条件3为no-&gt;输出-&gt;结束 形参 实参 含义 -&gt; -&gt; 连接 condition c1 条件(布尔值,方向) (yes,right) 如果满足向右连接，4种方向：right ，left，up ，down 默认为：down 注：operation (程序); subroutine (子程序) ;condition (条件)，都可以在括号里加入连接方向。 123operation(right)subroutine(left)condition(yes,right) // 只有条件 才能加布尔值]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Web_Pyquery]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython_Web%2FPyQuery%2F</url>
    <content type="text"><![CDATA[PyQueryclass – .id – # 初始化1、字符串的初始化123456789101112131415from pyquery import PyQuery as pqhtml = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = pq(html)print(doc)print(type(doc))# 提取li标签内所有内容print(doc('li')) 2、URL初始化123from pyquery import PyQuery as pqdoc = pq(url=" ")print(doc("li")) 3、通过文件初始化123from pyquery import PyQuery as pqdoc = pq(filename='demo.html')print(doc('li')) CSS选择器1234567891011121314from pyquery import PyQuery as pqhtml = '''&lt;div&gt; &lt;ul id = 'haha'&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = pq(html)print(doc)# id等于haha下面的class等于item-0下的a标签下的span标签#（注意层级关系以空格隔开）print(doc('#haha .item-0 a span')) 查找子标签123456789101112131415161718from pyquery import PyQuery as pqhtml = '''&lt;div&gt; &lt;ul id = 'haha'&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;''' doc = pq(html) items = doc('.list') # 寻找同时含有Item-0和active属性的list内的标签 # 其中item-0与active并列 itema = doc('.list .item-0.active') print(type(items)) list = items.find('li') print(list) # 查找含有active子元素的标签 lis = items.children('.active') 兄弟元素 1234li = doc('.list .item-0.active')print(li.siblings())# 可再次筛选print(li.siblings('.active'))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2FCrawler_02%2F</url>
    <content type="text"><![CDATA[[TOC] 1.爬取网页 response属性读取数据 1.读取文件的全部内容，会把读取到的数据赋值给一个列表 data = response.readlines()2.读取文件的全部内容，会把读取到的数据赋值给一个字符串 data = response.read() 读取文件的一行data = response.readline()4.encode 将我们看得懂得东西变为看不懂得东西_ decode 将我们看不懂得东西变为看得懂得东西返回当前环境的有关信息data = response.info() 返回状态码data = response.getcode()if response.getcode() ==200 or response.getcode() ==304 返回正在爬取的URL地址data = response.geturl() 编码(解码)，将url中的汉字编码转化为汉字 url=&quot;http://***&quot; newurl = urllib.request.(un)quote(url) 有时候内容编码是Unicode的格式，则需要对其进行编码再解码 content.encode(&#39;latin-1&#39;).decode(&#39;unicode_escape&#39;) 改进 decode(“utf-8”,”ignore”) 2.将网页存取到指定文件中import urllib.requesturllib.request.urlretrieve(&quot;url&quot;,filename=r&quot;存取的文件地址&quot;) 注意:urlretrieve在执行的过程中会产生一些缓存，清除缓存如下操作urllib.request.urlcleanup() 3.模拟浏览器利用User-Agent，添加headers,使得模拟更加真实1234567891011import urllib.requesturl = " "headers = &#123;"User-Agent":" "&#125;#设置一个请求体,构建请求对象req = urllib.request.Request(url,headers=headers)#发起请求response = urllib.request.urlopen(req)data = response.read().decode("utf-8")print (data) 1234567891011#保持模拟浏览器登陆状态--cookies#post请求一般应用在登陆#为保证持续模拟登陆，则需要处理好cookiesreq_attr = urllib.request.Request(url=url,data=encode_data,headers=headers)response_attr = urllib.request.urlopen(req_attr)#read().decode("gbk")#print (response)#获取登陆后获取的响应头，处理相应的cookies以保持登陆状态print(response_attr.headers)#比较两个cookies的不同，将浏览器响应头修改为服务器登陆响应头 123456789101112# 为防止被封IP可以将多个Agent做成列表，多次变换agentlist = ["","",""]agentstr = random.choice(agentlist)req =urllib.request.Request(url)#向请求体里添加了User-Agentreq.add_header("User-Agent",agentstr)response =urllib.request.urlopen(req)print (response.read().decode("utf-8")) - 请求url的错误处理，防止无法请求url而影响程序12345678import requests.exceptions import RequestExceptiondef page_state(rep): try: if rep.status_code == 200: # 如果状态码正常，则返回url的内容 return rep.text return None except: return None 4.设置超时&amp;间隙时间12345678910#在使用urllib或者urllib2时，有可能会等半天资源都下载不下来，#可以通过设置socket的超时时间，来控制下载内容时的等待时间。#如下python代码import sockettimeout = 20socket.setdefaulttimeout(timeout)#这样默认20秒之后就会超时。 123456789101112import urllib.requestimport timetime.sleep(10)#如果网页长时间未反应，系统判断超时for i in range(1,100): #循环次数 try: response = urllib.request.urlopen( "http://www.baidu.com",timeout = 0.5) print (len(response.read().decode("utf-8"))) except: print ("请求超时，继续下一个爬取") 5.HTTP请求1234567891011121314151617181920212223'''使用场景：进行客户端与服务器之间的消息传递时使用Get :通过URL网址传递信息，可以直接在URL地址上传递信息Post :可以向浏览器提交数据，时一种比较流行的比较安全的数据传递。 如密码等,但速度慢Put ：请求服务器存储一个资源，通常要指定存储的位置Delete ：请求服务器删除一个资源Head ：请求获取对应的HTTP报头信息Options :可以获取当前URL所支持的请求类型''' #对于一些既有post请求,又有get请求的网页 #get请求的参数在url地址中 #post请求的参数需要我们单独传递数据，对数据进行编码import urllib.parse #创建请求体的参数内容headers = &#123;&#125;post_data = &#123;&#125; #利用urllib.parse对post_data进行处理 #data参数如果要传必须传bytes（字节流）类型的 #如果是一个字典，先用urllib.parse.urlencode()编码。encode_data = urllib.parse.urlencode(post_data).encode("utf-8")req = urllib.request.Request(url=url,data=encode_data,headers=headers) Https请求123#抓取HTTPS协议import sslssl._create_default_https_context = ssl._create_unverified_context 6.抓取网页动态Ajax请求的数据12345678import ssl #抓取https协议的网页req = urllib.request.Request(url,headers=headers) #使用ssl创建未验证的上下文context = ssl._create_unverified_context()response = urllib.request.urlopen(req.context=context)jsonstr = response.read().decode("utf-8")jsondata = json.loads(jsonstr) 12# 动态数据，在 js文件中有真正的请求url# 爬取静态与动态网页通法 1.建立需求 源代码中没有我们需要的数据原因： 1.Ajax异步加载 ：通过多个请求获取数据（通过XHR筛选出Ajax加载的数据） 2.数据加密 7.保存文件，数据持久化123456789import requestsurl = " "headers = &#123; "User-Agent":" "&#125;response = requests.get(url,headers=headers)with open("demo.zip","wb") as f: #以二进制形式打开文件 f = write(url.content) 1234import os# 导入os模块，为爬取的文件新建文件夹，可进行分类保存os.mkdir("文件夹名称")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_xpath]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2Fxpath%26lxml%2F</url>
    <content type="text"><![CDATA[xpath 和 lxml xpath 一门从html中提取数据的语言 xpath语法 xpath helper插件：帮助我们从elements中定位数据 / ：表示从根节点开始 选择节点(标签) // ：表示从任意节点开始 @ ：定位具体元素的位置 例如：//div[@class=&#39;feed-infinite-wrapper&#39;]/ur/li,表示为选择@class=’feed-infinite-wrapper’的div下的ur下的li。 另外，a/@href:选择a的href的值 获取文本 a/text()：获取a下的文本 a//text():获取a下的所有文本 5.当前 ./a表示当前节点下的a lxml 安装 pip install lxml 使用123456from lxml import etree#接收HTML字符串response = requests.get(url).content.decode("utf-8")element = etree.HTML("html字符串")#xpath提取数据element.xpath("") 以下代码中，a, b, c是什么参数？ 1.&gt;&gt;&gt; “{a} love {b}.{c}”.format(a=”I”, b=”FishC”, c=”com”) 2.’I love FishC.com’关键字参数 3. 以下代码中，{0}, {1}, {2}是什么参数？ 1.&gt;&gt;&gt; “{0} love {1}.{2}”.format(“I”, “FishC”, “com”) 2.’I love FishC.com’ 位置参数 4. 如果想要显示Pi = 3.14，format前边的字符串应该怎么填写呢？ ‘{0}{1:.2f}’.format(‘Pi = ‘, 3.1415) 写爬虫的结论 1.url 知道url地址的规律和总页码数：构造url地址的列表 start_url (url地址有规律) 2.发送请求，获取响应 requests 3.提取数据 返回json字符串：json模块 返回html字符串：lxml模块配合xpath模块 4.保存]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_encode]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%2F</url>
    <content type="text"><![CDATA[编码格式a=u&#39;string&#39; :u 代表 unicodea.encode(&#39;utf-8&#39;) : utf-8格式a.decode(&#39;utf-8&#39;) : 从utf-8转至Unicode格式 from sys import argvscript,filename = argv 获取文件信息 ####文件方法f.readline(): f文件会记录每次调用readline()后的读取位置，可以在下次被调用时读取下一行 fileObject.seek(offset[, whence]): offset: 开始的偏移量，也就是代表需要移动偏移的字节数whence：可选，默认值为 0。给offset参数一个定义，表示要从哪个位置开始偏移；0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。 1234fo.seek(0, 0)line = fo.readline()print "读取的数据为: %s" % (line)f.seek(4,1) #1为从当前位置，移动4个字节 文件处理r :只读 f.close(),f.read(),f.readline() w :只写 文件内有内容，则写入内容会覆盖*，若无内容，则会新写入内容-f.write() F.writelines() a :追加 f.write() 写入内容后，f.close()才会保存修改 若要强制修改。则使用 f.flush()rb :读写wb :写读ab :追加及读 方法 | 作用:—: |:—:f.seek(0) | 回到文件开头f.tell(0) |告知当前所在位置f.truncate() |清空文件 123456#只读模式f = file('myfile.txt','r')for line in f.readlines(): # 去除换行符， 将 ： 前后分割 line =line.strip('\n').split(':') print (line) 1234#图片，音频，zip的复制with open("test_01.png","rb") as f1: with open("test_02.png","wb") as f2: f2.write(f1.read()) 123456#例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; i = Image.open(BytesIO(r.content)) 123456fh = open(r"test_emails.txt", "r").read()# 注意我们直接在目录路径之前使用了 r# 这项技术会将一个字符串转换成一个原始字符串# 这有助于避免由某些机器阅读字符的方式所导致的冲突# 比如 Windows 中目录路径中的反斜杠]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Chart]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%BB%98%E5%9B%BE%2Fpyecharts%2F</url>
    <content type="text"><![CDATA[1、渲染图表123456from pyecharts import Barbar = Bar("我的第一个图表", "这里是副标题")bar.add("服装", ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", ], [5, 20, 36, 10, 75])# bar.print_echarts_options() # 该行只为了打印配置项，方便调试时使用bar.render() # 生成本地 HTML 文件 解释 add()主要方法，用于添加图表的数据和设置各种配置项 print_echarts_options()打印输出图表的所有配置项 render()默认将会在根目录下生成一个 render.html 的文件，支持 path 参数，设置文件保存位置，如 render(r&quot;e:\my_first_chart.html&quot;)，文件用浏览器打开。Note 可以按右边的下载按钮将图片下载到本地，如果想要提供更多实用工具按钮，请在 add() 中设置 is_more_utils 为 True 2、使用主题 安装主题插件$ pip install echarts-themes-pypkg 设置主题bar.use_theme(&#39;dark&#39;) Noteecharts 自带 dark 主题， pyecharts 也就自带了 dark。 echarts-themes-pypkg 提供了 vintage, macarons, infographic, shine 和 roma 主题。 3、多次显示图表12345678910111213141516from pyecharts import Bar, Linefrom pyecharts.engine import create_default_environmentbar = Bar("我的第一个图表", "这里是副标题")bar.add("服装", ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", ], [5, 20, 36, 10, 75])line = Line("我的第一个图表", "这里是副标题")line.add("服装", ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋"], [5, 20, 36, 10, 75])env = create_default_environment("html")# 为渲染创建一个默认配置环境# create_default_environment(filet_ype)# file_type: 'html', 'svg', 'png', 'jpeg', 'gif' or 'pdf'env.render_chart_to_file(bar, path='bar.html')env.render_chart_to_file(line, path='line.html')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_Draw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMongodb%2F</url>
    <content type="text"><![CDATA[基本概念 数据库（database） 集合（collection） 文档（document） 数据库和集合在MongoDB中不需要手动创建 当创建文档时，如果文档所在集合或数据库不存在会自动创建数据库和集合 Mongodb的windows服务安装和卸载安装: mongod --dbpath &quot;C:\mongodb\db&quot; --logpath &quot;C:\mongodb\log.txt&quot; --install --serviceName &quot;MongoDB&quot; 卸载: mongod.exe --remove --serviceName &quot;MongoDB&quot; 1、了解MongodbMongoDB数据库中存的是各种各样的JSON(BSON) 2、更换MongoDB的database文件夹mongod --dbpath 文件夹地址 3、运行MongoDB#####命令行下运行 MongoDB 服务器为了从命令提示符下运行 MongoDB 服务器，你必须从 MongoDB 目录的 bin 目录中执行 mongod.exe 文件。C:\mongodb\bin\mongod --dbpath c:\data\db 4、重新设置端口C:\mongodb\bin\mongod 数据库路径 --port 123456 注意: 端口数最大不能超过65535 5、连接MongoDB我们可以在命令窗口中运行 mongo.exe 命令即可连接上 MongoDB，执行如下命令：C:\mongodb\bin\mongo.exe 6、启动MongoDB要启动 MongoDB，请运行 mongod.exe 。 例如，从命令提示符：D:\Program Files\MongoDB\Server\3.4\bin\mongod.exe 注意：如果不使用 –dbpath 指定数据存储的目录， 那么 MongoDB 默认使用的是 C:\data\db目录，所以在启动 MongoDB 数据库之前要确保 C:\data\db 目录已经创建了。 在mongodb\bin下打开命令行模式:（启动服务器）D:\mongodb\bin&gt;mongod 验证Mongdb启动成功在Chrome浏览器下，打开localhost:27017若出现It looks like you are trying to access MongoDB over HTTP on the native driver port. 则登录成功 打开mongo命令行下输入mongo,进入mongo的客户端命令模式 命令 show dbs命令可以显示所有数据库的列表。 show collections 显示数据库中的所有集合 db 命令可以显示当前数据库对象或集合。 use 数据库名命令，可以进入到一个指定的数据库。 可以创建任意数据库 MongoDB 的 CRUD（增删改查）操作增添 db.集合名.insert(doc): 在集合中插入一个文档doc,为**json格式** { ：，： } 若要插入多个doc,则用列表形式 向集合插入文档时，若没有给文档指定_id属性，则数据库会自动为文档添加_id 该属性为文档的唯一标识 可以自己指定_id ,”_id”=” “ 使用循环，插入多条数据1234567891011// 方法1for(var i=1 ; i &lt;200 ; i++)&#123; db.user.insert(&#123;num:i&#125;) //需要调用200次insert方法，效率低&#125;//方法2var arr = [];for(var i=1 ; i&lt;200 ; i++)&#123; arr.push(&#123;num:i&#125;); //将num从1到200添加到数组arr中&#125;db.num.insert(arr) //只需调用一次 insert方法 查找 db.集合名.find(): 查询当前集合中的所有文档 `db.collection.find()` `find()`返回的是数组，若要查询其中某个属性，则要添加索引`[0]` find()用来查询集合中所有符合条件的文档，返回一个数组，可以加索引 增加查询条件 {}：{属性:值} 查询指定属性的文档 MongoDB支持直接通过内嵌文档的属性查询，若要查询内嵌文档，则可以通过.的形式来匹配此时属性名必须使用引号 db.user.find({&quot;hobby.movies&quot;:&quot;hero&quot;}) 更多方法 用处 拓展 findone() 查询符合条件的第一个文档对象 find().count() 统计所有文档的数量 find({num:{$gt:200}}) 查找数字大于200的数据 $gte: &gt;= $lt:&lt; $lte:&lt;= $ne:!= find().limit(10) ==limit()== 可以设置显示数据的上限，即显示10条 find().skip(10).limit(10) ==skip()== 用于跳过指定的数据，该命令可以查询第11-20条数据 其中skip(),limit()顺序可以倒换 finf({$or:[{a:1},{b:2}]}) 查询a属性为1或b属性为2的集合 1234// 查找用户订单，使用用户ID作为索引// 向商品属性中添加用户ID做索引var user_id = db.users.findone(&#123;username:&quot;&quot;&#125;)._id;db.order.find(&#123;user_id:user_id&#125;); 修改 db.collection.update(查询条件，新对象) : 修改文档内容 方法：`updateMany`,`updateOne` 12// 利用update实现updateMany 和 updateOne 的功能db.user.update( &#123;name:&quot;jedieal&quot;&#125;,&#123;$set:&#123; age=28 &#125;&#125;,&#123;multi:true&#125;); 注意：update()默认情况下会使用新对象来替换旧的对象 如果需要修改指定的属性，而不是替换，则需要使用“修改操作符”来完成 $set：可以用来修改，增添文档属性 $unset：可以用来删除文档属性 例子1：db.user.update({name:&quot;jedieal&quot;},{age:28}); ： ==age==会将==name==内容给替换 例子2：db.user.update({name:&quot;jedieal&quot;},{$set:{ age=28 }}); 利用$set，只对age进行修改，还可以用来添加值 删除属性，还是属于修改 修改集合属性的数组内的数据 1 db.user.update({ },{$push :{&quot;hobby.movies&quot;:&quot;hero&quot;}}) 2 db.user.update({ },{$addToSet :{&quot;hobby.movies&quot;:&quot;hero&quot;}}) : 若要加入的元素与数组内有相同的，则不会添加 更多方法 作用 {$inc:{a:2}} 在a的值的基础上加上2 要减少，可以将2变为-2 删除 db.collection.remove() db.collection.deleteOne();,db.collection.deleteMany(; ==remove()== : 可以根据条件来删除文档，传递的条件的方式和==find()== 一样 删除一个 db.collection.remove({ },true); 删除所有文档，清空集合(性能略差) db.collection.remove({}) 清空集合（优化） db.collection.drop() 删除数据库 db.dropDatabase() 一般数据库中的数据都不会删除，所以删除的方法很少用 一般会在数据中添加一个字段，来表示数据是否被删除 db.collection.update({ }，{$setZ:{isDel:0}}) db.collection.find({isDel:0}): 利用==isDel==作为标准，0代表没删除，1 代表删除 NOSQL (Not Only SQL)数据库 数据库的服务器 用于保存数据 mongod 用于启动服务器 数据库的客户端 用于操作数据，对数据进行增删改除 mongo 用于启动客户端]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_cookbook]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%90%86%E8%AE%BA%2Fcookbook%2F</url>
    <content type="text"><![CDATA[解决方案 12345678from collections import deque#deque(maxlen=N)创建一个固定长度的队列#当有新记录加入而队列已满时会自动移除最老的那条记录q = deque(maxlen=3)q.appendleft()q.popleft()#创建无限序列q = deque() 123456789101112131415#寻找集合中最大或最小的N个元素# nlargest(),nsmallest()import heapqnums=[1,8,2,23,7,-4,18,23,42,37,2]print(heapq.nlargest(3,nums)) #print [42,37,23]#将集合转换为堆,堆的特性为heap[0]总是最小的那个元素nums=[1,8,2,23,7,-4,18,23,42,37,2]import heapqheap = list(nums)heapq.heapify(heap)#去除heap中最小值heap.heappop(heap)#插入元素heap.heappush()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_terms]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%90%86%E8%AE%BA%2Fdefinition-py%2F</url>
    <content type="text"><![CDATA[1.多态：可以对不同类的对象使用相同的操作 2.headers=headers :反爬措施，防止浏览器以为是机器在工作 3.对象的状态由它的特性（比如名称）来描述 4.所有的对象都属于某一个类，称为类的实例 5.self参数用于对象自身的引用，实例化对象将自己作为第一个参 数传入函数中，例如 若 foo为Person的实例，则foo.greet()可以看作Person.greet(foo)的简写]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_terms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython_Advanced%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B_1%2F</url>
    <content type="text"><![CDATA[函数式编程 原则写代码要遵循==开发封闭==原则，虽然这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即： 封闭：已实现的功能代码块 开放：对扩展开发 内容装饰器12345678910def w1(func): def inner(): # 验证1 # 验证2 # 验证3 return func() return inner@w1 # 相当于执行了 w1(f1())def f1(): print('f1') 当写完这段代码后（函数未被执行、未被执行、未被执行），python解释器就会从上到下解释代码，步骤如下：12def w1(func): ==&gt;将w1函数加载到内存@w1 没错，从表面上看解释器仅仅会解释这两句代码，因为函数在没有被调用之前其内部代码不会被执行。 从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章 @函数名 : 是python的一种语法糖。 如上例 @w1内部会执行以下操作: 执行w1函数，并将 @w1 下面的 函数 作为 w1 函数的参数即：@w1 等价于 w1(f1)。 所以，内部就会去执行：1234567891011121314151617def inner: #验证 return f1() # func是参数，此时 func 等于 f1return inner # 返回的 inner，inner代表的是函数，非执行函数# 其实就是将原来的 f1 函数塞进另外一个函数中。# 将执行完的 w1 函数返回值赋值给@w1下面的函数的函数名# w1函数的返回值是： def inner: #验证 return 原来f1() # 此处的 f1 表示原来的f1函数# 然后，将此返回值再重新赋值给 f1，即：new_f1 = def inner: #验证 return 原来f1() 如此一来， 即执行了验证的功能，又执行了原来 f 函数的内容，并将原 f1 函数返回值, 返回给业务调用着。 参数传递12345678910111213141516171819202122232425 # 一个参数：def w1(func): def inner(arg): # 验证1 # 验证2 # 验证3 return func(arg) return inner@w1def f1(arg): print('f1')# 两个参数：def w1(func): def inner(arg1,arg2): # 验证1 # 验证2 # 验证3 return func(arg1,arg2) return inner@w1def f1(arg1,arg2): print('f1') 问题: 装饰具有处理n个参数的函数的装饰器？12345678910def w1(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return inner@w1def f1(arg1,arg2,arg3): print('f1') 问题：一个函数可以被多个装饰器装饰吗？123456789101112131415161718def w1(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return innerdef w2(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return inner@w1@w2def f1(arg1,arg2,arg3): print('f1') Lambda函数（匿名函数） 函数 ： 最大程度地复用代码 存在问题：若函数很小，很短，则会造成啰嗦，不方便阅读代码 lambda表达式 一个表达式，函数体相对简单 用法 以lambda开头 紧跟一定的参数 参数后面用冒号和表达式主题分开 只是一个表达式，没有return 实例 stm = lambda x: 100 * x stm(89) ==&gt;8900 高阶函数 定义 ： 把函数作为参数使用的函数 注意 函数名称就是一个变量，即函数可以作为参数 举例`pythondef funA(n):return n * 100 def funB(n): return funA(n) * 3]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Compute]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E8%AE%A1%E7%AE%97%2Fpandas%26numpy%2F</url>
    <content type="text"><![CDATA[帮助函数 S.method? Pandas1.什么是Series简单来说：一维带标签（索引）的数组 2.Series的特征 数组中的数据可以是任意的类型，包括整数、浮点数、字符串、列表、字典等python对象 数组中的数据应为同一类型 创建Series一般格式s = pd.Series(data,index = index) 通过列表list创建Series 1234import pandas as pdimport numpy as nps = pd.Series([10,30,20,40])si 通过字典dictionary创建Series 123dict_1 = &#123;"a":10,"c":5,"b":40&#125;s1 = pd.Series(dict_1)s1 字典和Series的区别： 字典是无序的，Series是有序的，通过无序的字典来创建Series后，Series会将字典的键作为自己的索引，并且按升序方式排列 通过数组array创建Series123array_1 = np.arange(10,16)s2 = pd.Series(array_1,index=list("abcdef")) # 设置indexs2 Series的属性 获得索引index12s2.indexIndex(['a', 'b', 'c', 'd', 'e', 'f'], dtype='object') 索引为迭代器 通过赋值整体地修改索引值12s2.index = ["aa","bb","cc","dd","eee","fff"]s2 要点：新设置的索引个数必须与原来索引个数一致值得一提的是：提取单个索引值来修改是不允许的，如果要修改索引值，就得全部重新设置 修改index的名称 12s2.index.name = "banana"s2 修改Series的名称 1s2.name = "length" 获取Series的值values 1s2.values 通过以上我们发现，Series对象本身及其索引都有name属性 Series的索引 index 位置索引 12#得到第一行的数s2[0] 得到最后一行的数 1s2[-1] 得到特定一些行的数(如第1行，第4行，第6行） 1s2[[0,3,5]] *名称索引12#得到索引为aa所对应的数s2["aa"] Series的切片slice 索引位置切片1s2[1:4] 没有包含末端 索引名称切片1s2["aa":"eee"] 包含末端 修改Series的值1234s2[index] = value （index表示需要修改的值所对应的索引）s2[i] = value （i表示需要修改的值所对应的索引位置）s2["aa"] = 100s2[2] = 120 添加Series的值 返回一个新的Series，不修改原来的Series1s2.append(pd.Series([value1,value2,...],index = [index1,index2,...])) 12#添加Series的值,并返回一个新的Seriess2.append(pd.Series([50,60],index=["a1","a2"])) 直接在原来的基础上修改Series1s2["new index"] = value 通过append来添加Series的值，特点是： 返回一个新的Series 批量修改 通过s2[&quot;new index&quot;] = value这种方式来添加的值，特点是: 直接在原来的Series基础上增加值 每次只能增加一个值 删除Series的值del s2[index]12#删除y索引对应的99这个值del s2["y"] 过滤Series的值 通过布尔选择器（条件筛选）来过滤掉一些值，从而得到满足条件的值123456789s2[s2 &lt; value]s2[s2 &gt; value]s2[s2 == value]s2[s2 != value]#单条件筛选s2[s2 &gt; 90]#多条件筛选s2[(s2 &gt; 50) | (s2 &lt; 14)] Series的缺失值处理 创建一个带有缺失值的Series12# np.nans = pd.Series([10,np.nan,15,19,None]) 提示：None值会被当做NA处理* 判断是否有缺失值isnull（） 判断s中的缺失值s.isnull() 如果需要取出这些缺失值，则通过布尔选择器来筛选出来s[s.isnull()] 删除缺失值 123456#dropna()会删除掉所有缺失值NaN，并返回一个新的Series#原有的Series并未发生改变s.dropna()#如果希望原有的Series发生改变，#可以将s.dropna（）返回的新Series直接赋值给原来的Seriess = s.dropna() 此外，我们也可以通过过滤的方式来达到一样的删除效果： 123456789data[~data.isnull()]data[data.notnull()]s = pd.Series([10,np.nan,15,19,None]) #初始化一下s #依然是返回一个新的Series，波浪号~表示否定、非的意思s[~s.isnull()]#也可以使用 s.notnull#通过notnull（）也能实现，同样也是返回一个新的Seriess[s.notnull()] 填充缺失值fillna（） :用指定值或插值的方式填充缺失值 12345678910111213141516171819用指定值填充缺失值#用0填充缺失值,返回的依然是一个新的Seriess.fillna(value=0)#如果希望直接修改原Series#一种方法是之前说的直接赋值，另一种是添加参数inplace=Trues.fillna(value=0,inplace=True)#用插值填充缺失值#初始化一下ss = pd.Series([10,np.nan,15,19,None])#向前填充（ffill，全称是front fill）s.fillna(method="ffill")#向后填充（bfill，全称是back fill）s.fillna(method="bfill")` 排序123456789101112131415161718192021222324#创建一个Seriess3 = pd.Series([10,15,8,4,20],index=list("gadkb"))s3g 10a 15d 8k 4b 20dtype: int64#（1）根据索引排序#sort_index() 默认升序，如果添加参数ascending=False,则降序排列#(2)根据索引升序排列# 根据值排序 sort_valuess3.sort_index()a 15b 20d 8g 10k 4dtype: int64#根据索引降序排列s3.sort_index(ascending=False) 排名1234567891011121314151617181920# rank（）# 创建一个用来排名的Seriess4 = pd.Series([2,5,15,7,1,2])s40 21 52 153 74 15 2# 中国式排名s4.rank(ascending=False,method="dense")0 4.01 3.02 1.03 2.0 4 5.0 5 4.0 Series的描述性统计 值的计数 Series.value_counts（） 123456789101112131415161718192021222324252627282930313233343536373839#创建一个Seriess5 = pd.Series([100,50,100,75,24,100])s5#值的计数 Series.value_counts（）s5.value_counts()100 375 150 124 1#最小值 s5.min（）s5.min()24#最大值 s5.max（）s5.max()100#中位数 s5.median（）s5.median()#均值 s5.mean（）s5.mean()74.83333333333333#求和 s5.sum（）s5.sum()449#标准差 s5.std()s5.std()31.940048006643114#描述性统计 s5.describe（）s5.describe().round(1) # round表示小数点后多少位count 6.0mean 74.8std 31.9min 24.025% 56.250% 87.575% 100.0max 100.0 Series的向量化运算 可对Series进行批量操作，并且返回一个新的Series并不会在原基础上直接修改123s5 + 1000s5 * 2s5 / 10 自动对齐相同索引的数据,不同索引的数据对不上，则显示NaN123456789s6 = pd.Series([35000,40000,71000,5500],index=list("abcd"))s7 = pd.Series([222,35000,4000,2222],index=list(aqtb))s6 + s7a 35222.0b 42222.0c NaNd NaNq NaNt NaN]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_Compute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_Tools]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2FSpider_00%2F</url>
    <content type="text"><![CDATA[爬虫的分类 1.通用爬虫 2.聚焦网络爬虫 3.增量式网络爬虫 4.深层网络爬虫 了解url(统一资源定位符) 1.url的结构：协议-域名（ip)-端口号-目录-文件名-参数-锚（位置） #Charles抓包工具S]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_requests]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2Frequests%2F</url>
    <content type="text"><![CDATA[requests 爬取网页的通用代码框架12345678def getHTMLText(url):try:r=requests.get(url,timeout30)r.raise_for_status #如果状态不是200，引发HTTPError异常r.encoding = r.apparent_encoding # 将编码格式转换为响应内容的编码格式return r.textecxept:return #产生异常 1234567891011import requestsfrom requests.exceptions import RequestExceptiondef page_state(rep): url = " " try: rep = requests.get(url) if rep.status_code == 200: # 如果状态码正常，则返回url的内容 return rep.text return None except: return None 解释 requests是python实现的简单易用的HTTP库，使用起来比urllib简洁很多requests.get()用于请求目标网站，类型是一个HTTPresponse类型 基本操作123456789import requestsresponse = requests.get('http://www.baidu.com')print(response.status_code) # 打印状态码print(response.url) # 打印请求urlprint(response.headers) # 打印头信息print(response.cookies) # 打印cookie信息print(response.text) #以文本形式打印网页源码print(response.content) #以字节流形式打印 GET请求相关内容传入参数 第一种直接将参数放在url内 1234import requests#url/get?参数&amp;参数response = requests.get(http://httpbin.org/get?name=gemey&amp;age=22)print(response.text) 第二种先将参数填写在dict中，发起请求时params参数指定为dict 123456789import requestsdata = &#123; 'name': 'Jedieal', 'age': 18&#125;response = requests.get('http://httpbin.org/get', params=data)print(response.text) 案例 百度搜索123import requestskv = &#123;'wd':'python'&#125;r = requests.get("http://www.baidu.com/s",params=kv) 请求添加头信息123456import requestsheads = &#123;&#125;heads['User-Agent'] = 'Mozilla/5.0 ' \ '(Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 ' \ '(KHTML, like Gecko) Version/5.1 Safari/534.50' response = requests.get('http://www.baidu.com',headers=headers) #####访问响应头字段1234567r.headers['Content-Type]'application/json'r.headers.get('content-type')'application/json' 使用代理同添加headers方法，代理参数也要是一个dict: 这里使用requests库爬取了IP代理网站的IP与端口和类型 因为是免费的，使用的代理地址很快就失效了。12345678910111213141516171819202122232425262728293031323334353637import requestsimport redef get_html(url): proxy = &#123; 'http': '120.25.253.234:812', 'https': '163.125.222.244:8123' &#125; heads = &#123;&#125; heads['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0' req = requests.get(url, headers=heads,proxies=proxy) html = req.text return html#利用正则匹配IPdef get_ipport(html): regex = r'&lt;td data-title="IP"&gt;(.+)&lt;/td&gt;' iplist = re.findall(regex, html) regex2 = '&lt;td data-title="PORT"&gt;(.+)&lt;/td&gt;' portlist = re.findall(regex2, html) regex3 = r'&lt;td data-title="类型"&gt;(.+)&lt;/td&gt;' typelist = re.findall(regex3, html) sumray = [] for i in iplist: for p in portlist: for t in typelist: pass pass a = t+','+i + ':' + p sumray.append(a) print('高匿代理') print(sumray)if __name__ == '__main__': url = 'http://www.kuaidaili.com/free/' get_ipport(get_html(url)) 获取cookie12345678import requestsresponse = requests.get('http://www.baidu.com')print(response.cookies)print(type(response.cookies))#字典形式，利用items()遍历for k,v in response.cookies.items(): print(k+':'+v) 解析json1234567import requestsresponse = requests.get('http://httpbin.org/get')print(response.text)#response.json()方法同json.loads(response.text)print(response.json())print(type(response.json())) 保存一个二进制文件 二进制内容为response.content123456import requestsresponse = requests.get('http://img.ivsky.com/img/tupian/pre/201708/30/kekeersitao-002.jpg')b = response.contentwith open('F://fengjing.jpg','wb') as f: f.write(b) 超时异常捕获12345678import requestsfrom requests.exceptions import ReadTimeouttry: res = requests.get('http://httpbin.org', timeout=0.1) print(res.status_code)except ReadTimeout: print('timeout') 异常处理使用try…except来捕获异常 Exceptions:123456789101112import requestsfrom requests.exceptions import ReadTimeout,HTTPError,RequestExceptiontry: response = requests.get('http://www.baidu.com',timeout=0.5) print(response.status_code)except ReadTimeout: print('timeout')except HTTPError: print('httperror')except RequestException: print('reqerror') POST 请求 通常，你想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典在发出请求时会自动编码为表单形式：1234payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.post("http://httpbin.org/post", data=payload)print(r.text) 可以为 data 参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式尤其有效：123456789payload = (('key1', 'value1'), ('key1', 'value2'))r = requests.post('http://httpbin.org/post', data=payload)print(r.text)&gt;&gt;&gt;"form": &#123; "key1": [ "value1", "value2" ] &#125; 很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个dict，那么数据会被直接发布出去。可以使用 json 参数直接传递，然后它就会被自动编码。这是 2.4.2 版的新加功能：123url = 'https://api.github.com/some/endpoint'payload = &#123;'some': 'data'&#125;r = requests.post(url, json=payload)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F25%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[代码命令 代码 作用 input type=”text” name=”username” value=”” 输入账号 input type=”text”name=”password” value=”” 输入密码 input type=”submit” 提交查询按钮 input type=”reset” 重置]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F25%2FREADME%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F25%2FGit%2FGithub%2F</url>
    <content type="text"><![CDATA[搜索仓库文件快捷键：T]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hacker_Techo]]></title>
    <url>%2F2018%2F07%2F21%2FHacker%2FHacker-Techo%2F</url>
    <content type="text"><![CDATA[专业术语 脚本 (asp、 php、 jsp) html (css、 js、 html) HTTP协议 CMS (B/S) MD5 肉鸡 ： 被黑客入侵并长期驻扎的计算机或服务器 抓鸡 ： 利用使用量大的程序的漏洞，使用自动化方式获取肉鸡的行为 Webshell : 通过 Web 入侵的一种脚本工具，可以据此对网站服务进行一定程度的控制 漏洞 ： 硬件、软件、协议等可利用安全缺陷，对数据进行篡改、控制等 提权 ： 操作系统低权限的账户将自己提升为管理员权限使用的方法 后门： 黑客为对主机进行长期的控制，在机器上种植的一段程序或留下的一个”入口” 跳板 ： 使用肉鸡IP来实施攻击其他目标，以便更好的隐藏自己的身份信息 旁站 ： 对于一个大的服务器，可以供多个网站使用 旁站入侵 ： 同服务器下的网站入侵，可以通过提权跨目录等手段拿到目标网站的权限。 常见旁站查询工具： WebRoot、御剑、明小子、Web在线查询等。 C段入侵 ： 同C段下服务器入侵。如目标Ip为192.168.1.253入侵192.168.1.*的任意一台机器，然后借助一些黑客工具嗅探获取网络上传输的各种信息。 常见工具： Cain (windows) 、 Sniffit、Snoop、Tcpdump、Dsniff(Unix) 渗透测试 黑盒测试 ： 在未授权的情况下，模拟黑客的攻击方法和思维方式，来评估计算机网络系统可能存在的安全风险 黑盒测试不同于黑客攻击，并不等于黑站。黑盒测试考验的是综合的能力 (OS,Database,Script,code,思路,社工) 思路和经验积累往往决定成败 黑白盒 ： 知道源代码和不知道源代码的渗透测试 黑盒测试为传统的渗透测试，而白盒测试偏向于代码审计 渗透测试与入侵的区别 渗透测试：更全面的找出服务器的问题，倾向于保护 入侵：不择手段的拿到权限 黑客攻击 DDoS 攻击 ： 分布式拒绝服务攻击 (distributed denial-of-service attack) 缺陷： 无法贡献系统 DNS污染 ： DNS (Domain Name System 域名系统) Poisoning 小结 木马： 通过向服务端提交一句简短的代码，配合本地客户端，实现webshell功能的木马 12&lt;%eval request("pass")%&gt;&lt;%execute(request("pass"))%&gt; 解释 request(“pass”) ： 接收客户端提交的数据， pass 为执行命令的参数值 eval/execute : 函数执行客户端命令的内容 黑客之路 一隐写术步骤 准备一个文件 ,如 test.txt (test.txt是需要被隐藏的文件) 将其压缩为zip , 或 rar,直接重命名 打开命令终端，将压缩文件定向到需要被隐写的文件 (可选操作)将被隐写的文件的拓展名修改为 .zip 作用 将test.txt文件定向隐藏至hide.png文件下，即点击图片，其实打开的是test.txt 代码 cat test.txt.zip &gt;&gt; hide.png 使用 Python3 编写破解 zip 压缩包密码用料： 准备需要破解的 zip 文件，找一个密码字典 【可自行制作】 运行脚本 读取一个Python zipfile 模块 这里假设filename是一个文件的路径: 1234import zipfile z = zipfile.ZipFile(filename, 'r') for i in z.infolist(): print i.file_size, i.header_offset 这里使用了z.infolist(), 它返回的就是压缩包内所有文件的信息，就是一个ZipInfo的列表。一个ZipInfo对象中包含了压缩包内一个文件的信息，其中比较常用的是 filename, file_size, header_offset, 分别为文件名，文件大小，文件数据在压缩包中的偏移 已知密码进行解压代码12345import zipfile #导入模块，它是做压缩和解压缩的password="123" #我们设定的口令zfile = zipfile.ZipFile("test.zip") #要解压缩的压缩包zfile.extractall(path='C:\\Users\\Administrator\\Desktop\\', members=zfile.namelist(), pwd=password.encode('utf-8'))#进行解压缩操作，path为输出的路径 运行一下上面的代码(当然你的加密口令要为123)，会发现在桌面上已经把test.zip解压出来了 破解开始直接上代码12345678910import zipfile zfile = zipfile.ZipFile("test.zip")passFile=open('pwd.txt') #读取你设定的密码文件for line in passFile.readlines(): try: password = line.strip('\n') zfile.extractall(path='C:\\Users\\Administrator\\Desktop\\', members=zfile.namelist(), pwd=password.encode('utf-8')) break except: print("密码错误") 利用了try except异常机制，当解压正常的时候就正常密码正常，解压失败会报出异常]]></content>
  </entry>
  <entry>
    <title><![CDATA[Big_Data]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2FBig-Data%2F</url>
    <content type="text"><![CDATA[大数据 搭配LINUX环境 创建 /usr/local/hadoop 文件夹 下载hadoop，并解压 安装 JDK 环境 生成无密公钥 ssh-keygen -t dsa -P &#39;&#39; -f ~/.ssh/id_dsa 将公钥id_dsa.pub 添加进keys ,保证无密码登录cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys 验证是否成功 ： ssh localhost (第一次登录有询问) 解释 dsa 为生成的密钥类型 -P 为密码 ‘’ 表示无密码 -f 后面为生成要保存的位置 Java1234567891011121314151617181920212223package com.itstar.util;/** * 大数据文件批量检索(豆瓣电影影评)数据抓取核心工具类 * @author * @version v1.0 */public class DataDownUtil &#123; // java 入口 public static void main(Sring[] args)&#123; System.out.println("java爬虫"); &#125;&#125;// 1. 根据网址和页面的编码集获取网页的源代码// 2. 解析源代码，批量采集我们需要的影评数据// 3. 将文字信息转换成文本文件，储存在服务器中// 4. 同步到分布式文件系统中// 5. 计算、处理、可视化public static String getHtmlResource(String url, String encoding)&#123; // 建立网络链接 URL urlObj = new URL(url);&#125; 数据概念大数据是由结构化和非结构化数据组成的 10%的结构化数据，储存在数据库中 90%的非结构化数据，它们与人类信息密切相关 HDFS的底层原理：代理对象与RPCHive什么是Hive？Hadoop : 大数据的第一个框架 框架 作用 HDFS 存储 MapReduce 计算 YARN 调度 解释 ： Hive 是基于 Hadoop 的一个数据仓库工具，可以将结构化(行对行、列对列)的数据文件映射为一张表，并提供一种类SQL(HQL)的功能 优缺点 优点 提供了SQL的查询，提供快速开发的能力 避免了去写 MR(MapReduce)，减少开发人员成本 底层实现是 MR 适合处理大数据量，对于小数据量没有优势，延迟高 缺点 数据挖掘领域不擅长 效率相对较低，MR 不够智能 调优比较困难 Hive 的架构原理Hive 原理架构 Meta store ==&gt; derby | mysql Driver : 解析器 、 编译器 、 优化器 、 执行器 MapReduce HDFS Hive 与数据库比较 查询语言 HQL 与 SQL 、 自定义函数 (UDF、UDAF、UDFF) 数据的储存位置 Hive 存在HDFS 中 数据库： 本地文件系统中、块设备 数据更新 Hive 内容 读多写少 数据库： 增删改查 执行 和 执行延迟 扩展性 Hive 比 Mysql 强 Hive 的数据类型 基本数据类型 Hive 的数据类型 Java 数据类型 Tinyint byte SMALINT short INT int BIGINT long BOOLEAN boolean FLOAT float DOUBLE double STRING string TIMESTAMP 时间类型 BINARY 字节数组 集合数据类型 STRUCT 、 MAP 、 ARRAY 类型转换 和 Java 的类型转换一致，如果是 低 -&gt; 高 自动转 DDL数据定义与DML数据操作小范例 MAP : kv 结构 STRUCT : 不单单只是类型，而且还有类型名 建表语句： Json 格式 1234567891011create table test( name string, friends array&lt;string&gt;, children map&lt;string, int&gt;, address struct&lt;street:string, city:string&gt;)row format delimited fields terminated by "," -- 列分隔符collection items terminated by "_" -- MAP STRUCT 和 ARRAY 的分隔符map keys terminated by ":" -- MAP 中的 key 和 value 的分隔符lines terminated by "n"; --行分隔符 数据操作1. 创建数据库： create database if not exists db_hive; // 默认路径： /user/hive/warehouse create database if no exists jedieal location &apos;/jedieal.db&apos;; // 使用 location 指定路径 2. 修改数据库： alter database jedieal set dbproperties(‘create’=’20180724’); // 加上创建时间，即自定义的元数据(记录了数据的相关信息) desc database extended jedieal; 3. 查询数据库： show database; show database like ‘db_hive*’; 4. 删除数据库： drop database db_hive; 5. 创建数据表： 普通创建表123456create table if not exists student (id int, name string)row format delimited fields terminated by '\t'stored as textfilelocation '/user/hive/warehouse/student' 根据查询结果创建表 (查询的结果会添加搭配新建的表中) `create table if not exists student as select id, name from student;` 根据已经存在的表结构创建表 create table if not exists emp like emp1; Table Type MANAGED_TABLE 内部表 EXTERNAL_TABLE 外部表 外部表与内部表的区别： 删内 ： 会把表结构和表里的数据都删除 删外 ： 只会删除表结构、不会删除表数据 drop table 表名; 6. 分区数据表：12345create external table dept_partition_external (deptno int, dname string, loc string)partitioned by (month string)row format delimited fields terminated by '\t'; 分区及分文件夹 分桶及文件 修改数据表： 删除数据表： 企业级优化Fetch 抓/hive.fetch.task 三个： more minimal none123set hive.fetch.task.conversion=none;set hive.fetch.task.conversion=more; 本地模式12345678#开启本地 MRset hive.exec.mode.local.auto=false;#设置文件大小的最大值set hive.exec.mode.local.auto.inputbytes.max=50000000;#文件个数set hive.exec.mode.local.auto.input.files.max=10; 查询分桶表：select * from emp cluster by deptno; 严格模式1234select * from emp;set hive.mapred.mode = nonstrict (默认)select * from ori_partitioned_target where p_time = '20111230000010'; MapReduce日志的固定格式： 访问时间 用户ID 查询词 该URL在返回结果中的排名 用户点击的顺序号 用户点击的URL 需求: 分析搜索结果中，排名第一，点击率第二的日志信息 一、 使用MapReduce 原理： 根据Google发表的一篇论文提出： MapReduce计算模型 MapReduce的问题来源： PageRank问题 （网页排名） 实战： 依赖的jar包 二、 使用 Spark 原理： 三、 使用 Hive 原理： 四、 大数据项目标准、架构 HadoopHadoop 简介Hadoop 简介 Hadoop 是 Apacha 软件基金会旗下的一个开源分布式计算平台，为用户提供了系统底层细节透明的分布式基础架构 Hadoop是基于 Java 语言开发的，具有跨平台的特性，也可以部署在廉价计算机集群中 Hadoop的核心是分布式文件系统HDFS(Hadoop Distributed File System) 和 MapReduce Hadoop是行业大数据标准开源软件 Hadoop 发展 Hadoop由Apache Lucene 项目创始人 Doug Cutting 开发的文本搜索库，源自 Apache Nutch 项目 2004， Nutch 模仿 GFS 开发了HDFS的前身 NDFS (Nutch Distributed File System) 2004, 谷歌公司发表一篇阐述 MapReduce 分布式编程思想的论文 2005， Nutch 开源实现谷歌的 MapReduce 2006, NDFS、MapReduce 独立成为 Hadoop 2008, Hadoop 正式成为 Apache 顶级项目 Hadoop 特性 高可靠性 高效性 高可扩展性 高容错性 成本低 运行在 Linux 平台上 支持多种编程语言 国内采用 Hadoop 的公司： 百度、淘宝、网易、华为、中国移动 其中淘宝的Hadoop集群较大 Hadoop 应用 Hadoop 版本第二代 Hadoop 包含两个版本 ： 0.23.x 和 2.x 这两个版本完全不同于Hadoop1.0，是一套全新的架构，包含 HDFS Federation 和 YARN 两个系统。相对0.23.X , 2.X 增加了 NameNode HA 和 Wire-compatibility 两个特性 Hadoop 生态系统Hadoop 组图 生态系统组件解释 Hadoop 安装与使用一、 Linux 推荐选择Ubuntu操作系统，建议使用64位系统版本的Linux。若电脑的配置较好，推荐使用虚拟机安装 二、 Hadoop安装方式 单机模式： Hadoop默认模式为非分布式模式(本地模式)，无需进行其他配置即可运行。 非分布式即单 JAVA 进程，方便进行调试 伪分布式模式： Hadoop 可以在单节点上以伪分布式的方式运行 Hadoop进程以分离的 java 进程来运行，节点即作为 NameNode 也作为 DataNode, 同时读取的是 HDFS 中的文件 分布式模式： 使用多个节点构成集群环境来运行Hadoop 注意：Hadoop不会覆盖结果文件 HBase介绍HBase访问接口一、 BigTable BigTable是一个分布式存储系统。起初用于解决典型的互联网搜索问题 特点 (1) 使用谷歌的MR分布式并行计算模型来处理海量数据(2) 使用谷歌分布式文件系统GFS作底层数据存储(3) 使用Chubby提供协同服务管理(4) 具有广泛的应用性、可扩展性、高性能和高可用性等(5) 谷歌的许多项目存储在BT中，如搜素、地图，另外还有YouTube等 建立互联网索引 (1) 爬虫抓取新页面，将页面每页一行的方式存储至 BigTable(2) MR计算作业运行在整张表上，生成索引，为网络搜素提供准备 搜索互联网 (1) 用户发起搜索请求(2) 网络搜索应用查询建立好的索引，从BigTable得到网页(3) 搜索结果返回给用户 HBase介绍 HBase是一个高可靠、高性能、面向列、可伸缩的分布式数据库，是谷歌BT的开源实现。 用途： 存储非结构化和半结构化的松散数据 处理非常庞大的表，通过水平扩展的方式，由廉价计算机集群处理庞大的数据表 对比BT与HBase HBase关系数据库(1) 数据类型： HBase数据库采用相对传统关系数据库更为见到那的数据模型，把数据存储为未经解释的字符串 (2) 数据操作： 只包含简单的插入、查询、删除、清空等，避免了复杂表和表之间的关系 (3) 存储模式： 关系数据库基于行模式存储的，而HBase是基于列存储的，不同的列族文件是分离的，每个列族由几个文件保存 (4) 数据索引： 关系数据库通常针对不同列构建复杂的多个索引，而HBase只有一个索引/行键，以至所有的访问方法，或通过行键访问，或通过行键扫描，从而系统不会停滞 (5) 数据维护： 关系数据库更新操作会将新值覆盖旧值，而HBase更新操作不会删除旧数据版本、而是生成一个新的版本，旧版本仍然保留 (6) 可伸缩性： 关系数据库难以实现横向扩展，而纵向扩展空间有限，而HBase和BT分布式数据库可以灵活的水平扩展，通过在集群中增加或减少硬件数量来实现性能伸缩 SQL操作select * from db where ; : 从 db 中查看所有数据, where 为条件查询]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%89%8D%E7%AB%AF%2FCSS%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSS入门学习 CSS 基础CSS 语法CSS定义方式 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 selector {declaration1; declaration2; ... declarationN } CSS 值的写法例 123456789p &#123; color: #ff0000; &#125;p &#123; color: #f00; &#125;p &#123; color: rgb(255,0,0); &#125;p &#123; color: rgb(100%,0%,0%); &#125;p &#123;font-family: "sans serif";&#125; 多重声明 1234567body &#123; color: #000; background: #fff; margin: 0; padding: 0; font-family: Georgia, Palatino, Serif; &#125; 注意 是否包含空格不会影响 CSS 在浏览器的工作效果， 同样，与 XHTML 不同，CSS 对大小写不敏感。不过存在一个例外：如果涉及到与 HTML 文档一起工作的话，class 和 id 名称对大小写是敏感的 CSS 高级语法 根据 CSS，子元素从父元素继承属性.通过 CSS 继承，子元素将继承最高级元素（在本例中是 body）所拥有的属性（这些子元素诸如 p, td, ul, ol, ul, li, dl, dt,和 dd）。对于部分旧式浏览器,它不仅忽略继承，而且也忽略应用于 body 元素的规则。 解决 1234567body &#123; font-family: Verdana, sans-serif; &#125;p, td, ul, ol, li, dl, dt, dd &#123; font-family: Verdana, sans-serif; &#125; 如果不想使某些子类继承父类的属性，可以针对该子类单独设置其属性 1234567body &#123; font-family: Verdana, sans-serif; &#125;p &#123; font-family: Times, "Times New Roman", serif; &#125; CSS派生选择器 派生选择器可以使得根据文档的上下文关系来确定某个标签的样式。通过合理地使用派生选择器，可以使 HTML 代码变得更加整洁。 如将列表中的 strong 元素变为斜体字，可以定义一个派生选择器 123li strong &#123; font-style: italic;&#125; 更多例子 123456h2 strong &#123; color: blue; &#125;strong &#123; color: red;&#125; CSS id 选择器 id选择器可以为标有特定id的HTML元素指定特定的样式 使用 “#”定义 注意 id 属性只能在每个 HTML 文档中出现一次。 一个选择器，多种用法&gt; 即使被标注为 sidebar 的元素只能在文档中出现一次，这个 id 选择器作为派生选择器也可以被使用很多次：12345678#sidebar p&#123; font-style: italic; text-align: center;&#125;#sidebar h&#123; font-size: lem; margin: 0;&#125; 单独的选择器&gt;id 选择器即使不被用来创建派生选择器，它也可以独立发挥作用1234#sidebar &#123; border: 1px dotted #000; padding: 10px; &#125;### CSS 类选择器示例：123.center &#123; text-align: center;&#125;&gt; HTML 中类可以使用多次h1 和 p 元素都有 center 类。这意味着两者都将遵守 “.center” 选择器中的规则。1234567&lt;h1 class="center"&gt;This heading will be center-aligned&lt;/h1&gt;&lt;p class="center"&gt;This paragraph will also be center-aligned.&lt;/p&gt;注意：:类名的第一个字符不能使用数字！### CSS 属性选择器先来看几个例子1. 将所有含有title属性的元素设置颜色123456&lt;style type="text/css"&gt; [title]&#123; color: blue;&#125;&lt;/style&gt;2. 将含有 title 为 keithxodoy 的元素设置颜色123456&lt;style type="text/css" &gt;[title=keithxodoy]&#123; color: blue;&#125; &lt;/style&gt;3. 将含有 title 内容包含 hello 的元素设置颜色 适用于由空格分隔的属性值title=&quot;hello keithxodoy&quot;123456&lt;style type="text/css"&gt;[title~=hello]&#123; color: blue;&#125;&lt;/style&gt; 适用于由连字符分隔的属性值title=&quot;hello-keithxodoy123456&lt;style type="text/css" &gt;[title|=hello] &#123; color: blue;&#125;&lt;/style&gt;其余用法| 选择器 | 功能 ||——–|—–|| [attribute^=value] | 匹配属性值以指定值开头的每个元素|| [attribute$=value] | 匹配属性值以指定值结尾的每个元素|| [attribute=value] | 匹配属性值中包含指定值的每个元素|## CSS 创建样式表### 外部样式表&gt; 背景 ： 当页面所需的css样式过多，而且大多是重复相同的样式时，不易在HTML文件中单独呈现，于是使用 link标签，将外部的一个 css 文件引入至 HTML 中123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="style_set.css" /&gt;&lt;/head&gt;注意:最好不要再属性值和单位之间留有空格，否则会在一些浏览器中无法正常工作### 内部样式表&gt; 背景 ： 当某个文档需要特殊样式时，适合使用内部样式表1234567&lt;head&gt;&lt;style type="text/css"&gt; p &#123; margin-left: 20px; &#125;&lt;/style&gt;&lt;/head&gt;### 内联样式&lt;p style=&quot;color: sienna; margin-left: 20px&quot;&gt;### 背景### 背景色使用 background-color 设置背景色&gt; background-color 不能继承，默认值 transparent 透明### 背景图像使用background-image设置背景图像实例：body {background-image: url(/1.png);}&gt; background-image 不能继承,但是可以为段落、行内元素设置背景### 背景重复&gt;如果需要在页面上对背景图像进行平铺，可以使用 background-repeat 属性。属性值repeat1. repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复2. no-repeat 则不允许图像在任何方向上平铺。示例：12345body &#123; background-image: url('i.png'); background-repeat: repeat-x;&#125;### 背景定位&gt;可以利用 background-position 属性改变图像在背景中的位置。示例：123456p&#123; background-image: url('i.png'); background-repeat: repeat-x; background-position: center;&#125;|位置关键字||——–||center ||top||bottom||right ||left|&gt;同时 background-postion 也可以使用 长度值，百分数值 设置12345body&#123; background-position: 50% 50%; background-position: 50px 50px;&#125;### 背景关联&gt;如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。可以通过 background-attachment 属性防止这种滚动,使图像相对可视区为固定的实例：12345body&#123; background-image: url('i.png'); background-attachment: fixed;&#125;注意:background-attachment 属性的默认值是 scroll，即在默认的情况下，背景会随文档滚动### 总结&gt;可以将所有的 CSS背景属性写在一个申明中123456&lt;style type="text/css"&gt;body&#123; background: #ff0000 url(/i.png) repeat-x center fixed ; &#125;&lt;/style&gt;—## CSS 文本### 缩进文本 text-indent&gt; 通过使用 text-indent 属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值示例：将所有段落的首行缩进 5em:12345p &#123;text-indent: 5em;&#125;p &#123;text-indent: -5em;&#125;p &#123;text-indent: 20%;&#125;注意：1. 一般来说，可以为所有块级元素应用 text-indent，但无法将该属性应用于行内元素，图像之类的替换元素上也无法应用 text-indent 属性。2. 如果一个块级元素(比如段落)的首行中有一个图像，它会随该行的其余文本移动。3. 对于行内元素的第一行“缩进”，可以使用设置左内边距或外边距创造。4. text-indent 属性可以继承### 水平对齐 text-align&gt; text-align 是一个基本的属性，它会影响一个元素中的文本行互相之间的对齐方式。示例：中间对齐1p &#123;text-align: center;&#125;注意：text-align:center 与 &lt;CENTER&gt;区别是&lt;CENTER&gt; 不仅影响文本，还会把整个元素居中;而text-align 不会控制元素的对齐，而只影响内部内容。### 字间隔 word-spacing &amp; 字母间隔 letter-spacing#### 字间隔 word-spacing&gt; word-spacing 属性可以改变字（单词）之间的标准间隔。其默认值 normal 与设置值为 0 是一样的。word-spacing属性接受一个正长度值或负长度值。如果提供一个正长度值，那么字之间的间隔就会增加。为 word-spacing 设置一个负值，会把它拉近示例：设置文本之间距离为负值12p.spacing &#123; word-spacing: -0.5em;&#125;#### 字母间隔 letter-spacing&gt;letter-spacing 属性与 word-spacing的区别在于，字母间隔修改的是字符或字母之间的间隔。示例：设置字母间的间隔123456h1 &#123; letter-spacing: -0.5em;&#125;h2 &#123; letter-spacing: 20px;&#125;### 字符转换| 属性值| 作用||——-|—-|| none | 不对文本做任何改动|| uppercase | 文本转换为全大写|| lowercase | 文本转换为全小写|| capitalize| 每个单词的首字母大写|### 文本装饰| 属性值 | 作用 ||——-|——|| none | 不做处理，也可以使超链接的下划线去除 || underline | 加下划线|| overline | 在文本顶端画一个上划线| line-through | 在文本中间画一个贯穿线|| blink | 使得文本闪烁|注意:可以在一个规则中结合多种装饰,但如果两个不同的装饰都与同一元素匹配，胜出规则的值会完全取代另一个值### 处理空白符 white-space&gt; white-space 属性会影响到用户代理对源文档中的空格、换行和 tab 字符的处理,即各个字之间只会显示一个空格，同时忽略元素中的换行 normal属性示例： 显式设置默认行为，即去除多余空格与换行123p &#123; white-space: normal;&#125; pre属性示例： 浏览器保留额外的空格回车123p &#123; white-space: pre;&#125;注意：:IE 7 以及更早版本的浏览器不支持该值 nowrap属性示例：nowrap会防止元素中的文本换行，除非使用了一个 br 元素123p &#123; white-space: nowrap;&#125;## CSS 样式### CSS 字体#### 5 种通用字体系列： Serif 字体 Sans-serif 字体 Monospace 字体 Cursive 字体 Fantasy 字体 font-family 属性 ： 定义文本的字体系列1body &#123;font-family: sans-serif;&#125;&gt; 注意：只有当字体名中有一个或多个空格（比如 New York），或者如果字体名包括 # 或 $ 之类的符号，才需要在 font-family 声明中加引号#### 字体风格font-style 属性最常用于规定斜体文本。该属性有三个值： normal - 文本正常显示 italic - 文本斜体显示 oblique - 文本倾斜显示&gt; 注意： 斜体（italic）是一种简单的字体风格，对每个字母的结构有一些小改动，来反映变化的外观。与此不同，倾斜（oblique）文本则是正常竖直文本的一个倾斜版本#### 字体加粗font-weight 属性设置文本的粗细。使用 bold 关键字可以将文本设置为粗体。关键字 100 ~ 900 为字体指定了 9 级加粗度。如果一个字体内置了这些加粗级别，那么这些数字就直接映射到预定义的级别，100 对应最细的字体变形，900 对应最粗的字体变形。&gt; 数字 400 等价于 normal，而 700 等价于 bold#### 字体大小font-size 属性设置文本的大小。font-size 值可以是绝对或相对值。绝对值： 将文本设置为指定的大小 不允许用户在所有浏览器中改变文本大小（不利于可用性） 绝对大小在确定了输出的物理尺寸时很有用相对大小： 相对于周围的元素来设置大小 允许用户在浏览器改变文本大小注意：如果您没有规定字体大小，普通文本（比如段落）的默认大小是 16 像素 (16px=1em)12body &#123;font-size:100%;&#125;h1 &#123;font-size:3.75em;&#125;—### CSS 的链接#### 链接样式 a:link - 普通的、未被访问的链接 a:visited - 用户已访问的链接 a:hover - 鼠标指针位于链接的上方* a:active - 链接被点击的时刻，即正在被点击的链接实例：12345678&lt;head&gt; &lt;style&gt; a:link &#123;color:#FF0000;&#125; /* 未被访问的链接 */ a:visited &#123;color:#00FF00;&#125; /* 已被访问的链接 */ a:hover &#123;color:#FF00FF;&#125; /* 鼠标指针移动到链接上 */ a:active &#123;color:#0000FF;&#125; /* 正在被点击的链接 */ &lt;/style&gt;&lt;/head&gt;注意 a:hover 必须位于 a:link 和 a:visited 之后 a:active 必须位于 a:hover 之后 常见链接样式 text-decoration ： 多用于除去链接的下划线 实例：1a:link &#123;text-decoration: none;&#125; background-color : 设定链接的背景色 实例：1a:hover &#123;background-color: #FFFF85;&#125; font-size : 改变链接的字体大小 实例： 设置鼠标悬停在链接上的字体大小变化1a:hover &#123;font-size: 150%;&#125; font-family : 改变链接字体 实例：修改链接字体为微软雅黑1a:link &#123;font-family: '微软雅黑';&#125; font-weight : 设置字体的厚度 实例：1a:active &#123;font-weight: bold;&#125; 高级示例 本例来设置创建链接框 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;style&gt; a:link , a:visited &#123; color: white; background-color: black; display: block; text-align: center; text-decoration: none; font-weight: bold ; width: 120px; padding: 10px; &#125; a:hover , a:active &#123; color: orange; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://www.baidu.com"&gt;百度一下&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; CSS列表无序列表的样式 在一个无序列表中，列表项的标志 (marker) 是出现在各列表项旁边的圆点 修改： 间无序列表的圆点改为方形123ul &#123; list-style-type: square&#125; 更多样式 list-style-type: disc 空心圆 list-style-type: circle 实心圆 list-style-type: square 方形 list-style-type: none 无 任意列表的样式 将列表的标志改为图像 123ul li &#123; list-style-image: url(test.gif)&#125; 使用url来引入图像为标志 列表标志的位置 从CSS2.1 可以确定标志出现在列表项内容之外还是内容内部。 使用 list-style-position 完成 总结–简写列表样式 为简单起见，可以将以上 3 个列表样式属性合并为一个方便的属性：list-style 123li &#123; list-style: url(test.gif) square inside&#125; 设置CSS表格一、 CSS表格边框123table &#123; border: 1px solid;&#125; 同时也可以设置边框颜色 border: 1px solid green 二、 CSS单一边框(实线) 1234table &#123; border-collapse:collapse; &#125; 三、 CSS设置表格文本对齐方式 12345td &#123; height:30px; vertical-align:bottom; &#125; 四、 CSS设置表格内边距 如需控制表格中内容与边框的距离，请为 td 和 th 元素设置 padding 属性： 1234td &#123; padding:15px; &#125; 五、 CSS表格空单元设置 12345table&#123;border-collapse: separate;empty-cells: hide;&#125; 值 描述 hide 不在空单元格周围绘制边框。 show 在空单元格周围绘制边框。默认。 六、 CSS设置表格的页边距 12345table &#123; border-collapse:separate; border-spacing:10px 50px; &#125; border-spacing length 如果定义一个 length 参数，那么定义的是水平和垂直间距。 如果定义两个 length 参数，那么第一个设置水平间距，而第二个设置垂直间距。 七、 CSS表格标题位置 1234567&lt;style type="text/css"&gt;caption&#123;caption-side:bottom;&#125;&lt;/style&gt;&lt;caption&gt;This is a caption&lt;/caption&gt; CSS轮廓 轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用 使用outline属性 一、在元素周围画线123p&#123; outline: #0F0 dotted thick;&#125; dotted:为点状线 ###二、设置Outline属性12345p&#123; outline-style: dotted; outline-color: #0F0; outline-width: 3px;&#125; 常见outline-style: dotted dashed solid double groove ridge inset outset 注意:只有在规定了 !DOCTYPE 时，Internet Explorer 8 （以及更高版本） 才支持 outline-style 属性。 CSS框模型概述如图所示 示例：假设框的每个边上有 10 个像素的外边距和 5 个像素的内边距。如果希望这个元素框达到 100 个像素，就需要将内容的宽度设置为 70 像素，请看下图： 12345#box &#123; width: 70px; margin: 10px; padding: 5px;&#125; 提示 内边距、边框和外边距可以应用于一个元素的所有边，也可以应用于单独的边。 外边距可以是负值，而且在很多情况下都要使用负值的外边距。 CSS内边距 元素的内边距在边框和内容区之间，控制该区的属性为 padding padding 属性接受长度值或百分比值，但不允许使用负值 一、单边内边距属性 padding-top padding-right padding-bottom padding-left 二、内边距的百分比数值 示例：p {padding: 10%;} 注意:上下内边距和左右内边距一致，即上下内边距的百分数会相对于父元素宽度设置，而不是相对高度。 三、示例 (1) 设置上下内边距为0.5cm,左右内边距为2.5cm 123p &#123; padding: 0.5cm 2.5cm;&#125; 注意： padding 左边设置上下的内边距，右边设置左右的内边距 CSS边框 元素的边框(border)是围绕元素内容和内边距的一条或多条线 边框有三个属性： 宽度、样式、颜色 一、宽度 语法：border-width：； 设置宽度： thin ： 1px medium(默认值) : 2px thick : 3px 定义单边宽度 按照 top-right-bottom-left 顺时针顺序来设置各边宽度 ： border-width: 1px 1px 1px 1px border-top-width border-right-widthnone border-bottom-width border-left-width 二、样式 语法：border-style: ; 单边样式： 按照 top-right-bottom-left 顺时针顺序来设置各边样式 border-top-style border-right-style border-bottom-style border-left-style 没有边框 border-style: none; 三、边框颜色 使用border-color属性，一次最多可以接受4个颜色值 单边颜色： 按照 top-right-bottom-left 顺时针顺序来设置各边样式 border-top-color border-right-color border-bottom-color border-left-color 示例 12345p &#123; border-style: solid; border-color: blue rgb(25%,35%,45%) #909090 red; border-color: transparent; &#125; 四、所有边框设置在一个样式中 123p &#123; border: medium double rgb(250, 0, 255) ;&#125; CSS外边距 设置外边距的最简单的方法就是使用 margin 属性。 margin 属性接受任何长度单位，可以是像素、英寸、毫米或 em,margin 可以设置为 auto,也可以设置为百分比 示例：12345p &#123; margin: top right bottom left; margin: 10px 0px 15px 5px; margin: 10%;&#125; CSS定位CSS position 属性 通过使用 position 属性，我们可以选择 4 种不同类型的定位，这会影响元素框生成的方式。 position 属性值的含义： static 元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。 relative 元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。 absolute 元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 fixed 元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。 使用滚动条来显示元素内溢出的内容 当元素内容太大而超出规定区域时，如何设置溢出属性来规定相应的动作。 1234&lt;style&gt; overflow: scroll; overflow: hidden;&lt;/style&gt; overflow: hidden :隐藏溢出元素中溢出的内容 overflow: auto:设置浏览器来自动地处理溢出 元素显示的优先级 Z-index可被用于将在一个元素放置于另一元素之后。 Z-index: 设置元素的堆叠顺序。 12345678910&lt;script&gt;img.x&#123;position:absolute;left:0px;top:0px;z-index:-1z-index:1&#125;&lt;/script&gt; CSS 相对定位相对定位是一个非常容易掌握的概念。如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 1234567891011&lt;style type="text/css"&gt;h2.pos_left&#123;position:relative;left:-20px&#125;&lt;/style&gt;&lt;body&gt;&lt;h2&gt;这是位于正常位置的标题&lt;/h2&gt;&lt;h2 class="pos_left"&gt;这个标题相对于其正常位置向左移动&lt;/h2&gt;&lt;/body&gt; 注意，在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 CSS 绝对定位绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。 12345#box_relative &#123; position: absolute; left: 30px; top: 20px;&#125; 可知，绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%89%8D%E7%AB%AF%2FPHP%2F</url>
    <content type="text"><![CDATA[PHP入门 What is PHP??? PHP是一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入HTML中使用 是一种创建动态交互性站点的强有力的服务器端脚本语言 PHP： Hypertext Preprocessor –超文本预处理器 DNS DNS (Domin Name System 域名系统) ： 因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能使用户更方便的访问互联网 域名解析 用户通过主机名，最终得到该主机名对应的 IP 地址的过程 步骤： 用户输入域名 localhost –&gt; DNS (localhost 127.0.0.1) –&gt; 服务器电脑 PHP基本语法 php脚本可以放置在文档任意位置 123&lt;?php// PHP代码?&gt; 文本输出命令echo &amp; print 输出字符串可以包含HTML标签 echo 语句echo - 可以输出一个或多个字符串 echo 输出样式 12345678&lt;?php$txt = "学习PHP"；$arr = array('Jan', 'Ame', 'Chi');echo $txt;echo "我要 $txt";echo "想去的国家&#123;$arr[1]&#125;";?&gt; print 语句print - 只允许输出一个字符串，返回值为 1 如果字符串成功显示则返回true，否则返回false。 12345678&lt;?php$txt = "学习PHP"；$arr = array('Jan', 'Ame', 'Chi');print $txt;print "我要 $txt";print "想去的国家&#123;$arr[1]&#125;";?&gt; 比较 echo 输出速度比 print 快，echo 无返回值， print 返回值为 1 print $a 和 print &quot;$a&quot; 效果相同，echo 同理 print &quot;text$a text&quot; 和 print &quot;text $a text&quot; 和 print &quot;text{$a}text&quot; 都可以正常显示 $a 的值，不使用 {} 则 &amp;a 之后必须有一个空格，echo 同理 文本注释123456789&lt;?php// PHP单行注释/*PHP多行注释*/?&gt; 须知 PHP中每个代码行必须以分号结束，以使指令集区分开来 PHP变量 PHP为一门弱类型语言，不必向 PHP 声明该变量的数据类型。 PHP 会根据变量的值，自动把变量转换为正确的数据类型。 1234567&lt;?php$x=5;$y=6;$z=$x+$y;$txt="Hello,World!"echo $z;?&gt; 规则 变量以 $ 符号开始，后面跟着变量的名称 变量名不能包含空格 变量名是区分大小写的（$y 和 $Y 是两个不同的变量） PHP变量作用域 PHP 有四种不同的变量作用域： local global static parameter 局部与全局作用域 实例：12345678910111213141516171819&lt;?php $x=5; // 全局变量 function myTest() &#123; $y=10; // 局部变量 echo "&lt;p&gt;测试函数内变量:&lt;p&gt;"; echo "变量 x 为: $x"; echo "&lt;br&gt;"; echo "变量 y 为: $y"; &#125; myTest(); echo "&lt;p&gt;测试函数外变量:&lt;p&gt;"; echo "变量 x 为: $x"; echo "&lt;br&gt;"; echo "变量 y 为: $y"; ?&gt; global全局变量 函数内访问全局变量需要 global 关键字或者使用 $GLOBALS[index] 数组 global $x,$y; 123456789&lt;?php$x=5;$y=10;function mytest()&#123; $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];&#125;?&gt; 注意 在 php 中函数是有独立的作用域，所以局部变量会覆盖全局变量 Static作用域 当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除 123456function myTest()&#123; static $x=0; echo $x; $x++;&#125; 每次调用该函数时，该变量将会保留着函数前一次被调用时的值,且该变量仍然是函数的局部变量。 参数作用域 参数是通过调用代码将值传递给函数的局部变量,并且在参数列表中声明的:function mytest($x) PHP 字符串变量实例： 创建一个 txt 的字符串变量1234&lt;?php$txt="Hello World!";echo $txt;?&gt; PHP 并置运算符 . 在 PHP 中，只有一个字符串运算符。 并置运算符 (.) 用于把两个字符串值连接起来。 实例：12345&lt;?php$txt1="Hello";$txt2="World";echo $txt1 . " " . $txt2;?&gt; 字符串函数 strlen(&quot;string&quot;):返回字符串的长度 mb_strlen(&quot;字符串&quot;,&quot;utf-8&quot;): 设置指定编码输出中文字符个数 strpos(&quot;string&quot;,&quot;str&quot;):在字符串内查找一个字符或一段指定的文本的位置，若未找到匹配，则返回 FALSE PHP超级全局变量 PHP中预定义了几个超级全局变量（superglobals），这意味着它们在一个脚本的全部作用域中都可用。 $GLOBALS$GLOBALS 是PHP的一个超级全局变量组，在一个PHP脚本的全部作用域中都可以访问。 $GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键 示例：123456789101112&lt;?php $x = 75; $y = 25; function addition() &#123; $GLOBALS['z'] = $GLOBALS['x'] + $GLOBALS['y']; &#125; addition(); echo $z; ?&gt; 实例中 z 是一个$GLOBALS数组中的超级全局变量，该变量同样可以在函数外访问 $_SERVER $_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。 示例：12345678910111213&lt;?php echo $_SERVER['PHP_SELF'];echo "&lt;br&gt;";echo $_SERVER['SERVER_NAME'];echo "&lt;br&gt;";echo $_SERVER['HTTP_HOST'];echo "&lt;br&gt;";echo $_SERVER['HTTP_REFERER'];echo "&lt;br&gt;";echo $_SERVER['HTTP_USER_AGENT'];echo "&lt;br&gt;";echo $_SERVER['SCRIPT_NAME'];?&gt; 这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些 $_REQUEST PHP $_REQUEST 用于收集HTML表单提交的数据。 示例： 用超级全局变量 $_REQUEST 来收集表单中的 input 字段数据123456789101112131415&lt;html&gt;&lt;body&gt;&lt;form method="post" action="&lt;?php echo $_SERVER['PHP_SELF'];?&gt;"&gt;Name: &lt;input type="text" name="fname"&gt;&lt;input type="submit"&gt;&lt;/form&gt;&lt;?php $name = $_REQUEST['fname']; echo $name; ?&gt;&lt;/body&gt;&lt;/html&gt; $_POST有类似的用法 PHP 常量 常量是一个简单值得标识符，不可以在脚本中改变 设置PHP常量语法 bool define ( string $name , mixed $value [, bool $case_insentitive = false ]) 解释 name：必选参数，常量名称，即标志符 value：必选参数，常量的值 case_insensitive：可选参数，如果设置为TRUE，该常量则大小写不敏感。默认是大小写敏感的 示例：12345&lt;?php//不区分大小写的常量define("Hello", "Keithxodoy", True);echo Hello;?&gt; 注意事项 常量在定义后，默认是全局变量，可在任意脚本中使用 PHP EOF (heredoc) PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。 PHP 定界符 EOF 的作用就是按照原样，包括换行格式什么的，输出在其内部的东西 1234567&lt;?phpecho &lt;&lt;&lt;EOF &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;段落&lt;/p&gt;EOF;// 结束需要独立一行且前后不能空格?&gt; 1. 以 &lt;&lt;&lt;EOF 开始标记开始，以 EOF 结束标记结束，结束标记必须顶头写，不能有缩进和空格，且在结束标记末尾要有分号2. EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。3. 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。4. 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义。5. 在 heredoc 中，变量不需要用连接符 . 或 , 来拼接 补充:PHP_EOL 是一个换行符，兼容更大平台 PHP 数据类型 String Integer Float Boolean Array Object Null 示例1234567891011121314&lt;?php$x = "Hello ,world!";$y = 520;$z = 52.1;$a = True;$arr = array("1","2","3");class obj&#123; var $color; function what_color() &#123; return $this-&gt;color; &#125;&#125;$b = null; 拓展 判断变量类型：var_dump() 说明：var_dump() 方法，判断一个变量的类型与长度，并输出变量的数值，如果变量有值，则输出是变量的值，并返回数据类型。显示关于一个或多个表达式的结构信息，包括表达式的类型与值. 注意：用保证 var_dump 中的变量必须是存在的，如果变量不存在则返回 NULL. PHP 运算符以例子来理解 123456789101112&lt;?php$x=10;$y=6;echo ($x * $y); // 输出60 ,乘法echo '&lt;br&gt;'; // 换行 echo ($x / $y); // 输出1.6666666666667 ，除法echo '&lt;br&gt;'; // 换行 echo ($x % $y); // 输出4 ，取余echo '&lt;br&gt;'; // 换行?&gt; php7+ 新增整除运算符 示例：123&lt;?phpvar_dump(intdiv(10, 3));?&gt; 赋值运算符与算法运算符用法相同 PHP 递增/递减运算符 运算符 名称 描述 ++$x 预递增 x 加 1，然后返回 x $x++ 后递增 返回 x，然后 x 加 1 PHP 比较运算符 运算符 名称 描述 实例 x &lt;&gt; y 不等于 如果 x 不等于 y，则返回 true 5&lt;&gt;8 返回 true x !== y 绝对不等于 如果 x 不等于 y，或它们类型不相同，则返回 true 5!==”5” 返回 true x === y 绝对等于 如果 x 等于 y，且它们类型相同，则返回 true 5===”5” 返回 false PHP 逻辑运算符 运算符 名称 描述 x and y 与 如果 x 和 y 都为 true，则返回 true x or y 或 如果 x 和 y 至少有一个为 true，则返回 true x xor y 异或 如果 x 和 y 有且仅有一个为 true，则返回 true x &amp;&amp; y 与 如果 x 和 y 都为 true，则返回 true `x y` 或 如果 x 和 y 至少有一个为 true，则返回 true ! x 非 如果x 不为 true，则返回 true 三元运算符 语法格式 (expr1) ? (expr2) : (expr3) 对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。 (exp1)?: (expr3) 自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。 示例：12345&lt;?php$test = "一段字符"；$username = $test ?: 'nobody';echo $username, PHP_EOL;?&gt; ==&gt; 一段字符 组合比较符(PHP7+) PHP7+ 支持组合比较符 示例：比价两个整型数的大小12345&lt;?phpecho 1 &lt;==&gt; 1; // 0echo 1 &lt;==&gt; 2; // -1echo 2 &lt;==&gt; 1; // 1?&gt; 运算优先级 优先级 &amp;&amp; &gt; = &gt; and ` &gt; = &gt; or` 括号优先运算 PHP 条件语句PHp - if 语句 if 语句仅当指定条件成立时执行代码 示例：1234if (condition)&#123; // 条件成立时执行代码块；&#125; PHP - if…else 语句 在条件成立时执行一块代码，条件不成立时执行另一块代码 12345678if (条件)&#123; //条件成立时执行的代码;&#125;else&#123; //条件不成立时执行的代码;&#125; PHP - if…elseif….else 语句 在若干条件之一成立时执行一个代码块 示例：123456789101112if (条件)&#123; //if 条件成立时执行的代码;&#125;elseif (条件)&#123; // elseif 条件成立时执行的代码;&#125;else&#123; //条件不成立时执行的代码;&#125; 注意: elseif 和 else if 完全同效果，elseif 是 PHP 为 else if 专门做到容错版 PHP Switch 语句 如果希望有选择地执行若干代码块之一，可以使用 switch 语句 示例：判断n的值1234567891011121314&lt;?phpswitch (n)&#123; case num1: # code... break; case num2: # code... break; default: # code // 如果 n 即不等于 num1 也不等于 num2 ，此处代码将会被执行；&#125;?&gt; 解释:。代码执行后，使用 break 来阻止代码跳入下一个 case 中继续执行。default 语句用于不存在匹配（即没有 case 为真）时执行 PHP 循环while循环1234while (条件)&#123; 要执行的代码;&#125; do…while 语句 do…while 语句会至少执行一次代码，然后检查条件，只要条件成立，就会重复进行循环。 语法:12345do&#123; 要执行的代码;&#125;while (条件); for 循环 for 循环用于您预先知道脚本需要运行的次数的情况。 语法:1234for (初始值; 条件; 增量)&#123; 要执行的代码;&#125; foreach 循环 foreach 循环用于遍历数组。 语法:1234foreach ($array as $value)&#123; 要执行代码;&#125; 实例: 输出x数组内的元素1234567&lt;?php$x=array("one","two","three");foreach ($x as $value)&#123; echo $value . "&lt;br&gt;";&#125;?&gt; PHP数组语法：$arr=array(); 在 PHP 中，有三种类型的数组： 数值数组 - 带有数字 ID 键的数组,自动分配 ID 键（ID 键总是从 0 开始 关联数组 - 带有指定的键的数组，每个键关联一个值 多维数组 - 包含一个或多个数组的数组 数值数组实例12345&lt;?php$cars=array("BMW","Volvo","Toyota");echo "one" .$cars[0]. "," .&amp;cars[1]. "," .&amp;cars[2]. ".";echo count(&amp;cars);?&gt; 获取数组的长度 - count() 函数 12345for($x=0;$x&lt;$count(&amp;cars);$x++)&#123; echo $cars[$x]; echo "&lt;br&gt;";&#125; PHP关联数组语法： &amp;age=array(&quot;TOM&quot;=&gt;&quot;25&quot;,&quot;KIT&quot;=&gt;&quot;21&quot;); $age[&#39;TOM&#39;]=&quot;25&quot;; $age[&#39;KIT&#39;]=&quot;21&quot;; 遍历关联数组 123456789&lt;?php$age=array("TOM"=&gt;"25","KIT"=&gt;"21"); foreach($age as $x=&gt;$x_value)&#123; echo "Key=" . $x . ", Value=" . $x_value; echo "&lt;br&gt;";&#125;?&gt; PHP多维数组 多维数组是包含一个或多个数组的数组。 实例: 二维数组:123456789&lt;?php$cars = array( array("Volvo",100,96), array("BMW",60,59), array("Toyota",110,100));?&gt; PHP print_r() 函数 print_r() 函数用于打印变量，以更容易理解的形式展示。 print_r() 将把数组的指针移到最后边。使用 reset() 可让指针回到开始处。PHP 版本要求: PHP 4, PHP 5, PHP 7 实例:1234&lt;?php$a = array ('a' =&gt; 'apple', 'b' =&gt; 'banana', 'c' =&gt; array ('x','y','z'));print_r ($a);?&gt; 输出结果为：123456789101112Array( [a] =&gt; apple [b] =&gt; banana [c] =&gt; Array ( [0] =&gt; x [1] =&gt; y [2] =&gt; z )) PHP数组排序概述PHP - 数组排序函数 sort()- 对数组进行升序排列 rsort()- 对数组进行降序排列 asort()- 根据关联数组的值，对数组进行升序排列 ksort()- 根据关联数组的键，对数组进行升序排列 arsort() - 根据关联数组的值，对数组进行降序排列 krsort() - 根据关联数组的键，对数组进行降序排列 示例12345&lt;?php $numbers=array(4,6,2,22,11); sort($numbers); print_r($numbers); ?&gt; 运行结果12345678Array( [0] =&gt; 2 [1] =&gt; 4 [2] =&gt; 6 [3] =&gt; 11 [4] =&gt; 22) PHP 函数在PHP中，提供了超过1000哥内建函数，这才是PHP真正强大的来源 创建函数函数通过调用函数来执行 123456&lt;?phpfunction functionName()&#123; // 执行代码&#125;?&gt; PHP 函数准则： 函数的名称应该提示出它的功能 函数名称以字母或下划线开头（不能以数字开头） 函数参数在函数名后的括号内添加参数,而且一个函数可以有多个参数 示例：1234567&lt;?phpfunction name($name)&#123; echo "myname is" . $name;&#125;name("keith");?&gt; 输出：myname is keith 函数返回值如果让函数返回一个值，使用return语句 12345678&lt;?phpfunction add($x, $y)&#123; $total = $x +$y; return $total;&#125;echo "1 + 5 = " . add(1,5);?&gt; PHP 常见的疑问双引号与单引号 双引号 PHP允许我们在双引号串中直接包含字串变量，我们可以发现下面的两个字串的处理结果是相同的。 代码如下:12$full_name = $first_name . ' ' . $last_name; $full_name = "$first_name $last_name"; 单引号 单引号里是普通字符是啥就是啥]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim]]></title>
    <url>%2F2018%2F06%2F29%2F%E7%BC%96%E8%BE%91%E5%BF%AB%E6%8D%B7%E9%94%AE%2FVim%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[命令 功能 h 向左 j 向下 k 向上 l 向右 行内移动命令 作用 w 向后移动一个单词 b 向前移动一个单词 0 迅速回到行首 ^ 回到行首，第一个不是空白字符的位置 $ 回到行尾 行数移动命令 英文 作用 gg go 回到文件顶部 G GO 回到文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 :数字 移动到 数字 对应行数 屏幕移动 英文 功能 Ctrl+b back 向上翻页 Ctrl+f forwarf 向下翻页 ctrl + H Head 屏幕顶部 ctrl + M Middle 屏幕中间 ctrl + L Low 屏幕底部 编辑命令 英文 作用 i 进入编辑模式 esc 退出 y copy 复制 yy copy 复制一行，多行复制可以nyy,如 2 YY p paste 粘贴 u 撤销上一步的操作 Ctrl+r 恢复上一步被撤销的操作 dd Delete 删除，实际上是剪贴，将删除内容放入文本缓冲区中 缩放命令 ctrl + shift + = 放大 Ctrl + - 缩小 常用Linux命令 英文 作用 ls list 查看当前文件夹下的内容 pwd print work directory 查看当前所在文件夹 cd change directory 切换文件夹 touch touch 新建文件 mkdir make directory 创建目录 rm [-r] remove 删除指定的文件或目录 clear clear 清屏 终端命令格式command [-0ptions] [parameter] command : 命令名，相应功能英语缩写 -Options: 选项，可以对命令进行控制，也可以省略 parameter: 传递给命令的参数，可以为多个]]></content>
      <categories>
        <category>keybinding</category>
      </categories>
      <tags>
        <tag>keybinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keyboard]]></title>
    <url>%2F2018%2F06%2F29%2F%E7%BC%96%E8%BE%91%E5%BF%AB%E6%8D%B7%E9%94%AE%2Fkeyboard%2F</url>
    <content type="text"><![CDATA[CTRL + F 搜索功能CTRL + D 复制一行代码CTRL + Y 删除一行代码在任意位置按住shift + 回车 快速换行CTRL + / 批量注释与取消选中代码 + tab 批量缩进SHIFT + tab 批量取消缩进CTRL + R 代码替换CTRL + - （+）代码折叠（代码展开）CTRL + SHIFT -(+) 代码完全折叠（展开）CTRL + 鼠标左击 查看源代码 TODO 记录要做的事情Ctrl+\ 全屏模式Alt”+”R”运行脚本]]></content>
      <categories>
        <category>keybinding</category>
      </categories>
      <tags>
        <tag>keybinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2018%2F06%2F29%2F%E7%BC%96%E7%A8%8B%E9%A2%98%E5%BA%93%2F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[leetcode 刷题心得与题解 15. 3SUM题目：1234567891011121314151617Given an array nums of n integers,are there elements a, b, c in nums such that a + b + c = 0?Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] O（n3）的时间复杂度经过修改也没啥用 固定i，j、k为双向指针，j从头开始，k从尾开始遍历。当和小于0时，j减1，当和大于0时，k加1当找到一个值时，不能当做此时i的固定结果，因为可能有多个，所以需要再把j、k其中之一改变，j加1或者k减1都可以1234567891011121314151617181920212223class Solution(object): def threeSum(self, nums): length = len(nums) resultList = [] nums.sort() for i in range(0,length-2): j = i + 1 k = length - 1 while (j &lt; k): sum0 = nums[i] + nums[j] + nums[k] if (sum0 == 0): result = [] result.append(nums[i]) result.append(nums[j]) result.append(nums[k]) if result not in resultList: resultList.append(result) j +=1 if (sum0 &lt; 0): j +=1 if (sum0 &gt; 0): k -=1 return resultList]]></content>
      <categories>
        <category>编程题库</category>
      </categories>
      <tags>
        <tag>编程题库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm]]></title>
    <url>%2F2018%2F06%2F29%2F%E7%AE%97%E6%B3%95%2FAlgorithm%2F</url>
    <content type="text"><![CDATA[算法 初探算法Question: 猜价格 价格大了 价格小了 猜对了 递推算法顺推法斐波那契数列12345678910long fib[NUM] = &#123;1, 1&#125;;for (i=2; i&lt;num; i++)&#123; fib[i] = fib[i-1] + fib[i-2] ;&#125;for (i=0; i&lt;num; i++)&#123; printf("兔子目前的总数为:%d\n", fib[i]);&#125; 逆推法案例 : 银行存款的提取利息假设第48个月,利息为1000元 12345678910111213141516171819#include &lt;stdio.h&gt;#define Fetch 1000#define Rate 0.0171int main()&#123; double month[49]; //每个月的本利 int i ; month[48] = (double)Fetch; for(i=47; i&gt;0; i--) //由第48月的利息来倒推处第一个月 &#123; month[i] = (month[i+1]+Fetch)/(1+Rate/12); &#125; for(i=48; i&gt;0; i--) &#123; printf("第%d月末的本利合计为:%.2f\n", i, month[i]); &#125; getch(); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm step</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机科学]]></title>
    <url>%2F2018%2F06%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%2FComputer%20Science%2F</url>
    <content type="text"><![CDATA[c语言 1234if (condition || condition)&#123; // do this---&#125; 计算机科学理论 比特BIT – binary digit 8 BIT – 1 Byte 计算机中数的表示例如 7 –二进制 以2的幂计算 十进制中 ： 1 2 4 8 … 二进制中 ： 1 1 1 0 … 即 7 的表示为 0111 硬盘组成 由非常微小的磁性粒子组成，有规定的排列顺序，就如小磁针，南北指向可以代表比特中的 0 1 ,就由这些磁针来储存数据 C语言123456#include &lt;stdio.h&gt;int main()&#123; printf("Hello,World!\n");&#125; 字符串printf输出实例123456string name = "keithxodoy";float num = 5.264printf("hello,%s！\n", name);printf("%.2f\n", num);printf("%d\n", sizeof(i) ); sizeof ==&gt; 输出数据类型的长度 条件语句 conditions123456789101112if (condition)&#123; // do this&#125;else if (condition)&#123; /* code */&#125;else&#123; //code&#125; “或”、”且” 条件 123456789if (condition || condition)&#123; // do this&#125;if (condition &amp;&amp; condition)&#123; //do this&#125; switch 语句–多重条件,枚举结构 123456789101112131415switch (n)&#123; case 1: case 2: case 3: printf("You picked a small number "); break ; case 4: case 5: case 6: printf("anothor one%% ")； break ; default: printf("the last one ");&#125; 解释 当条件情况case 为 1、2、3时，作case3下的操作，再使用 break 中断循环 使用default处理case以外的情况，可以不使用 break %% 表示 百分比 循环结构12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;intmain()&#123; for (int i = 0; i &lt;= 5; i++) &#123; printf("A test\n"); fflush(stdout); sleep(2); &#125;&#125; 解释 fflush(stdout) : 将循环的进度以类似进度条的形式在一行中显示出来 通信原理互联网的本质就是一系列的网络协议 两台计算机之间的通信与两个人打电话之间的原理是一样的，可以讲统一的普通话 osi七层协议 互联网协议按照功能不同分为osi七层或tcp/ip四层 口诀： 应表会运网数物 物理层和数据链路层物理层由来：孤立的计算机之间想要一起通信，就必须接入Internet,言外之意就是计算机之间必须完成组网 功能：主要是基于电器特性发送高低电压(电信号)，高电压对应数字1，低电压对应数字0 在一个客户端对数据的二进制进行分组，使得电信号变得有意义。 数据链路层由来：单纯的电信号1和0没有任何意义，必须规定电信号多少位为一组，每组代表什么意思 功能：定义了电信号的分组方式 以太网协议 背景：早期的各个公司都有自己的分组方式，后来形成了统一标准，即以太网协议ethernet 规定 一组电信号构成一个数据包，叫做”帧” 每一数据帧分成：接头head和数据data两部分 head (固定18个字节) data(最短46字节，最长1500字节) 发送者/源地址：6字节 包括数据包的具体内容 接收者/目标地址：6字节 数据类型：6字节 head长度 + data长度 = 最短64字节 ， 最长1518字节。 超过最大限制就分片发送 mac地址 head中包含的源和目标地址由来：ethernet规定接入的设备都必须具备网卡，发送端和接受端的地址指的是网卡的地址，即mac地址 mac地址: 每块网卡出厂时都被烧制上一个世界唯一的mac地址(物理地址),长度为48位二进制，通常由12位16进制数表示。其中前六位是厂商编号，后六位是流水线号。 广播 有了mac地址，同一网络内的两台主机就可以通信了(一台主机通过arp协议获取另一台主机的mac地址) ethernet采用最原始的方式–广播的方式进行通信，通俗理解，计算机通信基本靠哄 所有user收到包后，解包后，若mac地址不是指本机，则丢包，而接受的mac地址是本机的，则接受信息 网络层由来：有了ethernet、mac地址、广播的发送方式，世界上的计算机就可以彼此通信了 问题提出：世界范围内的互联网是由一个个彼此隔离的小局域网组成的，那么如果所有的通信都采用广播的方式，那么一台机器发送的包会被全世界接收到，这样不仅效率低下，而且会导致互联网灾难！！！ IP协议 规定网络地址的协议叫做IP协议，它定义的地址称之为ip地址，广泛采用v4版本，即ipv4(默认网关)。规定了网络地址由32位二进制表示 范围 0.0.0.0 – 255.255.255.255 一个ip地址通常写为四段十进制数，例如：172.16.10.1 ip地址组成部分 网络部分：标识子网 主机部分：标识主机 注意：单纯的ip地址只是标识了ip地址的种类，从网络部分或主机部分都无法辨识一个ip所处的子网，如：172.16.10.1 与 172.16.10.2 不能确定两者处于同一子网 子网掩码 ip数据包 ip数据包分为head和data部分，无须为ip包定义单独的栏位，直接放入以太网包的data部分 head : 20-60字节 data : 最多65515字节 以太网数据包最长只有1500字节，而超出部分，需要分割为几个以太网数据包，分开发送 最终包的格式 以太网头 ip头 ip数据 arp协议 由来： 通信是基于mac的广播方式实现，计算机在发包时，获取自身的mac是容易的，而获取目标主机的mac，则需要通过arp协议 功能 广播的方式发送数据包，获取目标主机的mac地址 协议工作方式 每台主机的ip都是已知的 一、首先通过ip地址和子网掩码区分出自己所处的子网 二、分析源ip和目标ip是否处于同一网络 三、包会以广播的方式在发送端所处的子网内传播，所有主机接受后拆包，发现目标ip为自己的，就响应，返回自己的mac 理解mac地址与ip地址：mac地址相当于房间号，ip地址相当于所在酒店具体位置 传输层和应用层传输层由来：网络层ip帮助用户区分子网，以太网层的mac地址帮用户找到主机，然后用户使用应用程序。而通过ip和mac找到一台特定的主机，此时端口就是用来标识这台主机上的应用程序，应用程序对应窗口。端口：应用程序与网卡关联的编号功能:建立端口之间的通信补充：端口的范围为0-65535，其中0-1023为系统占用端口tcp协议 可靠传输，TCP数据包没有长度限制，理论上可以无限长，但为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割 以太网头 IP头 TCP头 数据 udp协议 不可靠传输，”报头”部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据包 以太网头 IP头 udp头 数据 应用层由来：用户使用应用程序，工作于应用层，由于互联网是开放的，大家都可以开发自己的应用程序，数据多种多样，必须要规定好数据的组织形式 功能：规定应用程序的数据格式 示例： TCP协议可以为各种各样的程序传递数据，例如E-mail、www、FTP等，则必须有不同协议规定电子邮箱、网页、FTP数据的格式 这些应用程序协议就组成了应用层 Socket 编程网络中的进程是通过socket来通信的,而socket起源于Unix，Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。 可以理socket是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭） FAQ 对硬盘或软盘进行格式化时会发生什么？ 解答 不会产生很大改变，对盘进行格式化（分区）只会修改几字节或几千字节的信息，使得电脑无法知道原先的文件或文件夹被存放至哪个位置，但是这些数据仍在原先的位置存储着 编译器作用 ？ 解答 将代码文件编译为二进制文件]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux教程.md]]></title>
    <url>%2F2018%2F06%2F28%2FLinux%2FLinux%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[LINUX 初探 知识概念网络概述1970年 — Linux元年1969年 — Internet元年 局域网(LAN) - Local Area Network : 指范围在几百米到十几公里内办公楼群或校区内的计算机相互连接所构成的计算机网络 城域网(MAN) + Metropolitan Area Network 广域网(WAN)- Wide Area Network : 通常跨接很大的物理范围，如一个国家 网络分类 – 公网 &amp; 内网 公网：上网的计算机得到的 IP 地址是 Internet 上的非保留地址，公网的计算机和 Internet 上的其他计算机可以随意相互访问 IP 地址IP (Internet Protocol) : 网络之间互连的协议，即网络相互连接进行通信而设计的协议 IP 地址类型 ： 公有地址、私有地址 1.0.0.0 - 255.255.255.255 公有地址(Public address) 公有地址由 Inter NIC (Internet Network Information Center 因特网信息中心)负责。这些 IP 地址分配给注册并向 Inter NIC 提出申请的组织机构(免费)，可以通过它直接访问因特网 私有地址(Private address) 私有地址属于 非注册地址，专门为组织机构内部使用，用以分散使用 类别 私有 IP 地址 使用对象 最大主机数 最大网络数 A 类 10.0.0.0 - 10.255.255.255 电信、联通等运营商 16777214 126 (2^7-2) B 类 172.16.0.0 - 172.31.255.255 65534 16384(2^14) C 类 192.168.0.0 - 192.168.255.255 使用最多 254 2097152(2^21) DNSDNS (Domin Name System 域名系统) ： 因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能使用户更方便的访问互联网 域名解析 用户通过主机名，最终得到该主机名对应的 IP 地址的过程 步骤： 用户输入域名 localhost –&gt; DNS (localhost 127.0.0.1) –&gt; 服务器电脑 端口(Port) 端口可以认为是设备与外界通讯交流的出口 端口: 虚拟端口 和 物理端口 虚拟端口 ： 计算机内部或者交换机路由器内的端口，不可见端口 物理端口 ： 如计算机的 80端口、 21端口等，可见端口例如 计算机背板的 RJ45网口 **用户输入域名 localhost：端口 –&gt; DNS (localhost 127.0.0.1) –&gt; 服务器电脑 –&gt; 软件（服务） **文件与用户的关系 所有者 u : 只有一个，但可以交换 用户组 g ： 只有一个，可以使用文件，但不是所有者 其他人 o ： 既不属于所有者，又不是用户组 格式 -： 表示文件 d： 表示目录 l : 表示软连接 例子 ：rw- r– r– rw- : 代表文件的所有者有读写的权限，代表最高权限，不一定需要赋予所有权限，够用就行 r– : 代表赋予用户组的权限 — : 代表赋予其他人的权限 软链接 类似 Windows快捷方式，不决定原文件的权限，只是符号链接 三种用户都有所有权限 rwx ， 文件为 l 开头 ，文件大小较小 硬链接 相当于拷贝 cp -p（保留属性） + 同步更新 一个i节点对应到了两个文件 注意 ： 硬链接不能跨分区 ，而且不能针对目录使用文件操作 r(读) w(写) x(执行) 文件覆盖 y Linux配置设置Linux的IP地址ifconfig eth0 ip地址 添加虚拟网卡 ifconfig eth0:1 198.168.1.1 操作技巧 文件部分名称+ tab ： 自动补全文件名 Ctrl shift = : 放大终端窗口的字体显示 Ctrl - : 缩小终端窗口的字体显示 向上/下箭头:查看历史输入命令 Linux命令查阅命令帮助信息help:command --help : 显示帮助信息man:man command : 查阅使用手册 空格:显示手册下一屏 Enter:下一行 b:回滚一屏 f:前滚一瓶 q:退出 /word:搜索word字符串 命令格式 命令 -选项 -参数 例子 ： ls -la /etc命令的选项可以同时使用，且不分顺序 文件处理命令 文件命令 作用 英文 ls 目录处理命令 list ls -a 查看目录所有文件（含隐藏文件） 可以添加目录参数 ls -l 查看文件的详细信息 ls -lh 人性化显示文件信息,更直观显示文件大小 ls -ld /etc 只示目录本身的信息 ls -i 查看文件的i节点 （即为文件的id信息） 说明 .开头为隐藏文件,需要-a参数查看或者Ubuntu进入目录，按ctrl h就能看见以点号开头的隐藏文件 .当前目录 ..上一级目录 目录命令 英文 作用 mkdir make directories 创建新目录 mkdir -p 递归创建新目录，并且在新目录在再进行创建，可同时创建多个 cd change directories 切换目录 . 代表当前目录 ..回到上一级目录 pwd print working directories 显示当前工作目录 rmdir remove directories 删除空目录 cp copy 拷贝目录或文件 cp -rp [原文件或目录] [目标目录] r为复制目录操作 p为保留文件属性 可以同时复制多个 mv move 目录剪切 移动 mv [绝对路径] [目标路径] 若是要剪切当前路径下的文件 可以直接 mv [文件名] [目标目录] rm remove 删除文件或名录 要慎重 rm -f 强制删除 rm -r 删除目录 rm -rf 直接删除目录 cd 补充 作用 cd ~ 切换到当前用户的主目录 cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 文件处理 作用 例子 touch 创建空文件 touch /root/book.list cat 浏览文件内容 可以加 -n 参数 cat -n /etc/issue tac cat 的倒序显示可以倒序显示文件内容 more 分页显示文件，适合查看长文件 less 分页浏览 head 查看文件的前n行,默认为10行 head -n 8 tail 查看文件的末尾n行 tail -f /var/log/message 动态显示问文件 链接处理 作用 例子 ln /etc/issue /tmp 默认创建硬链接 ln -s 软连接 注意事项: touch 若要创建带空格文件名的文件，可touch &quot;my love&quot;,即加上双引号 最好不要在Linux中创建带有特殊符号的文件名 cat 不太适合浏览含有非常多内容的文件 more 按 空格 ： 一页一页浏览 按 回车 ： 一行一行浏览 按 q : 退出浏览 cp cp -p : 该属性可以保持复制文件或目录的信息，如创建和修改的时间等 cp -r cp -r : 可以在复制文件或目录时，将文件名进行修改 mv mv 当前目录下的文件名 要修改成的名字 : 可以作为文件名修改命令 less 可以倒回去浏览内容 pageup : 一页一页往回翻 上箭头 : 一行一行往回翻 /service ： / 斜杠可以用来搜索，按 n 可以翻看下一页 权限管理命令命令名称： chmod 命令原意： change the permissions mode of a file 所在路径： /bin/chmod 功能描述： 改变文件或目录权限 可以更改权限的对象： root &amp; 所有者 语法 chmod [{ugoa}{+-=}{rwx}] [文件或目录][mode=421] [文件或目录] -R 递归修改 例子 ： chmod u+x myblog.md – 给所有者(u)赋予myblog文件的写(x)的权限 补充 ： 通过”+-=”来修改权限 一般通过权限的数字来表示： r–4 w–2 x–1 rwx : 7 ; rw- : 6 ; r–: 4 例子 ： chmod 640 myblog.md 注意： chmod 默认改变当前指定的文件或目录，对目录下的子目录不进行修改 若需要修改，则可以添加-R属性 正确理解目录rwx权限 注意：r+x 权限是同时出现的 w权限的说明： 对文件的删除是否能进行，是与用户在该文件所在目录被赋予的权限有关 若用户被给予W权限，则可以删除该文件 改变所有者命令 chown 命令名称 ： chown – change file ownership 命令所在路径 : /bin/chown 执行权限 ： root用户 功能描述 ： 改变文件或目录的所有者 语法- 基本语法 : chown [用户][文件或目录] 注意事项 只有root管理员身份才能修改所有者 修改所有者时，要确保新所有者用户存在 创建新用户 useradd 用户名 ,并且谁创建的文件，谁就是所有者 改变文件所有组 chgrp 命令名称 ： chgrp – change file group ownership 命令所在路径 ： /bin/chgrp 执行权限 ： 所有用户 语法 基本语法 ： chgrp [用户组][文件或目录] 范例 : $ chgrp newgroup doc : 将doc文件的所属组改为newgroup 创建新组 ： groupadd 新组名 设置新建文件的缺省权限 umask 命令名称 ： umask – the user file-creation mask 命令所在路径 ： Shell内置命令 执行权限 ： 所有用户 功能描述 ： 显示、设置文件的缺省权限 语法 基本语法 ： umask [-S] S : 以 rwx 形式显示新建文件的缺省权限 范例 ： $ uamsk -S 拓展语法 umask 023 含义 ：所有权限777 ,将 777 - 023 = 754 ,则为新设置的目录权限为 rwx–rx–r 注意 touch 创建新文件是不具有可执行权限的 文件搜索命令文件搜索命令 find 命令名称： find 命令所在路径： /bin/find 执行权限： 所有用户 语法 find [搜索范围][匹配条件] 更多用法 $find /etc -name init :使用-name 精准搜索 粗略搜索 *init* 不分文件名大小写 -iname ：匹配任意字符 ？：匹配单个字符 $find / -size : 使用-size 根据文件大小来查找 find / -size +204800 : 在根目录下查找大于100MB的文件 +n 大于 -n 小于 n 等于 大小说明 1K = 2数据块 1数据块 = 512字节 = 0.5K $find /home -user（-group） yonghu ：根据文件所有者(所属组)来查找 find -type f :根据文件类型查找 – f 文件 d 目录 l 软连接文件 find -inum : 根据i节点查找 ，通过i节点，可删除特殊文件 根据文件信息修改的时间来查找 $find /etc -amin -5:查找5分钟内被访问过的文件和目录 – access $find /etc -cmin -5:查找5分钟内被修改过属性的文件或目录 – change $find /etc -mmin -5:查找5分钟内被修改过内容的文件或目录 – modify 常用连接选项 作用 范例 -a (and) 表示两个条件同时满足 $find /etc +163840 -a -size -204800 -o (or) 表示两个条件满足任意一个即可 $find /etc 163840 -o -size 204800 注意事项 查找文件时，文件名的大小写是区分开来的 文件搜索命令 locate 命令名称： locate 命令所在路径： /usr/bin/locate 执行权限 ： 所有用户 语法 基本语法 locate 文件名 功能 ： 在文件资料库中查找文件 范例：$locate init 文件库： /var/lib/mlocate/mlocate.db 拓展语法 locate -i 文件名 : 不区分大小写来查找文件 注意 当创建的文件没有被存入文件资料库中时，无法使用locate查找到文件 解决方法： $ updatedb 手动更新 文件资料库不会收取 /tmp 临时文件夹下的文件，故使用locate可能无法搜索到该目录下文件 文件搜索命令 which 命令名称： which 命令所在路径 ： /usr/bin/which 执行权限 ： 所有用户 功能描述： 搜索命令所在目录及别名信息 例子 ： $ which ls 文件搜索命令 whereis 命令名称: whereis 命令所在路径： /usr/bin/whereis 执行权限 ： 所有用户 功能描述： 搜索命令所在目录及帮助文档路径 例子： $ whereis ls 文件搜索命令 grep 命令名称 ： grep 命令所在路径： /bin/grep 执行权限: 所有用户 功能描述 : 在文件中搜寻字串匹配的行并输出，即在文件内进行搜索 语法 基本语法 $ grep mysql /root/install.log $ grep + 查找关键词 + 文件所在地址 拓展语法 $ grep -i : 不区分大小写来查找 $ grep -v : 排除指定字串来查找 $ grep -v ^# : 过滤掉位于行首的文件脚本注释行 文件解压操作tar -zxvf 压缩文件名 注意事项目录：/proc/ /sys/ : 为系统内存和内核，只可读，写入的数据在重启时会清除，不要往内写入文件 /tmp : 临时目录，存放临时文件，建议不要存放重要文件，重启时最好清除 /var : 动态数据保存位置，注意保存缓存，日志已经软件运行产生的文件 /usr : 系统软件资源目录，为“Unix Software Resource”的缩写，用于存放系统软件资源的目录，系统安装的软件资源基本存放在此目录 服务器： 远程服务器不允许关机，只能重启 重启时应该关闭服务 不要在服务器访问高峰运行高负载命令 ，如对大数据的处理 远程配置防火墙（过滤作用）时，不要把自己踢出服务器 其他： 指定合理的密码规范并定期更新 合理分配权限 – 用户的权限越少越好 定期备份重要数据与日志，多处存储 Linux命令若未指定目录，则默认在当前目录里执行操作 Linux 新建的文件的 x(可执行)权限会自动去除]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>Linux初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐理知识.md]]></title>
    <url>%2F2018%2F06%2F28%2F%E9%9F%B3%E4%B9%90%2F%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[乐理入门 泛音 概念：物体局部振动产生的复合音的总和 以弦的振动来说，除了整个弦的振动，其二分之一，三分之一…各段都在振动，共同发音 作用：对音色具有决定性的作用，通过增减泛音的音量，可对音色有明显的改变 音阶 什么是音阶 调式中由高低次序（上下行），由主音到主音排列起来 音级概念乐音体系中的各个音，例如钢琴有88个不同音高的音，则音级为88 基本音级 从 do–si 七个独立音叫做基本音级，并通过字母或唱名标记 钢琴白键便是7个基本音级的循环重复 Do Re Mi Fa Sol La S 对应 C D E F G A B 两个相邻具有相同名称的音级叫做八度, 即相差一个八度，一个八度音阶共有7个基本音级和5个变化音级，共12个音组成（12平均音） 变化音级升高或者降低基本音级而获得的音，钢琴中用黑键表示 变化音级标注法 升 or “#” 降 or “b” 重升 or “x” 重降 or “bb” 其中音高相同而意义和记法不同的音叫做“等音” ，如#C , bD 乐音分组目的: 由于乐音体系中音级会循环出现，于是为了区分音名相同而音高不同，将其分组 以钢琴为例，最中央的12个音级叫做小字一组 音域及音区总音域概念: 指音列的总范围，乐器和人声的音域指能发生出的最高或最低音的范围 不同音区表现不同的音色/情感等特征 五线谱 概念: 通用的标准记谱法，由五条平行横线构成 音符通过在五线谱中记录在线上或间内 作用: 音符位置决定音的高低，形状决定音的长短 注意: 当五线不足以记录时，通过上加或下加线** 来解决 五线谱由自下而上计算，音高也由自下而上由低到高 多声部五线谱 多声部需要数行五线谱来记录，需要使用连谱号连接 连谱号: 包括起线（连接数行五线谱的垂直线）和括线（连接数行五线谱的括弧） 在总谱中，使用小节线连接同种类型的乐器连谱号括弧 花线 钢琴/风琴/手风琴/竖琴 直线 合奏/合唱乐队 有时在直线外还会加上辅助括线， 起线 位置在五线谱的开端，需连接全部的五线谱 音符概念: 记录不同长短的音的进行的符号 成分: 符头/符干/符尾 休止符休止符: 记录音的间断的符号 持续时间: 每个音符的持续时间为倍数减少，如二分音符持续2S.则四分音符持续1S 附点: 记在音符符头或者休止符右边的小圆点，表示增长原有音符或休止符时值得一半，且每增加一个附点，则增长时间为前一个附点值得一半 音符记谱 音符记录在五线谱的线或间上，符头越高，音高越高 五线谱音线有1-5，从下到上 符头方向判断 符头在三线以上，符干朝下，附在符头左边 符头在三线以下，符干朝下，附在符头右边 符头在三线上，则符干可上可下，符干方向随附近音符方向决定 符干 单声部永远使用单符干记谱（独立记谱） 多声部只有在节奏相同时，才用单符干记谱，如“三十二音符” 符尾 符尾在符干右边并且向符头方向弯曲 一符干 多音 同时连接多个音，表示这些音需要同时弹奏 同一符干连接多个音，符干方向以离第三线最远的音符为标准记录，且符尾方向相同 简谱与五线谱大音阶 对应手指 大拇指-小拇指 ： 1-2-3-4-5 C大调 ： 1-2-3-1-2-3-4-5 C 位于 下加一线 G大调 C 位于 第二线]]></content>
      <categories>
        <category>How to become a DJ</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电音入门.md]]></title>
    <url>%2F2018%2F06%2F28%2F%E9%9F%B3%E4%B9%90%2F%E7%94%B5%E9%9F%B3%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一入电音深似海引言 Can u feel the volume of my love for u 电音风格Techno – 高科技舞曲 理解 ： 重复动次打次 House music –舞蹈音乐 场景 ： 各大酒吧 风格 ： 类似Techno, 但高潮部分，会突然爆发不同的旋律 辨别 4/4拍 动次动次 动 ： 大姑 次 ： 镲 BPM(beats per minutes) : 118-135bpm ,最常见的为 128bpm Progressive House 辨别 ： 一层一层的堆叠感 拍数不断堆叠 内容 一定具有VOCAL(人声)，和弦等 Electric House 辨别 ： 电子制作 人造的音色 内容 与鼓点同步的Bass声音(sub) 类似 dong-en “咚-嗯” Big Room House 辨别 ： 单一洗脑 富有侵略性的旋律 内容 一串串 “叭叭叭”的声音 类似喇叭的声音 Melbourne Bounce 辨别 : 慢摇 缩放感 发出”嗯-嘚”的声音 Deep House 辨别 ： 结构稳定 情绪起伏小 速度较慢 120bpm Tropical House 辨别 : 热带感的乐器、音色 有种令人想跳舞的感觉 Future House 辨别 ： 常以 bassline 主旋律 有点空空的感觉 由一条bass的主旋律 Tech House 辨别 ： 碎拍、旋律不明确 打击乐特别多 次次次的声音特别多 Techno &amp; House Dubstep 风格 ： 偏向黑暗系， 嗡嗡嘭嘭感十足 Trap]]></content>
      <categories>
        <category>How to become a DJ</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多进程初探]]></title>
    <url>%2F2018%2F06%2F26%2FPython%2FPython%E7%90%86%E8%AE%BA%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%26%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[搞定多进程与多线程 多线程概念程序: 代码以文本的形式存入一个文档 进程: 程序运行的一个状态，包含地址空间、内存、数据栈等 每个进程由自己==完全独立==的运行环境，多进程共享数据 轻量化的进程 一个进程的多个线程间共享数据和上下文运行环境 共享、互斥问题 线程: 一个进程的独立运行片段，一个进程可以由多个线程 全局解释器锁(GIL) Python代码的执行是由python虚拟机进行控制 在主循环中有一个控制线程在执行 Python包thread： 有问题，不好用 python3： _thread* `import _thread as thread ` threading: 通行的包 直接利用threading.Thread生成Thread t = threading.Thread(target=xxx, args=()) t.start(): 启动多线程,可独立于主线程 t.join() : 等待多线程执行完成 守护线程 daemon子线程会在主线程结束后自动退出**，一般认为守护线程不重要或不允许离开主线程独立运行 设置守护线程–在t.start()前* `t.setDaemon(True)` 1234if __name__ == "__main__" main() while True: time.sleep(5) 启动线程–使用多线程执行某个函数thread.start_new_thread(loop,() 理解启动多线程: 相当于给多个工人分配任务，自己可以做别的事情，等自己事情做完了，工人也恰好完工（完成时间非常快） 注意事项 启动多线程函数为 ==start_new_thread== 参数为两个，一个是运行的==函数名==，另一个是==函数参数==作为元组使用，若为空，则使用空元组，若函数只有一个参数，则在参数后需要一个==逗号==，标识为元组启动多线程 ==一定要使用while语句==，因为启动多线程后本程序就作为主线程存在，如果主线程执行完毕，则子线程可能也会没执行完就终止 共享变量共享变量: 当多个线程同时访问一个相同变量时，会产生共享变量问题,即会产生冲突 解决变量锁(Lock)锁: 是一个标志，表示一个线程在占用一些资源 使用方法 上锁 可以放心使用共享资源 取消锁，释放锁 12345678import threadinglock = threading.Lock()# 上锁，申请锁lock.acquire()# 使用结束后，释放锁lock.release() 线程安全问题概念: 如果一个资源/变量，对于多线程来说，不用加锁也不会引起任何问题，则称为线程安全 类型 线程安全变量： queue 线程不安全变量： list 、 set 、 dict 生产者消费问题 一个模型，可以用来搭建消息队列 queue: 一个用来存放变量的数据结构，特点为先进先出，内部元素排队，可以理解为一个特殊的list 方法 queue.Queue() : 生成队列的实例 queue.qsize() : 计算队列的长度 queue.push() : 将数据放入队列中 queue.get() : 从queue中取出一个值 12345# python2from Queue import Queue# python3import queue 123456789101112131415161718import threadingimport time# 直接继承Thread方法class Producer(threading.Thread) def run(self): global queue count = 0 while True: # qsize计算队列的长度 if queue.qsize() &lt; 1000 for i in range(100): count = count + 1 msg = "生产产品" + str(count) # 将数据放入队列中 queue.put(msg) print(msg) time.sleep(0.5) 12345678910class Consumer(threading.Thread) def run(self): global queue while True: if queue.qsize() &gt; 100 for i in range(3): # get是从queue中取出一个值 msg = self.name + "消费了" + queue.get() print(msg) time.sleep(1) 解释: 对于继承Thread,必须重写run(self)函数，run(self)函数为调用Thread时，自动调用的函数 死锁现象解释 集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的 例如，如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1，这样两个线程就发生了死锁现象。 解决 对申请锁的内容设置超时时间 lock.acquire(timeout=2) semaphore 允许一个资源最多由几个多线程同时使用 semaphore = threading.Semaphore(3) : 设置最多3个线程同时使用资源 可重入锁 lock = threading.RLock()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端深似海-HTML]]></title>
    <url>%2F2018%2F06%2F24%2F%E5%89%8D%E7%AB%AF%2FHTML%2F</url>
    <content type="text"><![CDATA[逐步学会HTML URL统一资源定位符 URL URL Uniform Resource Locator URL 格式scheme://host.domain:port/path/filename scheme - 定义因特网服务的类型。最常见的类型是 http host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 w3school.com.cn :port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 URL 编码 URL 只能使用 ASCII 字符集来通过因特网进行发送。 由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。 URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。 URL 不能包含空格。URL 编码通常使用 + 来替换空格。 DTD文档类型定义(Document Type Definition) 一套为了进行程序间的数据交换而建立的关于标记符的语法规则。使用各类文档类型定义是为了让标准通用标记语言、可扩展标记语言文件能符合规定的数据交换标准 DTD : 严格型、过渡型、框架型 严格型：在整个文档中不能出现任何表现形式的标签，如 粗体、斜体等，要用 CSS ! 过渡型 ： 在文档中可以使用表现形式，也可以用CSS! HTML5 DTD&lt;!DOCTYPE html&gt;—## HTML5### HTML5 简介HTML5 的新的文档类型（DOCTYPE）声明：12&lt;!DOCTYPE html&gt;&lt;meta charset="UTF-8"&gt;&gt; 在 HTML5 标准中，能够省略 &lt;html&gt; 标签和 &lt;body&gt; 标签,但是不推荐省略。实例：123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Title of the document&lt;/title&gt;&lt;/head&gt;&gt; 注意 : HTML5中默认字符编码为 UTF-8### meta标签属性 http-equiv - 相当于http的文件头作用，可以向浏览器传回一些有用的信息，以帮助正确和精确的显示网页内容，与之对应的属性值为 content - 实例: Refresh 中的 2表示2秒后刷新页面，URL为刷新后跳转到的页面; X-UA-Compatible 为了兼容 IE浏览器12345&lt;meta http-equiv="content-type" charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7"&gt;&lt;meta http-equiv="Refresh" content="2;URL=https://wwww.baidu.com" &gt; name### 非meta标签 link &amp; script :123&lt;link rel="stylesheet" href="css.css"&gt;&lt;link rel="icon" href="httP://..."&gt;&lt;script src="hello.js"&gt;&lt;/script&gt;解释 : icon 为引入页面的小头像 、 stylesheet 引入外部样式表 、 script 引入 js脚本等—### HTML5 浏览器支持&gt; 所有浏览器，不论新旧，都会自动把未识别元素当做行内元素来处理。&gt; 正因如此，可以使得老式浏览器处理”未知的“ HTML 元素。把 HTML5 元素定义为块级元素HTML5 定义了八个新的语义 HTML 元素。所有都是块级元素。解决方案：把 CSS display 属性设置为 block，以确保老式浏览器中正确的行为：实例：123header, section, footer, aside, nav, main, article, figure &#123; display: block; &#125;Internet Explorer 的问题&gt; 注意：Internet Explorer 8 以及更早的版本，不允许对未知元素添加样式。 解决方案：12345&lt;head&gt;&lt;!--[if lt IE 9]&gt; &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt;以上代码是一段注释，但是 IE9 的早期版本会读取它（并理解它）—## HTML 文档声明&lt;HTML &lt;!DOCTYPE&gt;&lt;!DOCTYPE&gt;声明帮助浏览器正确地显示网页&gt; &lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。&lt;!DOCTYPE html&gt; : HTML5 的声明—### HTML 语义#### HTML5 &lt;section&gt; 元素&lt;section&gt; 元素定义文档中的节。&gt; 根据 W3C 的 HTML 文献：“节（section）是有主题的内容组，通常具有标题”。#### HTML5 &lt;article&gt; 元素&lt;article&gt; 元素规定独立的自包含内容。&gt; 文档有其自身的意义，并且可以独立于网站其他内容进行阅读。&lt;article&gt;元素的应用场景： 论坛 博客 新闻##### HTML5 &lt;header&gt; 元素&lt;header&gt;元素为文档或节规定页眉。&lt;header&gt;元素应该被用作介绍性内容的容器。一个文档中可以有多个&lt;header&gt; 元素。实例：1234567&lt;article&gt; &lt;header&gt; &lt;h1&gt;My Title&lt;/h1&gt; &lt;p&gt;SubTitle&lt;/p&gt; &lt;/header&gt; &lt;p&gt;my description ......&lt;/p&gt;&lt;/article&gt;##### HTML5 &lt;footer&gt;元素&lt;footer&gt;元素为文档或节规定页脚。&lt;footer&gt;元素应该提供有关其包含元素的信息。&gt; 页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。实例：为页脚添加联系邮箱,作者1234&lt;footer&gt; &lt;p&gt;Posted by: Keithxodoy&lt;/p&gt; &lt;p&gt;Contact Email: &lt;a href="mailto:someone@example.com"&gt;someone@example.com&lt;/a&gt;&lt;/p&gt;&lt;/footer&gt;#### HTML5 &lt;nav&gt;元素&lt;nav&gt;元素定义导航链接集合。注意:&lt;nav&gt;元素旨在定义大型的导航链接块。然而，并非文档中所有链接都必须位于 &lt;nav&gt;元素中！实例： 创建个人github的nav导航123&lt;nav&gt; &lt;a href="https://github.com"&gt;Github&lt;/a&gt;&lt;/nav&gt;#### HTML5 &lt;aside&gt;元素&lt;aside&gt;元素页面主内容之外的某些内容，例如侧栏。实例：123456&lt;aside&gt; &lt;ul&gt; &lt;li&gt;导航1&lt;/li&gt; &lt;li&gt;导航2&lt;/li&gt; &lt;/ul&gt;&lt;/aside&gt;&gt; aside 内容应该与周围内容相关连。#### HTML5 &lt;figure&gt;和 &lt;figcaption&gt;元素&gt; 在书籍和报纸中，与图片搭配的标题很常见.figcaption可以在图片下方给予图片相关的解释实例：为图片下方标示1234&lt;figure&gt; &lt;img src="test.png" alt="test_pic"&gt; &lt;figcaption&gt;Detail About Picture &lt;/figcaption&gt;&lt;/figure&gt;—## HTML基础标签 添加水平线 &lt;hr/&gt; 内容居中 align=&quot;center&quot; 换行 &lt;br/&gt; 注释 &lt;!-- --&gt; 背景颜色 bgcolor=&quot;blue&quot; 链接 &lt;a href=&quot;http://&quot; &gt; 图像 &lt;img src=&quot; &quot;&gt;—# 个性化设置## HTML属性 style属性 background-color 属性为元素定义了背景颜色 实例：style=&quot;background-color:red&quot; font-family、color 以及 font-size 属性分别定义元素中文本的字体系列、颜色和字体尺寸 实例：style=&quot;font-family:arial;color:red;font-size:20px;&quot; text-align 属性规定了元素中文本的水平对齐方式 实例：style=&quot;text-align:center&quot; color - 设置字体颜色 ： color: red - 特殊用法 : color: rgb(100,200,500); rgb: red green blue text-decoration - 设置文字修饰 - 例如 text-decoration: underline – 设置下划线 text-decoration: none –不设置任何文字修饰—## HTML 颜色&gt;颜色由红色、绿色、蓝色混合而成。颜色名：大多数的浏览器都支持颜色名集合。提示：仅仅有 16 种颜色名被 W3C 的 HTML4.0 标准所支持。它们是：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow。&gt; 如果需要使用其它的颜色，需要使用十六进制的颜色值。—## HTML中的样式 stylesheet123456&lt;style type="text/css"&gt;h1 &#123;color: red&#125;p &#123;color: blue&#125;body &#123;background-color: red&#125;p &#123;margin-left: 20px&#125;&lt;/style&gt;&gt; 添加到部分的样式信息对 HTML 进行格式化### HTML的内容格式化1234&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;meta http-equiv="Content-Language" content="zh-cn" /&gt;&lt;/head&gt;&gt; 当特殊的样式需要应用到个别元素时，就可以使用内联样式123&lt;p style="color: red; margin-left: 20px"&gt;This is a paragraph&lt;/p&gt;### 使用样式属性做一个没有下划线的链接1&lt;a href="/example/html/lastpage.html" style="text-decoration:none"&gt; 自定义下划线链接text-decoration: underline &lt;link&gt; 标签链接到一个外部样式表12&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="/html/css"/&gt;### 设置HTML的aside侧栏的边距1234aside ul &#123; list-style: none; padding-left: 0;&#125;例子12345678910111213141516&lt;div class="wrap"&gt; &lt;h1&gt;mytest&lt;/h1&gt; &lt;p&gt;The cat was fast.&lt;/p&gt; &lt;div class="content"&gt; &lt;h2&gt;content&lt;/h2&gt; &lt;p&gt;paragraph&lt;/p&gt; &lt;/div&gt; &lt;aside&gt; &lt;h2&gt;mysidebar&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;about&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/aside&gt;&lt;/div&gt;1234.wrap &#123; width: 600px; margin: auto;&#125;注意： 为显示aside的侧边效果，首先要对aside所在的div中，设置div的属性 为使得页面更好的附和浏览器，可以设置宽度，高度为百分比，如width: 80%### 设置样式元素的展示方式dispaly| code | function || — | ——– || display : inline | 将样式元素在一条线上显示 || display : block | 将样式元素块显示 |拓展 :hover :hover 选择器鼠标指针在其上浮动的链接设置样式。 hover 选择器可用于 所有元素 ，不只是链接。例：12345li a:hover&#123; text-decoration: underline color: #666; font-size: 60px;&#125; :link 选择器设置指向未被访问页面的链接的样式 :visited 选择器用于设置指向已被访问的页面的链接 :active 选择器用于活动链接。注释：在 CSS 定义中，:hover 必须位于 :link 和 :visited 之后（如果存在的话），这样样式才能生效。——## HTML文本实例化### 基础&lt;b&gt; 粗体 &lt;strong&gt; 字体加强&lt;big&gt; 字体变大 &lt;em&gt; 字体强调&lt;i&gt; 意大利斜体 &lt;small&gt; 字体减小&lt;sub&gt; 字体下放 &lt;sup&gt;字体上放&lt;del&gt; 删除字 &lt;ins&gt; 下划线### 拓展 &lt;pre&gt;&gt; 预格式文本，可以很好的显示计算机代码，可以对空行和空格进行控制。 &lt;code&gt; &lt;var&gt;&gt; 常用于显示计算机/编程代码,变量 &lt;kbd&gt;&gt; 定义键盘代码 &lt;tt&gt;&gt; 定义打字机代码 &lt;font color=&quot;&quot;&gt;&gt; 设置字体颜色 &lt;address&gt;&gt; 可以在 HTML 文件中写地址 &lt;acronym title=&quot;World Wide Web&quot;&gt;WWW&lt;/acronym&gt; &lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;&gt; 可以将 title 里的内容缩写为自己定义的形式&gt; 并且首字母缩写 &lt;bdo dir=&quot;rtl&quot;&gt;&gt; 可以将 中的内容倒序输出 &lt;cite&gt;&gt; 定义引用、引证 &lt;dfn&gt;&gt; 定义一个定义项目 &lt;blockquote&gt;&gt; 可以进行文本的长引用 &lt;q&gt;&gt; 可以进行文本的短引用 使用 blockquote 元素的话，浏览器会插入换行和外边距 而 q 元素不会有任何特殊的呈现。### HTML字符实体#### HTML实体&gt;在 HTML 中，某些字符是预留的。&gt;在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。&gt;如果希望正确地显示预留字符，必须在 HTML 源代码中使用字符实体（character entities）实例123&amp;entity_name; &amp;#entity_number;&lt;!--如需显示小于号，我们必须这样写：--&gt;&amp;lt; &amp;#60;字符实体表格| 显示结果| 描述| 实体名称| 实体编号||———| —–| ——-|———-|| | 空格| &amp;nbsp;| &amp;#160;|| &lt; | 小于号 |&amp;lt; | &amp;#60;|| &gt; | 大于号| &amp;gt;| &amp;#62;|| &amp; | 和号 | &amp;amp;| &amp;#38;|| “ | 引号 |&amp;quot;| |&amp;#34; ||’ |撇号 |&amp;apos; (IE不支持)| &amp;#39;|| ￠ |分（cent） |&amp;cent; |&amp;#162;|| £| 镑（pound）| &amp;pound; |&amp;#163;||¥ | 元（yen） |&amp;yen;|&amp;#165;|| €| 欧元（euro）| &amp;euro; |&amp;#8364;|| §| 小节 | &amp;sect;| &amp;#167;|| ©| 版权（copyright）| &amp;copy;| &amp;#169;||® |注册商标 | &amp;reg; |&amp;#174;||™ |商标 | &amp;trade;| &amp;#8482;||× |乘号 | &amp;times; |&amp;#215;||÷ |除号 |&amp;divide; | &amp;#247;|—#### 不间断空格(non-breaking space)&gt;HTML 中的常用字符实体是不间断空格(&amp;nbsp;)。&gt;浏览器总是会截短 HTML 页面中的空格。—## HTML链接实例### 3种基本方式 &lt;a href=&quot;/index.html&quot;&gt;一个指向本网站中的一个页面的链接 &lt;a href=&quot;http://www.microsoft.com/&quot;&gt;一个指向另一个页面的链接 &lt;a href=&quot; &quot;&gt;&lt;img src=&quot; &quot;/&gt;&lt;/a&gt;将图像用来作链接 &lt;a href=&quot;mailto:someone@microsoft.com?subject=Hello%20again&quot;&gt;发送邮件&lt;/a&gt;使用邮件链接，其中应该使用 ==%20== 来代替单词之间的空格也可以在链接后面传值，即可以添加邮件的内容&amp;subject=Summer%20Party &amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!### 超链接标签的属性 target=&quot;_blank&quot;链接将在新窗口中打开，默认属性是在本窗口打开新网页 &lt;a href=&quot;#C4&quot;&gt;链接将直接跳转至本页面的某个指定位置### 空连接1. &lt;a href=&quot;#&quot;&gt;空链接&lt;/a&gt; : 不推荐使用,会在链接后面添加一个#2. &lt;a href=&quot;javascript:void(0)&quot;&gt;空链接&lt;/a&gt; : 使用 javascript### 图像 定义背景图像&lt;body background=&quot;/i/eg_background.jpg&quot;&gt; 定义图像地图map 替换文本属性（==Alt==）&gt; alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。&lt;img src=&quot;boat.gif&quot; alt=&quot;Big Boat&quot;&gt;&gt;浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息,如图 排列图像位置通过改变&lt;img&gt;的align属性 bottom middle top 实例 ：&lt;img src=&quot;/i/eg_cute.gif&quot; align=&quot;bottom&quot;&gt; 浮动文本 ：align=&quot;left&quot; align=&quot;right&quot; 调整图像尺寸 ： width=&quot;200&quot; height=&quot;200&quot; 为图像添加链接属性 实例 ： 123&lt;a href="/example/html/lastpage.html"&gt;&lt;img border="0" src="/i/eg_buttonnext.gif" /&gt;&lt;/a&gt;### 命名锚的语法：&lt;a name=&quot;label&quot;&gt;锚（显示在页面上的文本）&lt;/a&gt;提示 锚的名称可以是任何你喜欢的名字。 您可以使用 id 属性来替代 name 属性，命名锚同样有效。 id适合对特定需求的进行锚定 class适合对一个组进行整体锚定实例1234567891011121314&lt;!--首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：--&gt;&lt;a name="tips"&gt;基本的注意事项 - 有用的提示&lt;/a&gt;&lt;!--然后，我们在同一个文档中创建指向该锚的链接：--&gt;&lt;a href="#tips"&gt;有用的提示&lt;/a&gt;&lt;!--您也可以在其他页面中创建指向该锚的链接：--&gt;&lt;a href="http://www.w3school.com.cn/html/html_links.asp#tips"&gt;有用的提示&lt;/a&gt;&lt;!--在上面的代码中，我们将 # 符号和锚名称添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。--&gt;12345&lt;a name="top"&gt;&lt;/a&gt;&lt;p&gt; 内容&lt;/p&gt;&lt;a href="#top"&gt;回到顶部&lt;/a&gt;实现回到顶部1. 直接添加 # ,瞬间回到顶部1234&lt;body&gt; &lt;p&gt;内容&lt;/p&gt; &lt;a href="#"&gt;回到顶部&lt;/a&gt;&lt;/body&gt;—## HTML背景1. 背景颜色（Bgcolor）&gt; 背景颜色属性将背景设置为某种颜色。属性值可以是十六进制数、RGB 值或颜色名。123&lt;body bgcolor="#000000"&gt;&lt;body bgcolor="rgb(0,0,0)"&gt;&lt;body bgcolor="black"&gt;2. 背景（Background）背景属性将背景设置为图像。 属性值可以为图像的URL，可可以是相对路径* gif 和 jpg 文件均可用作 HTML 背景1&lt;body background="clouds.gif"&gt;注意： 如果图像尺寸小于浏览器窗口，那么图像将在整个浏览器窗口进行复制。 使用背景图片应考虑是否增加了页面的加载速度，大小不应超过10kb 背景图片应与页面的各种元素搭配，如文字等 背景图片不应太华丽，可能会导致主次不分 HTML 列表 –可嵌套 种类 &lt;ul&gt; 无序列表 &lt;li&gt; 扩展 添加type属性 type =&quot;disc/circle/square&quot; &lt;ol&gt; 有序列表 1. 2. 扩展 添加type属性 type =&quot;a/A/I/i&quot; &lt;dl&gt; 自定义列表 &lt;dt&gt; : 项目的定义 definiton term &lt;dd&gt; : 自定义列表项的内容 definition detail 更多方法样式style中的技巧 li:nth-child(3){ color: red; } : 将每个li列表中的第3个的字体颜色修改为红色 注意： 此修改为对全体列表的第3个进行操作，若需要单独操作，可在代码前加上ul:first-of-type HTML块&amp;内联元素使用&lt;style&gt;定制样式12345678&lt;style&gt;.cities&#123; background-color:balck; color:white; margin:20px; padding:20px;&#125;&lt;/style&gt; 解释 .cites : 设置cities类的样式 margin : 设置页外边距 auto ： 设置页面左右间距相同 padding ： 设置页内边距 块级元素 –在前后显示折行block level element 块级 &lt;h1&gt; &lt;p&gt; &lt;ur&gt; &lt;table&gt; &lt;div&gt; : 如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性 HTML&lt;div&gt;: 是块级元素。它能够用作其他 HTML 元素的容器。 设置 &lt;div&gt; 元素的类，使我们能够为相同的&lt;div&gt; 元素设置相同的类： 12345678&lt;div class="cities"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt; div属性 min-width ： 设置最小页面宽度 注意： 为防止出现div标签中出现背景颜色的空白，可使用footer文档来解决另一方案：overflow: hidden#### footer定义和用法&lt;footer&gt; 标签定义文档或节的页脚。&lt;footer&gt; 元素应当含有其包含元素的信息。&gt;页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。&gt;您可以在一个文档中使用多个 &lt;footer&gt; 元素。 footer样式属性 clean: both; : 可以去除div中的背景空隙解释—### 内联元素 –通常不以新行开始inline element 内联元素 &lt;b&gt; &lt;td&gt; &lt;a&gt; &lt;img&gt; &lt;span&gt; :当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性HTML &lt;span&gt;: 是行内元素，能够用作文本的容器。 设置 &lt;span&gt; 元素的类，能够为相同的 &lt;span&gt; 元素设置相同的样式。123456789101112&lt;style&gt;span.red &#123; color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的&lt;span class="red"&gt;重要的&lt;/span&gt;标题&lt;/h1&gt;&lt;/body&gt;—## HTML表格 HTML | 用途—| —&lt;thead&gt;|表格的页眉，可以对表格内容分类&lt;tbody&gt; | 定义表格的主体内容 &lt;tfoot&gt;|定义表格的页脚，可统计数据 每个表格由 table 标签开始。 每个表格行由 tr 标签开始，thead标签必须有tr标签 每个表格数据由 td 标签开始。 实例1234567891011&lt;!--两行两列表格--&gt;&lt;table border="1"&gt;&lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;400&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表格的背景颜色与图像 设置整个表格12345&lt;table border="1"bgcolor="red"&gt;&lt;table border="1"background=""&gt; 设置个别格子12345&lt;table&gt;&lt;tr&gt; &lt;td bgcolor="1"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表格和边框属性 border=&quot;&quot; 如果不定义边框属性，表格将不显示边框。有时这很有用，但是大多数时候，我们希望显示边框。 表格的标题 &lt;caption&gt;我的标题&lt;/caption&gt; &lt;caption&gt;&lt;h2&gt;标题&lt;/h2&gt;&lt;/caption&gt; 自动为表格生成 tbody标签 表格的表头 表格的表头使用 &lt;th&gt; 标签进行定义。 大多数浏览器会把表头显示为粗体居中的文本 实例12345&lt;table border="1"&gt;&lt;tr&gt; &lt;th&gt;这是表头&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;注意: 为了避免空的单元格的边框没有被显示出来。这种情况，在空单元格中添加一个空格占位符，就可以将边框显示出来。 &lt;td&gt;&amp;nbsp;&lt;/td&gt; 空格由和号开始 (“&amp;”)，然后是字符”nbsp”，并以分号结尾(“;”) 设置跨越多行或多列的表格 &lt;th colspan=&quot;2&quot;&gt; &lt;th rowspan=&quot;2&quot;&gt; 设置单元格内文字的位置 &lt;td align=&quot;left&quot;&gt; FIFT &lt;/td&gt; 表格内也可以设置标签 实例123456789101112131415161718192021222324252627282930&lt;table border="1"&gt;&lt;tr&gt; &lt;td&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另一个段落。&lt;/p&gt; &lt;/td&gt; &lt;td&gt;这个单元包含一个表格： &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;B&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;C&lt;/td&gt; &lt;td&gt;D&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;这个单元包含一个列表： &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;菠萝&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;td&gt;HELLO&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 创建单元格内容与其边框之间的空白 cellpadding 增加单元格之间的距离。 cellspacing1234567891011121314&lt;table border="1" cellpadding="10"&gt;&lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt; &lt;table border="1" cellspacing="10"&gt;&lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;—## HTML5的网站布局HTML5 提供的新语义元素来定义网页的不同部分：### HTML5布局语义元素| HTML5 | 语义元素 ||——-| ——–|| header | 定义文档或节的页眉|| nav | 定义导航链接的容器|| section | 定义文档中的节 ||article | 定义独立的自包含文章|| aside | 定义内容之外的内容（比如侧栏）|| footer | 定义文档或节的页脚|| details | 定义额外的细节|| summary | 定义 details 元素的标题|### 例子 可以直接配合样式定义块123456789101112&lt;style&gt;#header &#123; background-color:black; color:white; text-align:center; padding:5px;&#125;&lt;/style&gt;&lt;div id="header"&gt;&lt;h1&gt;City Gallery&lt;/h1&gt;&lt;/div&gt; 可以直接使用布局标签123456789101112&lt;style&gt; header &#123; background-color:black; color:white; text-align:center; padding:5px; &#125;&lt;/style&gt;&lt;header&gt;&lt;h1&gt;City Gallery&lt;/h1&gt;&lt;/header&gt;#### 注意事项 &lt;table&gt; 元素不是作为布局工具而设计的。 &lt;table&gt;元素的作用是显示表格化的数据。—## HTML 表单### 账号信息12345678&lt;form action="HTML_submit" method="get" &gt; &lt;label for="name"&gt;Enter your name&lt;/label&gt; &lt;input type="text" id="name" name="name" /&gt; &lt;textarea name="" id="" cols="30" rows="10"&gt; 这是文本输入框，可以输入内容 &lt;/textarea&gt; &lt;input type="submit"/&gt;&lt;/form&gt;解释 设置GET可以在URL中显示传值内容test.html?name=陈俊杰&amp;comment=这是测试&gt; 其中name、comment 均为id属性的内容#### &lt;form&gt; 标签##### autocomplete 属性&gt;autocomplete 属性规定表单或输入字段是否应该自动完成。&gt; 当自动完成开启，浏览器会基于用户之前的输入值自动填写值。提示：可以把表单的 autocomplete 设置为 on，同时把特定的输入字段设置为 off示例 ： 表单信息自动填写，而E-mail信息特定输入123456&lt;form action="action_page.php" autocomplete="on"&gt; First name:&lt;input type="text" name="fname"&gt;&lt;br&gt; Last name: &lt;input type="text" name="lname"&gt;&lt;br&gt; E-mail: &lt;input type="email" name="email" autocomplete="off"&gt;&lt;br&gt; &lt;input type="submit"&gt;&lt;/form&gt;##### novalidate 属性&gt;novalidate 属性属于 &lt;form&gt; 属性。&gt;如果设置，则 novalidate 规定在提交表单时不对表单数据进行验证。示例：指示表单在被提交时不进行验证：1234&lt;form action="action_page.php" novalidate&gt; E-mail: &lt;input type="email" name="user_email"&gt; &lt;input type="submit"&gt;&lt;/form&gt;—#### label : 标签 设置输入信息 属性 + for : 将label与input连接起来，可点击label直接选中输入框—#### input 属性 input ： 输入框，可以根据不同的type类型，变化为多种形态 - 类型type： - text : 文本输入 - submit : 提交框 - value : 设置文本值 - name : 规定 input 元素的名称 - reset : 重置输入框 - hidden ： 隐藏密码显示 - password : 字符密码会被掩码处理，定义密码字段 - image : 以图像作为提交图形 - file : 用户进行选择本地文件的操作补充 input 属性 readonly 属性 ：规定输入字段为只读（不能修改）,readonly 属性不需要值。它等同于 readonly=”readonly”。示例：设置固定只读的用户名1234&lt;form &gt; username:&lt;br&gt; &lt;input type="text" name="username" value="Keithxodoy" readonly&gt;&lt;/form&gt; disabled 属性 :规定输入字段是禁用的,被禁用的元素是不可用和不可点击的1234&lt;form &gt; username:&lt;br&gt; &lt;input type="text" name="username" value="Keithxodoy" disabled&gt;&lt;/form&gt; autofocus 属性:是布尔属性。如果设置，则规定当页面加载时 &lt;input&gt;元素应该自动获得焦点。示例：使 “First name” 输入字段在页面加载时自动获得焦点，即鼠标自动点击输入框1First name:&lt;input type="text" name="fname" autofocus&gt; height 和 width 属性&gt;height 和 width 属性规定 &lt;input&gt; 元素的高度和宽度。&gt;height 和 width 属性仅用于 &lt;input type=&quot;image&quot;&gt;,且需要始终规定图像的尺寸123&lt;form&gt; &lt;input type="image" src="/i.jpg" alt="Submit" width="128" height="128"/&gt;&lt;/form&gt; multiple 属性&gt;multiple 属性是布尔属性。&gt;如果设置，则规定允许用户在 &lt;input&gt; 元素中输入一个以上的值。multiple 属性适用于以下输入类型：email 和 file。示例： 选择本地图片上传1234&lt;form action="/example/html5/demo_form.asp" method="get"&gt;选择图片：&lt;input type="file" name="img" multiple="multiple" /&gt;&lt;input type="submit" /&gt;&lt;/form&gt; step 属性&gt; step 属性规定 &lt;input&gt; 元素的合法数字间隔。示例：如果 step=”3”，则合法数字应该是 -3、0、3、6、等等。提示：step 属性可与 max 以及 min 属性一同使用，来创建合法值的范围。 required 属性&gt; required 属性是布尔属性。&gt; 如果设置，则规定在提交表单之前必须填写输入字段。示例： 用户必须输入名称1234&lt;form action="/example/html5/demo_form.asp" method="get"&gt; Name: &lt;input type="text" name="Username" required="required" /&gt; &lt;input type="submit" value="submit"&gt;&lt;form&gt; 输入字段长度的一些属性| 属性值 | 作用 | 注意事项 ||——|—–| ——–|| size 属性 |规定输入字段的尺寸| || maxlength 属性|规定输入字段允许的最大长度| 该属性不会提供任何反馈。如果需要提醒用户，则必须编写 JavaScript 代码|—### 设置账户密码12&lt;input type="text" name="username"&gt;&lt;input type="password" name="psw"&gt;### select : 设置下拉列表 option元素设置待选择的选项 可以通过添加selected属性来定义预定义选项 - 例子：&lt;option value=&quot;BWM&quot; selected&gt;BWM&lt;/option&gt;示例：12345&lt;select name="cars"&gt;&lt;option value="volvo"&gt;Volvo&lt;/option&gt;&lt;option value="fiat"&gt;Fiat&lt;/option&gt;&lt;option value="audi"&gt;Audi&lt;/option&gt;&lt;/select&gt; textarea : 文本输入区域 + 可以输入文本 + rows cols 设置输入框的长宽 (同时也可以使用CSS来设置) button ： 设置可点击的按钮 + 示例：&lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;Hello World&#39;)&quot;&gt;Button&lt;/button&gt; + 解释： onclick=&quot;alert(&#39;&#39;)&quot;:设置点击完后,显示的文本内容优化123456789101112&lt;form action="" method="get"&gt; &lt;p&gt; &lt;label for="name"&gt;Enter Your Name&lt;/label&gt; &lt;input type="text" id="name" name="name" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="comment"&gt;You Comment &lt;/label&gt; &lt;textarea id="comment" name="comment"&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="go" /&gt;&lt;/p&gt;&lt;/form&gt;12345678910111213&lt;form action="" method="get"&gt; &lt;ul&gt; &lt;li&gt; &lt;label for="name"&gt;Enter Your Name&lt;/label&gt; &lt;input type="text" id="name" name="name" /&gt; &lt;/li&gt; &lt;li&gt; &lt;label for="comment"&gt;You Comment &lt;/label&gt; &lt;textarea id="comment" name="comment" rows="10" cols="10"&gt;&lt;/textarea&gt; &lt;/li&gt; &lt;li&gt;&lt;input type="submit" value="go" /&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/form&gt;123456789101112form ul &#123; list-style: none; margin-bottom: 20px; padding-left: 0px;&#125;label &#123; display: block; cursor: pointer; color: #292929; font-family: sans-serif; padding-bottom: 8px;&#125;注释： 只有设置了 name 属性的表单元素才能在提交表单时传递它们的值。 name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据。 for - name - id 搭配使用 cursor 属性规定要显示的光标的类型（形状）。 cursor: pointer 光标呈现为指示链接的指针（一只手）### 复选框123&lt;label for="css"&gt;Do You Like Css&lt;/label&gt;&lt;input type="checkbox" name="css" id="css" /&gt;&lt;input type="radio" name="css" id="css"/&gt;复选框类型 checkbox ： 方形复选框允许用户在有限数量的选项中选择零个或多个选项 radio ： 圆形,只能进行单选实例：12345&lt;form &gt; &lt;input type="checkbox" name="country" value="China"&gt;China &lt;br&gt; &lt;input type="checkbox" name="country" value="USA"&gt;USA&lt;/form&gt;12345&lt;form&gt;&lt;input type="radio" name="sex" value="male" checked="checked"&gt;Male&lt;br&gt;&lt;input type="radio" name="sex" value="female"&gt;Female&lt;/form&gt;效果：也可以设置多个复选框123456789&lt;input type="radio" name="css" id="css"/&gt;HTML&lt;input type="radio" name="css" id="css"/&gt;CSS&lt;input type="radio" name="css" id="css"/&gt;PYTOHN&lt;!--这类复选框一旦选中，就不能取消--&gt;&lt;input type="radio" /&gt;HTML&lt;input type="radio"/&gt;CSS&lt;input type="radio" /&gt;PYTOHN—上下拉动的复选框&gt; 首选进行上下框的选择范例12345&lt;select&gt;&lt;option&gt;Apples&lt;option selected&gt;Bananas&lt;option&gt;Cherries&lt;/select&gt;—数字类型的复选框&lt;input type=&quot;number&quot;&gt;:用于应该包含数字值的输入字段示例：设置数字限制在1-5的字段123&lt;form&gt; &lt;input type="number" name="quanlity" min="1" max="5"&gt;&lt;/form&gt;其他输入限制1. required : 规定输入字段是必需的（必需填写）2. maxlength : 规定输入字段的最大字符数。3. disabled : 规定输入字段应该被禁用。—设置日期的输入字段&lt;input type=&quot;date&quot;&gt;:根据浏览器支持，日期选择器出现输入字段123&lt;form&gt; &lt;input type="date" name="bday"&gt;&lt;/form&gt;同时也可以为输入添加限制：1234&lt;form&gt; 输入一个日期大于2000年1月2号 &lt;input type="date" name="bday" min="2000-01-02"&gt;&lt;/form&gt;注释:Firefox 或者 Internet Explorer 11 以及更早版本不支持 type=”date”—设置输入包含颜色的输入字段&lt;input type=&quot;color&quot;&gt; : 根据浏览器支持，可以在输入字段中出现颜色选择器示例： 在输入框中出现颜色选择器12345&lt;form&gt; 可选择喜欢的颜色 &lt;input type="color" name="favcolor" value="#ff0000"&gt; &lt;input type="submit"&gt;&lt;/form&gt;注释: Internet Explorer 不支持 type=”color”—其余类型| 输入类型 | 用处 ||———|——|| type=”range”|输入字段可以显示滑块控件|| type=”month”| 输入日期选择器|| type=”week”| 输入用户选择周和年|| type=”time”| 输入用户选择时间|| type=”datetime”| 输入用户选择日期和时间|| type=”email”| 输入包含电子邮件地址的字段|| type=”search”| 用于搜索字段（搜索表现类似的常规文本字段）|—### 上传表单#### Action 属性&gt; action 属性定义在提交表单时执行的动作,表示提交表单数据至表单处理程序的按钮。&gt;&gt;向服务器提交表单的通常做法是使用提交按钮。&gt;通常，表单会被提交到 web 服务器上的网页。实例：&lt;form action=&quot;action_page.php&quot;&gt; :指定了某个服务器脚本来处理被提交表单注意如果省略 action 属性，则 action 会被设置为当前页面。#### Method 属性&gt;method 属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）：实例： get&gt;get常见于搜索引擎，适合少量数据提交，一般浏览器会设定容量限制，不含敏感信息&lt;form action=&quot;action_page.php&quot; method=&quot;GET&quot;&gt; post&gt;post适合更新数据，包含敏感信息（例如密码），post安全性更高，因为页面提交的数据不会在页面地址栏显示&lt;form action=&quot;action_page.php&quot; method=&quot;POST&quot;&gt;#### Name 属性如果要正确地被提交，每个输入字段必须设置一个 name 属性。例如：&lt;input type=&quot;text&quot; value=&quot;info&quot;&gt;因为不含name属性而无法正常提交正确做法： &lt;input type=&quot;text&quot; name=&quot;information&quot; value=&quot;info&quot; &gt;#### 用 &lt;fieldset&gt; 组合表单数据实例：123456789101112&lt;form action="action_page.php"&gt;&lt;fieldset&gt;&lt;legend&gt;Personal information:&lt;/legend&gt;name:&lt;br&gt;&lt;input type="text" name="name" value="Your name"&gt;&lt;br&gt;password:&lt;br&gt;&lt;input type="text" name="pwd" value="Your pwd"&gt;&lt;br&gt;&lt;br&gt;&lt;input type="submit" value="Submit"&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;fieldset&gt; 元素组合表单中的相关数据&lt;legend&gt; 元素为 &lt;fieldset&gt; 元素定义标题。#### &lt;datalist&gt;元素设置预定义选项列表&gt;用户在输入数据时可以看到预定义选项的下拉列表示例：12345678910&lt;form action="action_page.php"&gt;&lt;input list="browsers"&gt;&lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt;&lt;/datalist&gt; &lt;/form&gt;注意事项1. Safari 或者 IE9及之前版本不支持datalist标签2. input 元素的list属性必须引用 datalist 元素的 id属性—## HTML 脚本### 解释与基本语法&gt; JavaScript 使 HTML 页面具有更强的动态和交互性。。 语法 基本语法 ： &lt;script type=&quot;text/javascript&quot;&gt; 对于不支持Javascript的浏览器 ： &lt;noscript&gt;&lt;/noscript&gt; 解释 &lt;script&gt;标签用于定义客户端脚本，可以包含脚本语言，也可以通过src属性指向外部脚本文件 只有在浏览器不支持脚本或者禁用脚本时，才会显示 noscript 元素中的内容范例123&lt;script type="text/javascript"&gt;document.write("Hello World!")&lt;/script&gt;注意如何应付老式的浏览器&gt;如果浏览器无法识别 &lt;script&gt;标签，那么&lt;script&gt;标签所包含的内容将以文本方式显示在页面上。 解决办法：将脚本隐藏在注释标签当中。 解释： 对于无法识别 &lt;script&gt; 标签的浏览器将忽略这些注释，所以不会将标签的内容显示到页面上。而那些新的浏览器将读懂这些脚本并执行它们，即使代码被嵌套在注释标签内。范例12345&lt;script type="text/javascript"&gt;&lt;!--document.write("Hello World!")//--&gt;&lt;/script&gt;### 弹出框&gt; alert()为弹出框(js)123&lt;script&gt; alert()&lt;/script&gt;—## HTML头部元素头部基础信息123&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;meta http-equiv="Content-Language" content="zh-cn" /&gt;&lt;title&gt;定义标题&lt;/title&gt;### &lt;head&gt;元素&gt;标签都可以添加到 head 部分：&lt;title&gt;、&lt;base&gt;、&lt;link&gt;、&lt;meta&gt;、&lt;script&gt; 以及 &lt;style&gt;### meta属性&gt; 元数据metadata提供数据的信息，元数据不会显示在页面上，但是机器是可读的&gt; meta属性标识了创作者和编辑软件、文档和它的关键词&gt; meta属性始终位于 head 元素中12345678910111213141516&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;meta name="author"content="地址内容"&gt;&lt;meta name="revised"content="Keithxodoy,10/7/18"&gt;&lt;meta name="generator"content="Sublime"&gt;&lt;meta name="description"content="HTML examples"&gt;&lt;meta name="keywords"content="HTML, DHTML, CSS, XHTML, JAVAScript, VBScript"&gt; 重新定向新地址12345678910111213&lt;head&gt;&lt;meta http-equiv="Refresh" content="5;url=网页地址" /&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;URL 是 &lt;a href="http://www.地址.com"&gt;http://www.地址.com&lt;/a&gt;&lt;/p&gt;&lt;p&gt;您将在 5 秒内被重定向到新的地址。&lt;/p&gt;&lt;p&gt;如果超过 5 秒后您仍然看到本消息，请点击上面的链接。&lt;/p&gt;&lt;/body&gt;解释 针对搜索引擎的定义页面的描述： &lt;meta name=&quot;description&quot; content=&quot;HTML examples&quot;&gt; 针对搜索引擎的定义页面的关键词：&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML&quot; /&gt;—### base标签 使用 base标签使页面中的所有标签在新窗口中打开123&lt;head&gt;&lt;base target="_blank" /&gt;&lt;/head&gt;* 使用base标签使得页面上的所有链接规定默认地址123&lt;head&gt; &lt;base href="http://" /&gt;&lt;/head&gt;### style元素123456&lt;head&gt; &lt;style type="text/css"&gt; body &#123;background-color: yellow&#125; p &#123;color: blue&#125; &lt;/style&gt;&lt;/head&gt;—## HTML 框架### 框架理解框架通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。 使用框架的坏处： 开发人员必须同时跟踪更多的HTML文档 很难打印整张页面 框架相关标签 frameset 标签也被某些文章和书籍译为框架集 框架结构标签（&lt;frameset&gt;） 定义如何将窗口分割为框架 注意不能将 &lt;body&gt;&lt;/body&gt; 标签与 &lt;frameset&gt;&lt;/frameset&gt; 标签同时使用！ 框架标签（frame） Frame 标签定义了放置在每个框架中的 HTML 文档,一个窗口应该用一个 frame 标签表示， frame 标签不能分割，只能表示小窗口 frame标签属性 scrolling=&quot;no&quot;: 规定是否在框架中显示滚动条 src=&quot;文件地址&quot; ： 设定框架的内容 实例：将一个框架内容导入另一个框架，将menu.html内容导入至main.html内 12345&lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;&lt;a href="info.html" target="main"&gt;需要导入的文档&lt;/a&gt;&lt;/li&gt; &lt;li&gt;管理&lt;/li&gt;&lt;/ul&gt; 1234&lt;frame src="menu.html" name="menu" /&gt;&lt;frameset&gt; &lt;frame src="main.html" name="main" /&gt;&lt;/frameset&gt; 问题对于页面的index.html文件，若向main框架内导入index.html，则会导致框架内嵌重复框架解决12345&lt;ul&gt; &lt;li&gt;&lt;a href="index.html" target="_top"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="info.html" target="main"&gt;需要导入的文档&lt;/a&gt;&lt;/li&gt; &lt;li&gt;管理&lt;/li&gt;&lt;/ul&gt;#### 注意为了避免框架有可见边框,用户可以拖动边框来改变它的大小在 &lt;frame&gt; 标签中加入：noresize=&quot;noresize&quot;实例123&lt;frameset cols="50%,*,25%"&gt; &lt;frame src="/example/html/frame_a.html" noresize="noresize" /&gt;&lt;/frameset&gt;&gt;noresize 也可以在 frameset中使用，则整个框架集都不能拖动### 框架类型#### 垂直框架1234&lt;frameset cols="25%,50%,25%"&gt; &lt;frame src="/example/html/frame_a.html"&gt; &lt;frame src="/example/html/frame_b.html"&gt; &lt;frame src="/example/html/frame_c.html"&gt;#### 水平框架1234&lt;frameset rows="25%,50%,25%"&gt; &lt;frame src="/example/html/frame_a.html"&gt; &lt;frame src="/example/html/frame_b.html"&gt; &lt;frame src="/example/html/frame_c.html"&gt;#### noframes框架noframes 元素可为那些不支持框架的浏览器显示文本。noframes 元素位于 frameset 元素内部。重要事项：如果您希望 frameset 添加 &lt;noframes&gt; 标签，就必须把其中的文本包装在&lt;body&gt;&lt;/body&gt;标签中！实例12345678910&lt;frameset cols="25%,50%,25%"&gt; &lt;frame src="/example/html/frame_a.html"&gt; &lt;frame src="/example/html/frame_b.html"&gt; &lt;frame src="/example/html/frame_c.html"&gt;&lt;noframes&gt;&lt;body&gt;您的浏览器无法处理框架！&lt;/body&gt;&lt;/noframes&gt;&lt;/frameset&gt;#### 混合框架实例12345678910&lt;frameset rows="50%,50%"&gt;&lt;frame src="/example/html/frame_a.html"&gt;&lt;frameset cols="25%,75%"&gt;&lt;frame src="/example/html/frame_b.html"&gt;&lt;frame src="/example/html/frame_c.html"&gt;&lt;/frameset&gt;&lt;/frameset&gt;#### 导航框架实例导航框架包含一个将第二个框架作为目标的链接列表。123456&lt;frameset cols="120,*"&gt; &lt;frame src="/example/html/html_contents.html"&gt; &lt;frame src="/example/html/frame_a.html" name="showframe"&gt;&lt;/frameset&gt;#### 内联框架（HTML 页中的框架） 应用 ： iframe 用于在网页内显示网页 语法 ： &lt;iframe src=&quot;URL&gt;&lt;/frame&gt; 其中URL指向隔离页面的位置 拓展属性 1. height=&quot;200&quot; width=&quot;200 : 定义iframe的高度与宽度，默认单位为像素 2. frameborder=&quot;0 : 用于规定是否显示iframe周围的边框，为”0”即可移除边框实例1&lt;iframe src="/html/index.asp" height="300px" width="99%" style="margin-top:15px;"&gt;&lt;/iframe&gt; 使用 iframe 作为链接的目标iframe 可用作链接的目标（target）。链接的 target 属性必须引用 iframe 的 name 属性实例12&lt;iframe src="demo_iframe.html" name="iframe_a"&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href="http://www.w3school.com.cn" target="iframe_a"&gt;w3school&lt;/a&gt;&lt;/p&gt;解释使用 iframe 的 name 属性，与 a 的 target 关联，使其指向a中的超链接#### 表格中的框架 分别设置 上 ， 下 ，上下 ，两侧 的表格框线1234567891011&lt;table frame="above"&gt;&lt;tableframe="below"&gt;&lt;tableframe="hsides"&gt;&lt;table frame="vsides"&gt;### 框架属性 noresize=&quot;noresize&quot;添加该属性后，框架是不可调整尺寸的 设置指向另一个文件内指定的节的链接 &lt;frame src=&quot;/example/html/link.html#C6&quot;&gt; 使用框架导航跳转至指定的节123456&lt;frameset cols="180,*"&gt;&lt;frame src="/example/html/content.html"&gt;&lt;frame src="/example/html/link.html" name="showframe"&gt;&lt;/frameset&gt; target=&quot;_top&quot; ：跳出被锁定的框架—## 高级用法–HTML5图像### 使用JS的图像绘制标签： &lt;canvas&gt;&gt; 画布是一个矩形区域，您可以通过JS来控制其每一像素。实例： 创建Canvas元素,通过JS来绘制12345678&lt;canvas id="Canvas_test" width="200" height="100"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt; var c=document.getElementById("Canvas_test"); var cxt=c.getContext("2d"); cxt.fillStyle-"#F00"; cxt.fillRect(0,0,150,75);&lt;/script&gt;解释： JS通过ID来寻找canvas元素 getContext(&quot;2d&quot;)对象为内建的HTML5对象，有许多绘制图像的方法 fillStyle、fillRect用来绘制一个红色的矩形，其中fillStyle用来染色，fillRect用来规定形状、位置和尺寸* fillRect 方法拥有参数 (0,0,150,75),意思是：在画布上绘制 150x75 的矩形，从左上角开始 (2,0)。—#### 示例示例一： 绘制直线12345678&lt;script type="text/javascript"&gt; var c=document.getElementById("Canvas"); var cxt=c.getContext("2d"); cxt.moveTo(10,10); cxt.lineTo(150,50); cxt.lineTo(10,50); cxt.stroke();&lt;/script&gt;元素: moveTo():移动至起点 lineTo():画线段至线段另一端 stroke():结束线段 示例二：绘制一个红色圆形123456789&lt;script type="text/javascript"&gt; var c=document.getElementById("canvas"); var cxt=c.getContext("2d"); cxt.fillStyle="#F00"; cxt.beginPath(); cxt.arc(70,18,15,0*Math.PI,1.5*Math.PI,true); cxt.closePath(); cxt.fill();&lt;/script&gt; 语法:context.arc(x,y,r,sangle,eangle,counterclockwise)解释: arc()方法用来创建弧/曲线(圆形或部分圆) 圆的中心：arc(70,18,15,0,1.5*Math.PI,true) 圆的起始角：arc(70,18,15,0,1.5*Math.PI) 圆的结束角：arc(70,18,15,0,1.5*Math.PI,true) stroke()或fill()方法在画布上绘制实际的弧 true:该属性是判断弧线的旋转方向，即counterclockwise 绘制二次贝塞尔曲线 二次贝塞尔曲线需要两个点。第一个点是用于二次贝塞尔计算中的控制点，第二个点是曲线的结束点 123456var c=document.getElementById("myCanvas");var ctx=c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.quadraticCurveTo(20,100,200,20);ctx.stroke(); 开始点： moveTo(20,20) 控制点： quadraticCurveTo(20,100,200,20) 结束点： quadraticCurveTo(20,100,200,20) 绘制三次贝塞尔曲线 三次贝塞尔曲线需要三个点。前两个点是用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点 123456var c=document.getElementById("myCanvas");var ctx=c.getContext("2d");ctx.beginPath();ctx.moveTo(20,20);ctx.bezierCurveTo(20,100,200,100,200,20);ctx.stroke(); 开始点： moveTo(20,20) 控制点 1： bezierCurveTo(20,100,200,100,201,20) 控制点 2： bezierCurveTo(20,100,200,100,200,20) 结束点： bezierCurveTo(20,100,200,100,200,20) 示例三：绘制渐变背景 123456789&lt;script type="text/javascript"&gt; var c=document.getElementById("canvas"); var cxt=c.getContext("2d"); var grd=cxt.createLinearGradient(0,0,175,50); grd.addColorStop(0,"#F00"); grd.addColorStop(1,"#0F0"); cxt.fillStyle=grd; cxt.fillRect(0,0,175,50);&lt;/script&gt; 解释: 渐变可以填充在矩形, 圆形, 线条, 文本等等, 各种形状可以自己定义不同的颜色。 一、有两种不同的方式来设置Canvas渐变： createLinearGradient(x,y,x1,y1) - 创建线条渐变 createRadialGradient(x,y,r,x1,y1,r1) - 创建一个径向/圆渐变 二、addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1. 使用渐变，设置fillStyle或strokeStyle的值为 渐变，然后绘制形状，如矩形，文本，或一条线。 示例四：绘制文本 canvas 绘制文本，重要的属性和方法如下： font- 定义字体 fillText(text,x,y) - 在 canvas 上绘制实心的文本 strokeText(text,x,y) - 在 canvas 上绘制空心的文本 1234var c=document.getElementById("myCanvas");var ctx=c.getContext("2d");ctx.font="30px Arial";ctx.strokeText("Hello World",10,50); 示例五： 添加画布图像 12345var c=document.getElementById("canvas");var cxt=c.getContext("2d");var img=new Image();img.src="test.png";cxt.drawImage(img,0,0); 解释 drawImage(image,x,y):把一幅图像放置到画布上 img=new Image();:创建一个图像对象 img.src=&quot;test.png&quot;;:插入所需要的图片 路径对象 路径方法 描述 fill() 填充当前绘图（路径）。 stroke() 绘制已定义的路径。 beginPath() 起始一条路径，或重置当前路径。 moveTo() 把路径移动到画布中的指定点，不创建线条。 closePath() 创建从当前点回到起始点的路径。 使用SVG的图像绘制标签：&lt;svg&gt; 什么是SVG、SVG的优势一、 SVG SVG是指可伸缩矢量图形(Scalable Vector Graphics) SVG用于定义用于网络的基于矢量的图形 SVG图像在改变尺寸时不会损失图形质量 SVG使用XML格式定义图形 SVG是W3C的标准 二、 SVG的优势 SVG图像可以通过文本编辑器进行创建和修改 SVG图像可以被搜索、索引、脚本化或者压缩 SVG具有可伸缩性 SVG图像可以在任何分辨率下高质量地打印 IE9、Firefox、Opera、Safari支持内联SVG SVG与Canvas对比SVG SVG 是一种使用 XML 描述 2D 图形的语言。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 特点 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 Canvas Canvas 通过 JavaScript 来绘制 2D 图形。Canvas 是逐像素进行渲染的。 在 Canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。(如果其位置发生变化，那么整个场景也需要重新绘制) 特点 依赖分辨率 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 高级用法–HTML5媒介元素概述多媒体元素的不同扩展名的文件格式：.swf、.wmv、.mp3、.mp4 视频格式 文件 描述 AVI .avi AVI (Audio Video Interleave) 格式是由微软开发的。所有运行 Windows 的计算机都支持 AVI 格式。它是因特网上很常见的格式，但非 Windows 计算机并不总是能够播放。 WMV .wmv Windows Media 格式是由微软开发的。Windows Media 在因特网上很常见，但是如果未安装额外的（免费）组件，就无法播放 Windows Media 电影。一些后期的 Windows Media 电影在所有非 Windows 计算机上都无法播放，因为没有合适的播放器。 MPEG .mpg .mpeg MPEG (Moving Pictures Expert Group) 格式是因特网上最流行的格式。它是跨平台的，得到了所有最流行的浏览器的支持。 QuickTime .mov QuickTime 格式是由苹果公司开发的。QuickTime 是因特网上常见的格式，但是 QuickTime 电影不能在没有安装额外的（免费）组件的 Windows 计算机上播放。 RealVideo .rm .ram RealVideo 格式是由 Real Media 针对因特网开发的。该格式允许低带宽条件下（在线视频、网络电视）的视频流。由于是低带宽优先的，质量常会降低。 Flash .swf .flv Flash (Shockwave) 格式是由 Macromedia 开发的。Shockwave 格式需要额外的组件来播放。但是该组件会预装到 Firefox 或 IE 之类的浏览器上。 Mpeg-4 .mp4 Mpeg-4 (with H.264 video compression) 是一种针对因特网的新格式。事实上，YouTube 推荐使用 MP4。YouTube 接收多种格式，然后全部转换为 .flv 或 .mp4 以供分发。越来越多的视频发布者转到 MP4，将其作为 Flash 播放器和 HTML5 的因特网共享格式。 声音格式 文件 描述 MIDI .mid .midi MIDI (Musical Instrument Digital Interface) 是一种针对电子音乐设备（比如合成器和声卡）的格式。MIDI 文件不含有声音，但包含可被电子产品（比如声卡）播放的数字音乐指令。因为 MIDI 格式仅包含指令，所以MIDI文件极其小巧。MIDI得到了广泛的平台上的大量软件的支持。大多数流行的网络浏览器都支持 MIDI。 RealAudio .rm .ram RealAudio 格式是由 Real Media 针对因特网开发的。该格式也支持视频。该格式允许低带宽条件下的音频流（在线音乐、网络音乐）。由于是低带宽优先的，质量常会降低。 Wave .wav Wave (waveform) 格式是由 IBM 和微软开发的。所有运行 Windows 的计算机和所有网络浏览器（除了 Google Chrome）都支持它。 WMA .wma WMA 格式 (Windows Media Audio)，质量优于 MP3，兼容大多数播放器，除了 iPod。WMA 文件可作为连续的数据流来传输，这使它对于网络电台或在线音乐很实用。 MP3 .mp3 .mpga MP3 文件实际上是 MPEG 文件的声音部分。MPEG 格式最初是由运动图像专家组开发的。MP3 是其中最受欢迎的针对音乐的声音格式。期待未来的软件系统都支持它。 使用哪种格式？ WAVE 是因特网上最受欢迎的无压缩声音格式，所有流行的浏览器都支持它。如果您需要未经压缩的声音（音乐或演讲），那么您应该使用 WAVE 格式。 MP3 是最新的压缩录制音乐格式。MP3 这个术语已经成为数字音乐的代名词。如果您的网址从事录制音乐，那么 MP3 是一个选项。 参考w3cschool HTML5视频 标签 描述 &lt;embed&gt; 定义外部应用程序的容器（比如插件）。 &lt;source&gt; 定义 &lt;video&gt; 和 &lt;audio&gt; 的来源。 &lt;track&gt; 定义 &lt;video&gt;和 &lt;audio&gt; 的轨道。 &lt;video&gt; 定义视频或影片内容。 HTML5音频 标签 描述 &lt;audio&gt; 定义声音或音乐内容。 使用&lt;embed&gt;元素: &lt;embed&gt;标签定义外部（非 HTML）内容的容器。 示例：使用embed插入mp3文件 1&lt;embed src="TEST.mp3" /&gt; 注意： 不同的浏览器对音频格式的支持也不同。 如果浏览器不支持该文件格式，没有插件的话就无法播放该音频。 如果用户的计算机未安装插件，无法播放音频。 使用 &lt;!DOCTYPE html&gt; (HTML5)解决验证问题。 使用&lt;object&gt; 元素 &lt;object tag&gt;标签也可以定义外部（非 HTML）内容的容器。 实例:显示嵌入网页中的 MP3 文件：1&lt;object height="100" width="100" data="song.mp3"&gt;&lt;/object&gt; 使用 HTML5 &lt;audio&gt; 元素&lt;audio&gt; 元素是一个 HTML5 元素，在 HTML 4 中是非法的，但在所有浏览器中都有效。 实例:12345&lt;audio controls="controls"&gt; &lt;source src="song.mp3" type="audio/mp3" /&gt; &lt;source src="song.ogg" type="audio/ogg" /&gt;Your browser does not support this audio format.&lt;/audio&gt; 注意： 使用了一个 mp3 文件，这样它在 Internet Explorer、Chrome 以及 Safari 中是有效的。 为了使这段音频在 Firefox 和 Opera 中同样有效，添加了一个 ogg 类型的文件。如果失败，会显示错误消息。 最好的 HTML音频插入解决方法 使用’多层保险’ 实例：12345&lt;audio controls="controls" height="100" width="100"&gt; &lt;source src="song.mp3" type="audio/mp3" /&gt; &lt;source src="song.ogg" type="audio/ogg" /&gt;&lt;embed height="100" width="100" src="song.mp3" /&gt;&lt;/audio&gt; 使用了两个不同的音频格式。HTML5 &lt;audio&gt;元素会尝试以 mp3 或 ogg 来播放音频。如果失败，代码将回退尝试 &lt;embed&gt; 元素。 最简便的媒体播放方法之一 雅虎媒体播放器:实例1234&lt;a href="song.mp3"&gt;Play Sound&lt;/a&gt;&lt;script type="text/javascript" src="http://mediaplayer.yahoo.com/js"&gt;&lt;/script&gt; 注意：使用雅虎播放器是免费的。如需使用它，您需要把这段 JavaScript 插入网页底部：&lt;script type=&quot;text/javascript&quot; src=&quot;http://mediaplayer.yahoo.com/js&quot;&gt;&lt;/script&gt;HTML视频&gt; 最好的 HTML 解决方法:HTML 5 + &lt;object&gt; + &lt;embed&gt;12345678&lt;video width="320" height="240" controls="controls"&gt; &lt;source src="movie.mp4" type="video/mp4" /&gt; &lt;source src="movie.ogg" type="video/ogg" /&gt; &lt;source src="movie.webm" type="video/webm" /&gt; &lt;object data="movie.mp4" width="320" height="240"&gt; &lt;embed src="movie.swf" width="320" height="240" /&gt; &lt;/object&gt;&lt;/video&gt;—## HTML响应式WEB设计### 概念 什么是响应式 Web 设计？RWD 指的是响应式 Web 设计（Responsive Web Design） RWD 能够以可变尺寸传递网页 RWD 对于平板和移动设备是必需的### 创建方法1. 手工搭建，设置样式2. 使用现成的 CSS 框架使用 Bootstrap&gt;Bootstrap 是最流行的开发响应式 web 的 HTML, CSS, 和 JS 框架。&gt;Bootstrap 帮助您开发在任何尺寸都外观出众的站点：显示器、笔记本电脑、平板电脑或手机—## XHTML### 基础XHTML : EXtensible HyperText Markup Language疑问：1. XHTML 中有哪些不同的 DTD ？Strict, Transitional, Frameset （其中Transitional最常用）诞生原因&gt;由于互联网存在一些不同的浏览器技术。其中一些在计算机上运行，而另一些可能在移动电话或其他小型设备上运行。小型设备往往缺乏解释“糟糕”的标记语言的资源和能力。所以 - 通过结合 XML 和 HTML 的长处，开发出了 XHTML，即XHTML 是作为 XML 被重新设计的 HTML。### 由 HTML –&gt; XHTML步骤：1. 向每张页面的第一行添加 XHTML &lt;!DOCTYPE&gt;2. 向每张页面的 html 元素添加 xmlns 属性3. 把所有元素名改为小写4. 关闭所有空元素5. 把所有属性名改为小写6. 为所有属性值加引号须知：HTML 会被 XHTML 取代。### XHTML 的注意事项文档结构 XHTML DOCTYPE 是强制性的 &lt;html&gt; 中的 XML namespace属性是强制性的 &lt;html&gt;、&lt;head&gt;、&lt;title&gt; 以及 &lt;body&gt; 也是强制性的元素语法 XHTML 元素必须正确嵌套,而在 HTML 中，某些元素可以不正确地彼此嵌套在一起 XHTML 元素必须始终关闭 XHTML 元素必须小写 XHTML 文档必须有一个根元素属性语法 XHTML 属性必须使用小写 XHTML 属性值必须用引号包围 XHTML 属性最小化也是禁止的语法：1. XHTML 中不允许简写属性—## HTML API### HTML 拖放Drop 和 Drag 都是很常见的特性，拖放式HTML5标准的组成部分，任何元素都似乎可拖放的。分步骤实行#### 一、将元素设置为可拖放将元素的draggable属性设置为true:1&lt;img draggable="true" /&gt;#### 二、设置拖放的内容两个重要的属性和方法： ondragstart 和 setData() 当规定的元素被拖动时发生的事情，ondragstart属性调用一个drag(event)函数，规定拖动什么数据 dataTransfer.setData()方法设置被拖动数据的数据类型和值1234function drag(ev)&#123; ev.dataTransfer.setData("text", ev.target.id);&#125;代码中，text为本例中的数据类型，而值为可拖动元素的id(“ “)#### 三、规定元素被拖动到何处ondragover 实践规定被拖动数据能够被放置在何处然而，默认地，数据/元素都无法被放置到其他元素中，为实现拖放，需要阻止元素的这种默认的处理方式。使用ondragover事件的event.preventDefault()方法实现123function allowDrop(ev)&#123; ev.preventDefault();&#125;#### 四、进行放置当放开被拖数据时，就会发生ondrop事件ondrop属性调用一个函数drop(event)12345function drop(ev)&#123; ev.preventDefault(); var data = ev.dataTransfer.getData("text"); ev.target.appendChild(document.getElementById(data);&#125;代码解释： 调用 preventDefault() 来阻止数据的浏览器默认处理方式（drop 事件的默认行为是以链接形式打开） 通过 dataTransfer.getData()方法获得被拖的数据。该方法将返回在 setData()方法中设置为相同类型的任何数据 被拖数据是被拖元素的 id (“drag1”) ev.target.appendChild(document.getElementById(data))把被拖元素追加到放置元素中 对元素操作都需要添加ev.target.#### 示例：在两个div中来回拖放元素1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;style type="text/css"&gt;#div1, #div2&#123;float:left; width:198px; height:66px; margin:10px;padding:10px;border:1px solid #aaaaaa;&#125;&lt;/style&gt;&lt;script type="text/javascript"&gt;function allowDrop(ev)&#123;ev.preventDefault();&#125;function drag(ev)&#123;ev.dataTransfer.setData("Text",ev.target.id);&#125;function drop(ev)&#123;ev.preventDefault();var data=ev.dataTransfer.getData("Text"); //先获取元素内容ev.target.appendChild(document.getElementById(data)); //向元素被拖放的位置追加元素&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)"&gt; &lt;img src="/i/eg_dragdrop_w3school.gif" draggable="true" ondragstart="drag(event)" id="drag1" /&gt;&lt;/div&gt;&lt;div id="div2" ondrop="drop(event)" ondragover="allowDrop(event)"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;使用到的方法 ev.target.appendChild() ev.dataTransfer.setData() ev.dataTransfer.getData() ev.target.id注意 每个JS脚本中的函数都需要带好参数 ev 在body内的标签中调用的js函数都需要带入参数 event 在所需要拖放的元素所处标签需要有唯一的id Web Server个人服务器网站搭建 使用因特网服务提供商(ISP) 优点 连接速度快，拥有连接因特网的高速连接 硬件强大，最好查看 ISP 是否提供高效的负载平衡，以及必要的备份服务器 安全性、可靠性高 选择 ISP 的注意事项 24小时支持服务(免费电话服务等) 确保 ISP 执行每日备份的工作 ISP 的流量限制，避免因为网站访问人数激增而引起预料外的支付费用 ISP 的带宽与内容限制，确保可以发布图片或视频、音频等 ISP 支持所需的 e-mail 功能 ISP 确保可以支持个人所需访问的数据库 FAQ HTML 的框架是什么? —见HTML框架 如何解决使用div时，设置背景出现空白间隙？ —见块级元素的div]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶]]></title>
    <url>%2F2018%2F06%2F24%2FPython%2FPython_Advanced%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程 原则写代码要遵循==开发封闭==原则，虽然这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即： 封闭：已实现的功能代码块 开放：对扩展开发 内容装饰器12345678910def w1(func): def inner(): # 验证1 # 验证2 # 验证3 return func() return inner@w1 # 相当于执行了 w1(f1())def f1(): print('f1') 当写完这段代码后（函数未被执行、未被执行、未被执行），python解释器就会从上到下解释代码，步骤如下：12def w1(func): ==&gt;将w1函数加载到内存@w1 没错，从表面上看解释器仅仅会解释这两句代码，因为函数在没有被调用之前其内部代码不会被执行。 从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章 @函数名 : 是python的一种语法糖。 如上例 @w1内部会执行以下操作: 执行w1函数，并将 @w1 下面的 函数 作为 w1 函数的参数即：@w1 等价于 w1(f1)。 所以，内部就会去执行：1234567891011121314151617def inner: #验证 return f1() # func是参数，此时 func 等于 f1return inner # 返回的 inner，inner代表的是函数，非执行函数# 其实就是将原来的 f1 函数塞进另外一个函数中。# 将执行完的 w1 函数返回值赋值给@w1下面的函数的函数名# w1函数的返回值是： def inner: #验证 return 原来f1() # 此处的 f1 表示原来的f1函数# 然后，将此返回值再重新赋值给 f1，即：new_f1 = def inner: #验证 return 原来f1() 如此一来， 即执行了验证的功能，又执行了原来 f 函数的内容，并将原 f1 函数返回值, 返回给业务调用着。 参数传递12345678910111213141516171819202122232425 # 一个参数：def w1(func): def inner(arg): # 验证1 # 验证2 # 验证3 return func(arg) return inner@w1def f1(arg): print('f1')# 两个参数：def w1(func): def inner(arg1,arg2): # 验证1 # 验证2 # 验证3 return func(arg1,arg2) return inner@w1def f1(arg1,arg2): print('f1') 问题: 装饰具有处理n个参数的函数的装饰器？12345678910def w1(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return inner@w1def f1(arg1,arg2,arg3): print('f1') 问题：一个函数可以被多个装饰器装饰吗？123456789101112131415161718def w1(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return innerdef w2(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return inner@w1@w2def f1(arg1,arg2,arg3): print('f1') Lambda函数（匿名函数） 函数 ： 最大程度地复用代码 存在问题：若函数很小，很短，则会造成啰嗦，不方便阅读代码 lambda表达式 一个表达式，函数体相对简单 用法 以lambda开头 紧跟一定的参数 参数后面用冒号和表达式主题分开 只是一个表达式，没有return 实例 stm = lambda x: 100 * x stm(89) ==&gt;8900 高阶函数 定义 ： 把函数作为参数使用的函数 注意 函数名称就是一个变量，即函数可以作为参数 举例12345def funA(n): return n * 100def funB(n): return funA(n) * 3 map函数 对队列里的每个元素进行操作，即映射操作 map函数是系统提供的具有映射功能的函数，返回值是一个迭代对象,类型为map类 注意：若用列表生成式得到的结果为空 格式： map(func, *iterables) 12345678910111213141516# map举例# 列表里的每个元素都乘以10l1 = [ i for i in range(10)]print(l1)for i in li: l2.append(i*10)# 利用map来实现def multen(n): return n*10l2 = map(multen, l1 ) # multen函数作为map函数的一个参数for x in l2: print(l2) reduce函数 作用： 归并，缩减 ，把可迭代对象最后归并为一个结果 作为参数的函数要求： 必须有两个参数 必须有返回结果 理解 ：reduce([1,2,3]) == f(f(f(1),2),3) 即函数嵌套 注意： reduce需要导入functools包 1234567891011from functools import reduce# 定义一个操作函数# 加入操作函数来相加def add(x,y): return x + y## 对列表[1,2,3]执行add的reduce操作rst = reduce(add, [1,2,3])print(rst) filter 函数 过滤函数：对一组数据进行过滤，符合条件的数据会产生一个新的列表返回 与map函数比较 相同 ： 都对列表的每个元素逐一进行操作 不同 ： map 会生成一个跟原来数据相对应的新队列 filter 不一定，只有符合条件的才会进入新队列 filter函数写法 利用给定函数进行判断 返回值为一个布尔值 调用格式 ： filter(f,data) f 为过滤函数 data 为数据 12345678910# 案例 过滤偶数数据形成新列表def isEven(a): return a%2 ==0list = [3,4,56,3,455,67,4,4]rst = filter(isEven, l)print([i for i in rst]) 注意事项 返回的filter内容是一个可迭代对象,需要逐个输出 排序 把一个序列按照给定算法进行排序 key : 在排序前，对每一个元素进行 key 函数运算，可理解为按照 key 函数定义的逻辑进行排序 (key函数为排序函数的内嵌参数) python2 python3 的差别较大 12345678910111213141516# 排序案例1a = [21,5,7,456,45,66]al = sorted(a, reverse=True)print (al)# 排序案例2a = [4.-45.457.74.7.5]# 按照数据的绝对值进行排序 # abs 为求绝对值的函数al = sorted(a, key=abs, reverse=True)print (al)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
