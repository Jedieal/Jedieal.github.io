<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python_Spider_xpath]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2Fxpath%26lxml%2F</url>
    <content type="text"><![CDATA[xpath 和 lxml xpath 一门从html中提取数据的语言 xpath语法 xpath helper插件：帮助我们从elements中定位数据 / ：表示从根节点开始 选择节点(标签) // ：表示从任意节点开始 @ ：定位具体元素的位置 例如：//div[@class=&#39;feed-infinite-wrapper&#39;]/ur/li,表示为选择@class=’feed-infinite-wrapper’的div下的ur下的li。 另外，a/@href:选择a的href的值 获取文本 a/text()：获取a下的文本 a//text():获取a下的所有文本 5.当前 ./a表示当前节点下的a lxml 安装 pip install lxml 使用123456from lxml import etree#接收HTML字符串response = requests.get(url).content.decode("utf-8")element = etree.HTML("html字符串")#xpath提取数据element.xpath("") 以下代码中，a, b, c是什么参数？ 1.&gt;&gt;&gt; “{a} love {b}.{c}”.format(a=”I”, b=”FishC”, c=”com”) 2.’I love FishC.com’关键字参数 3. 以下代码中，{0}, {1}, {2}是什么参数？ 1.&gt;&gt;&gt; “{0} love {1}.{2}”.format(“I”, “FishC”, “com”) 2.’I love FishC.com’ 位置参数 4. 如果想要显示Pi = 3.14，format前边的字符串应该怎么填写呢？ ‘{0}{1:.2f}’.format(‘Pi = ‘, 3.1415) 写爬虫的结论 1.url 知道url地址的规律和总页码数：构造url地址的列表 start_url (url地址有规律) 2.发送请求，获取响应 requests 3.提取数据 返回json字符串：json模块 返回html字符串：lxml模块配合xpath模块 4.保存]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Basic_Distinguish]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%90%86%E8%AE%BA%2F%E6%A6%82%E5%BF%B5%E8%BE%A8%E5%88%AB%2F</url>
    <content type="text"><![CDATA[当一个类实例被创建时，__init__()方法会自动执行目的为执行一些对象的必要的初始化工作 123def __init__(self, name, symbol): self.name = name self.symbol = symbol 我们通过实现init()方法来初始化对象。当一个对象被创建，Python首先创建一个空对象并为该新对象调用__init__()方法。这个方法函数通常用来创建对象的实例变量并执行任何其他一次性处理。 注意： __init__只能返回None对象,不能返回任何实例化返回值 在其他面向对象编程中通常使用 this 12345class MyClass(object):def __new__(cls, *args, **kwargs): ...# 实例化myclass = MyClass(*args, **kwargs) 第一个参数cls是当前正在实例化的类。如果要得到当前类的实例，应当在当前类中的new()方法语句中调用当前类的父类 的new()方法。 例如，如果当前类是直接继承自object，那当前类的new()方法返回的对象应该为：123def __new__(cls, *args, **kwargs): ... return object.__new__(cls) _new_()与_init_()的区别 _new_作用于_init_之前。前者可以决定是否调用后者，或者说可以决定调用哪的init方法。Python 中的 _new_ 方法负责创建一个实例对象，_init_ 方法负责将该实例对象进行初始化 2.__init__是在类实例创建之后调用，而__new__方法正是创建这个类实例的方法,__new__产生的实例也就是__init__里面的self __new__(cls[,...}) class 参数会原封不动地传给init]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_terms]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%90%86%E8%AE%BA%2Fdefinition-py%2F</url>
    <content type="text"><![CDATA[1.多态：可以对不同类的对象使用相同的操作 2.headers=headers :反爬措施，防止浏览器以为是机器在工作 3.对象的状态由它的特性（比如名称）来描述 4.所有的对象都属于某一个类，称为类的实例 5.self参数用于对象自身的引用，实例化对象将自己作为第一个参 数传入函数中，例如 若 foo为Person的实例，则foo.greet()可以看作Person.greet(foo)的简写]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_terms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7%2FHEXO%2F</url>
    <content type="text"><![CDATA[友情链接主题的配置文件_config.html links 创建博客 source– _posts 命令 ： hexo n 文件名 开启微信公众号订阅 主题设置文档 搜索wechat wechat_subscriber qocde : 微信公众号的二维码图片 description : 相关描述 设置头像旋转在主题的source文件中 sidebar-author.styl文件中修改12345678&#123;border-radius: 50%;transition: 2s all;&#125;.site-author-image: hover&#123; transform: rotate(360deg);&#125; 首页文章设置阅读全文在blog文件需要添加阅读全文的位置加上&lt;!--more--&gt; 利用md修改博客 设置博客的分类与标签 1234567 tags: - xxx - xxx categories: 分类名---# 内容]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_Tools]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2FSpider_00%2F</url>
    <content type="text"><![CDATA[爬虫的分类 1.通用爬虫 2.聚焦网络爬虫 3.增量式网络爬虫 4.深层网络爬虫 了解url(统一资源定位符) 1.url的结构：协议-域名（ip)-端口号-目录-文件名-参数-锚（位置） #Charles抓包工具S]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%8D%9A%E5%AE%A2%E5%B7%A5%E5%85%B7%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[注释：加粗+斜体删除线 为无序排列,也可以使用- 为强调 为高亮文字 使用代码块 ** **粗体文字12345678 &gt;引用 多层嵌套&gt;&gt;#### 插入图片 `![](./01.png '描述')` ![name][01] [01]: ./01.png '描述'#### 插入图片带有链接`[![](./01.png '百度')](http://www.baidu.com)` ```代码框 内容标题 定义型列表注：解释型定义Markdown: 轻量级文本标记语言，可以转换成html，pdf等格式 // 开头一个: + Tab 或 四个空格 脚注Markdown[^1][^1]: Markdown是一种纯文本标记语言（标记内容） 任务列表 选项一 选项二 [选项 表格 a b c 居中 左对齐 右对齐 ========= ============= ============ 自动邮箱链接&#x78;&#120;&#120;&#64;&#x6f;&#117;&#x74;&#108;&#111;&#x6f;&#107;&#x2e;&#99;&#111;&#109; 流程图流程1234567891011121314st=&gt;start: 开始|past:&gt; http://www.baidu.com // 开始e=&gt;end: 结束 // 结束c1=&gt;condition: 条件1:&gt;http://www.baidu.com[_parent] // 判断条件c2=&gt;condition: 条件2 // 判断条件c3=&gt;condition: 条件3 // 判断条件io=&gt;inputoutput: 输出 // 输出//----------------以上为定义参数-------------------------//----------------以下为连接参数-------------------------// 开始-&gt;判断条件1为no-&gt;判断条件2为no-&gt;判断条件3为no-&gt;输出-&gt;结束st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;ec1(no)-&gt;e // 条件1不满足-&gt;结束c2(no)-&gt;e // 条件2不满足-&gt;结束c3(no)-&gt;e // 条件3不满足-&gt;结束 演示 代码详解*流程图分为两个部分：定义参数 然后 连接参数 定义示例：123tag=&gt;type: content:&gt;url // 形参格式st=&gt;start: 开始:&gt;http://www.baidu.com[blank] //实参格式注：** st=&gt;start: 开始 的：后面保持空格** 形参 实参 含义 tag st 标签 (可以自定义) =&gt; =&gt; 赋值 type start 类型 (6种类型) content 开始 描述内容 (可以自定义) :&gt;url http://www.baidu.com[blank] 链接与跳转方式 兼容性很差 123:---: 居中:--- 左对齐---: 右对齐 6种类型 含义 start 启动end 结束operation 程序subroutine 子程序condition 条件inputoutput 输出 连接示例：12st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;e开始-&gt;判断条件1为no-&gt;判断条件2为no-&gt;判断条件3为no-&gt;输出-&gt;结束 形参 实参 含义 -&gt; -&gt; 连接 condition c1 条件(布尔值,方向) (yes,right) 如果满足向右连接，4种方向：right ，left，up ，down 默认为：down 注：operation (程序); subroutine (子程序) ;condition (条件)，都可以在括号里加入连接方向。 123operation(right)subroutine(left)condition(yes,right) // 只有条件 才能加布尔值]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2Fjson%2F</url>
    <content type="text"><![CDATA[认识json 1.全称：JavaScript Object Notation 另称：轻量级的传输文件 2.Json是一个字符串！独立于语言，独立于平台。一种保存数据的格式 作用：可以保存本地的json文件，也可以将json串进行传输 组成：{ } [ ] : , 3.Json使用了JS语法 4.Json用于交换数据 5.Json为纯字符串，字符串强制为双引号，Json的key只能为字符串 1234import jsonjson.loads() #将json转化为字典response.json()json.dumps() #将字典转化为json 1234567#读取本地的json文件path = r"C/dizhi/jsonfile.json"with open(path,"rb") as f: #用load不用loads data = json.load(f) #返回字典 print (data) 12345678#写本地jsonpath = r"C/lujing/test.json"jsondata = &#123;" ":" "," ":" "&#125;with open(path , "w") as f: json.dump(jsondata,f) 1234# 写入文件with open ('c.txt','a',encoding = 'utf-8') as f: # 将文件的格式转换为中文，ensure_ascii=False f.write(json.dumps(content, ensure_ascii=False))]]></content>
      <categories>
        <category>Data_struction</category>
      </categories>
      <tags>
        <tag>data_struction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Web_Django]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython_Web%2FDjango%2F</url>
    <content type="text"><![CDATA[Python_Web 知识内容创建项目，并了解项目目录结构选好安置目录项目位置后，打开cmd，输入 `Django-admin` 输入 `Django-admin Startproject myblog` Dir查看目录，有无myblog项目 目录层级说明manage.py 一个命令行工具，可以让我们用多种方式对Django项目进行交互init.py 一个空文件，它告诉Python这个目录应该被看做一个包settings.py 项目的配置文件（主要处理文件）urls.py 项目的url声明 （主要处理文件）wsgi.py 项目与WSGI兼容的Web服务器入口 配置数据库Django默认使用SQLite数据库在settings.py文件中通过DATABASES选项进行数据库配置 配置MySQLPython3.x中安装的是PyMySQL在__init__.py文件中写入两行代码12import pymysqlpymysql.install_as_MySQLdb() myAPP目录说明 admin.py 进行站点配置 models.py 创建模型 views.py 创建视图 创建应用 在一个项目中可以创建多个应用，每个应用进行一种业务处理 打开CMD,进入project(目录激活应用 在settings.py文件中，将myApp应用加入到INSTALLED_APPS选项中)123456789INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'myApp',] 定义模型 概述：有一个数据表就对应有一个模型 在models.py文件中定义模型 引入：from django.db import models模型类要继承models.Model类12345678910class Grades(models.Model): gname = models.CharField(max_length=20) # 字符串类型 gdate = models.DateTimeField() # 时间类型 ggirlnum = models.IntegerField() # 整型类型 gboynum = models.IntegerField() isDelete = models.BooleanField(default=False) # 布尔值类型# 在布尔值类型中可以添加默认属性default=False# 关联外键 models.ForeignKey("Grades")#说明：需要定义主键，在生成时自动添加，并且值为自动增加 在数据库中生成数据表 生成迁移文件执行 python manage.py makemigrations 在migrations目录下生成一个迁移文件，此时数据库中还没有生成数据表 执行迁移执行 python manage.py migrate相当于执行MySQL语句创建了数据表 测试数据操作 进入到python shell 执行 python manage.py shell 引入包123from myApp.models import Grades, Studentsfrom django.utils import timezonefrom datetime import * 查询所有数据 类名.objects.all() 示例： Grades.objects.all() 添加数据 本质：创建一个模型类的对象实例 示例：CMD窗口下123456grade1 = Grades()grade1.gname = "python04"grade1.gdate = datetime(year=2017, month=7, day=17)grade1.ggirlnum = 3grade1.gboynum = 70grade1.save() 查看某个对象 类名.objects(pk=索引号) 示例： 12Grades.objects.get(pk=2) # 查找单个对象,pk=2 --查找第二个Grades.objects.all() 修改某个数据 模型对象属性 = 新值 示例： 12grade2.gboynum = 60grade2.save() # 保存修改至数据库 删除数据 模型对象.delete() grade2.delete()注意：这是物理删除，数据库中的相应数据被永久删除 关联对象 示例： 1234567stu = Students()stu.sname = "Xue Yanmei"stu.sgender = Falsestu.sage = 20stu.scontend = "I am Xue Yanmei"stu.sgrade = grade1stu.save() 获得关联对象的集合 需求：猎取python04班级的所有学生 对象名.关联的类名小写_set.all() 示例：grade1.students_set.all() 需求:创建曾志伟，属于python04班级 示例： 123stu3 = grade1.students_set.create(sname=u'Zhen Zhiwei',sgender=True,scontend=u"I am Zhen Zhiwei",sage=45) 注意：这样创建的数据直接被添加到了数据库当中。 传递参数request.GET[&#39;a&#39;] Get看做是在request下的一个数组，而‘a’是一个键，则request.GET[&#39;a&#39;]对于的就是通过Get方式发送的a的值 常用命令 命令 启动命令 python manage.py runserver 端口号 常见问题处理 CSRF问题处理 当用post提交数据的时候，django会去检查是否有一个csrf的随机字符串，如果没有就会报错 当用户访问login页面的时候，会生成一个csrf的随机字符串，，并且cookie中也存放了这个随机字符串，当用户再次提交数据的时候会带着这个随机字符串提交，如果没有这个随机字符串则无法提交成功 from django.views.decorators.csrf import csrf_exempt123@csrf_exemptdef firstPageAdd(request) return render(request,"firstclass_01.html",locals())]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMongodb%2F</url>
    <content type="text"><![CDATA[基本概念 数据库（database） 集合（collection） 文档（document） 数据库和集合在MongoDB中不需要手动创建 当创建文档时，如果文档所在集合或数据库不存在会自动创建数据库和集合 Mongodb的windows服务安装和卸载安装: mongod --dbpath &quot;C:\mongodb\db&quot; --logpath &quot;C:\mongodb\log.txt&quot; --install --serviceName &quot;MongoDB&quot; 卸载: mongod.exe --remove --serviceName &quot;MongoDB&quot; 1、了解MongodbMongoDB数据库中存的是各种各样的JSON(BSON) 2、更换MongoDB的database文件夹mongod --dbpath 文件夹地址 3、运行MongoDB#####命令行下运行 MongoDB 服务器为了从命令提示符下运行 MongoDB 服务器，你必须从 MongoDB 目录的 bin 目录中执行 mongod.exe 文件。C:\mongodb\bin\mongod --dbpath c:\data\db 4、重新设置端口C:\mongodb\bin\mongod 数据库路径 --port 123456 注意: 端口数最大不能超过65535 5、连接MongoDB我们可以在命令窗口中运行 mongo.exe 命令即可连接上 MongoDB，执行如下命令：C:\mongodb\bin\mongo.exe 6、启动MongoDB要启动 MongoDB，请运行 mongod.exe 。 例如，从命令提示符：D:\Program Files\MongoDB\Server\3.4\bin\mongod.exe 注意：如果不使用 –dbpath 指定数据存储的目录， 那么 MongoDB 默认使用的是 C:\data\db目录，所以在启动 MongoDB 数据库之前要确保 C:\data\db 目录已经创建了。 在mongodb\bin下打开命令行模式:（启动服务器）D:\mongodb\bin&gt;mongod 验证Mongdb启动成功在Chrome浏览器下，打开localhost:27017若出现It looks like you are trying to access MongoDB over HTTP on the native driver port. 则登录成功 打开mongo命令行下输入mongo,进入mongo的客户端命令模式 命令 show dbs命令可以显示所有数据库的列表。 show collections 显示数据库中的所有集合 db 命令可以显示当前数据库对象或集合。 use 数据库名命令，可以进入到一个指定的数据库。 可以创建任意数据库 MongoDB 的 CRUD（增删改查）操作增添 db.集合名.insert(doc): 在集合中插入一个文档doc,为**json格式** { ：，： } 若要插入多个doc,则用列表形式 向集合插入文档时，若没有给文档指定_id属性，则数据库会自动为文档添加_id 该属性为文档的唯一标识 可以自己指定_id ,”_id”=” “ 使用循环，插入多条数据1234567891011// 方法1for(var i=1 ; i &lt;200 ; i++)&#123; db.user.insert(&#123;num:i&#125;) //需要调用200次insert方法，效率低&#125;//方法2var arr = [];for(var i=1 ; i&lt;200 ; i++)&#123; arr.push(&#123;num:i&#125;); //将num从1到200添加到数组arr中&#125;db.num.insert(arr) //只需调用一次 insert方法 查找 db.集合名.find(): 查询当前集合中的所有文档 `db.collection.find()` `find()`返回的是数组，若要查询其中某个属性，则要添加索引`[0]` find()用来查询集合中所有符合条件的文档，返回一个数组，可以加索引 增加查询条件 {}：{属性:值} 查询指定属性的文档 MongoDB支持直接通过内嵌文档的属性查询，若要查询内嵌文档，则可以通过.的形式来匹配此时属性名必须使用引号 db.user.find({&quot;hobby.movies&quot;:&quot;hero&quot;}) 更多方法 用处 拓展 findone() 查询符合条件的第一个文档对象 find().count() 统计所有文档的数量 find({num:{$gt:200}}) 查找数字大于200的数据 $gte: &gt;= $lt:&lt; $lte:&lt;= $ne:!= find().limit(10) ==limit()== 可以设置显示数据的上限，即显示10条 find().skip(10).limit(10) ==skip()== 用于跳过指定的数据，该命令可以查询第11-20条数据 其中skip(),limit()顺序可以倒换 finf({$or:[{a:1},{b:2}]}) 查询a属性为1或b属性为2的集合 1234// 查找用户订单，使用用户ID作为索引// 向商品属性中添加用户ID做索引var user_id = db.users.findone(&#123;username:&quot;&quot;&#125;)._id;db.order.find(&#123;user_id:user_id&#125;); 修改 db.collection.update(查询条件，新对象) : 修改文档内容 方法：`updateMany`,`updateOne` 12// 利用update实现updateMany 和 updateOne 的功能db.user.update( &#123;name:&quot;jedieal&quot;&#125;,&#123;$set:&#123; age=28 &#125;&#125;,&#123;multi:true&#125;); 注意：update()默认情况下会使用新对象来替换旧的对象 如果需要修改指定的属性，而不是替换，则需要使用“修改操作符”来完成 $set：可以用来修改，增添文档属性 $unset：可以用来删除文档属性 例子1：db.user.update({name:&quot;jedieal&quot;},{age:28}); ： ==age==会将==name==内容给替换 例子2：db.user.update({name:&quot;jedieal&quot;},{$set:{ age=28 }}); 利用$set，只对age进行修改，还可以用来添加值 删除属性，还是属于修改 修改集合属性的数组内的数据 1 db.user.update({ },{$push :{&quot;hobby.movies&quot;:&quot;hero&quot;}}) 2 db.user.update({ },{$addToSet :{&quot;hobby.movies&quot;:&quot;hero&quot;}}) : 若要加入的元素与数组内有相同的，则不会添加 更多方法 作用 {$inc:{a:2}} 在a的值的基础上加上2 要减少，可以将2变为-2 删除 db.collection.remove() db.collection.deleteOne();,db.collection.deleteMany(; ==remove()== : 可以根据条件来删除文档，传递的条件的方式和==find()== 一样 删除一个 db.collection.remove({ },true); 删除所有文档，清空集合(性能略差) db.collection.remove({}) 清空集合（优化） db.collection.drop() 删除数据库 db.dropDatabase() 一般数据库中的数据都不会删除，所以删除的方法很少用 一般会在数据中添加一个字段，来表示数据是否被删除 db.collection.update({ }，{$setZ:{isDel:0}}) db.collection.find({isDel:0}): 利用==isDel==作为标准，0代表没删除，1 代表删除 NOSQL (Not Only SQL)数据库 数据库的服务器 用于保存数据 mongod 用于启动服务器 数据库的客户端 用于操作数据，对数据进行增删改除 mongo 用于启动客户端]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2FMySQL%2F</url>
    <content type="text"><![CDATA[启动在管理员模式下打开cmd,输入net start mysql 连接数据库mysql -u root -p 输入数据库密码 MySQL命令 code function use database； 使用数据库 show databases ； 查看数据库 create database name ： 创建一个数据库]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine_Learning]]></title>
    <url>%2F2018%2F07%2F25%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%26%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%2FMachineLearning%2F</url>
    <content type="text"><![CDATA[机器学习 基础概念 训练集 :用于训练机器学习算法的数据样本集合 为算法输入大量已分类数据作为算法的训练集 特征（属性） : 通常是训练样本集的列，是独立测量得到的结果，多个特征联系起来在一起共同组成一个训练样本 特征类型 数值型，可以使用十进制数字 目标变量 分类算法中目标变量的类型通常是标称型的，被称为类别 回归算法的类型通常为连续型的 知识表示 检查机器是否已经学会了所分配的任务 监督学习内容：分类 &amp; 回归 目的：进行预测，对目标变量的分类信息进行预测 回归 主要用于预测数值型数据 无监督学习特点：无类别信息，也不会给定目标值 聚类: 将数据集合分成由类似的对象组成的多个类的过程 密度估计: 将寻找描述数据统计值的过程]]></content>
      <categories>
        <category>Machine_Learning</category>
      </categories>
      <tags>
        <tag>Machine_Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Basic]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%90%86%E8%AE%BA%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[继续（换行分隔）: \ Python解释器执行12345#！/usr/bin/python #第一行是特殊注释行，称之为组织行，用来告诉我们GUN/Linux系统应该使用哪个解释器来执行#-*-coding:utf-8-*-#FileName: #Author:#Date: Python风格==Pythonic== PEP PEP7 PEP8 PEP257OOP-Python面向对象 面向对象概述：(ObjectOriented ,OO) OOP思想 几个名词 OO:面向对象 OOA:面向对象的分析 OOD：面向对象的设计 OOI：面向对象的实现 OOP：面向对象的编程 OOA–&gt;OOD–&gt;OOI:面向对象的实现过程 变量运算符 : =/!= 运算符 &gt;（ ）运算符 &gt; not 运算符 &gt; or/and 运算符12345678910#在函数内使用全局变量num = 1def f: global num print(num) num = 200 print (num)#从非空序列中随机选择元素random.choice(sequence) 生成器 generator返回值：返回生成器。1234567891011121314151617181920# 实例# 以下实例展示了 xrange 的使用方法：# 占用内存小&gt;&gt;&gt;xrange(8)xrange(8)# 通过list方法，将生成器xrange内容给生成出来&gt;&gt;&gt; list(xrange(8))[0, 1, 2, 3, 4, 5, 6, 7]&gt;&gt;&gt; range(8) # range 使用[0, 1, 2, 3, 4, 5, 6, 7]&gt;&gt;&gt; xrange(3, 5)xrange(3, 5)&gt;&gt;&gt; list(xrange(3,5))[3, 4]&gt;&gt;&gt; range(3,5) # 使用 range[3, 4]&gt;&gt;&gt; xrange(0,6,2)xrange(0, 6, 2) # 步长为 2&gt;&gt;&gt; list(xrange(0,6,2))[0, 2, 4] yieldyield: 是一个类似 return 的关键字，迭代一次遇到yield时就返回yield后面(右边)的值。在下一次迭代时，从上一次迭代遇到的yield后面的代码开始执行，可以理解为每执行完一次迭代，yield会记住上一次迭代的位置，然后在下一次迭代开始时，从上一次位置的下一位开始，再执行yield后的命令 运用: 在一堆有规律或者有着固定顺序（类似数列）的数据中，需要按照一定规律，将数据分类时，可以使用yield生成器来完成 利用递归生成器处理嵌套问题–树状问题123456789# 解释：当展开元素为单个元素时，会引发TypeError，则只会生成该元素的生成器# 当展开多层元素时，可以分层展开，利用faltten()递归def faltten(nested): try: for sublist in nested: for element in faltten(sublist): yield element except TypeError: yield nested 123456789101112# 利用生成器检查展开对象是否为类似字符串的对象def faltten(nested): try: # 不要迭代类似字符串的对象 try: nested + '' # 通过和字符串的拼接来检查 except TypeError: pass # 对非字符串对象不做处理 else : raise TypeError # 对字符串对象进行报错 for sublist in nested: for element in faltten(sublist): yield element except TypeError: yield nested 匿名函数 – lambda 函数无固定名123sum = lambda a,b:a+bprint(sum(10,20))#变量名 = lambda 参数1，参数2，。。。: 表达式 列表列表方法 引用方法：对象.方法(参数)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495961.append -----在列表末尾追加新的对象&gt;&gt;&gt;lst =[1,2]&gt;&gt;&gt;lst.append(3)&gt;&gt;&gt;lst[1,2,3]2.count -----统计某个元素在列表中出现的次数&gt;&gt;&gt;x =[1,1,1,2,3]&gt;&gt;&gt;x.count(1)33.extend -----用新列表来拓展原有列表&gt;&gt;&gt;a= [1,2]&gt;&gt;&gt;b= [3,4]&gt;&gt;&gt;a.extend(b)&gt;&gt;&gt;a[1,2,3,4]# 该方法与原始的列表连接不同(a+b),该方法返回的是一个全新的列表# 若要添加多个元素，则在括号内用列表例如：x.extend(['a','b'])4.index -----从列表中找出某个值的第一个匹配项的索引位置&gt;&gt;&gt;x =[a,b,c]&gt;&gt;&gt;x.index(c)&gt;&gt;&gt;25.insert -----将对象插入到列表中&gt;&gt;&gt;numbers = [1,2,3,4,5]&gt;&gt;&gt;numbers.insert(3,'four') #（）逗号前 3 为插入的位置，逗号后为插入的内容&gt;&gt;&gt;numbers[1,2,3,'four',4,5]6.pop -----移除列表中的一个元素&gt;&gt;&gt;x= [1,2,3]&gt;&gt;&gt;x.pop() #若括号内为空，则默认移除最后一个元素3 #注意这里pop方法返回了元素值，且pop方法为唯一一个既能修改列表又返回元素值的列表方法&gt;&gt;&gt;x[1,2]# Tip:使用pop方法可以实现一种数据结构——栈。栈的原理如堆放盘子，只能在顶部放一个盘子# 也只能从顶部拿走一个盘子，即后进先出（LIFO)# Python没有入栈的方法，但可以用append代替，。如果入栈刚刚出栈的值，则列表不变7.remove -----用于移除列表中某个值的第一个匹配项&gt;&gt;&gt;x = [1,2,1]&gt;&gt;&gt;x.remove(1)&gt;&gt;&gt;x[2,1] #只移除第一个匹配项8.reverse ----将列表中的元素反向存放&gt;&gt;&gt;x =[1,2,3]&gt;&gt;&gt;x,reverse()&gt;&gt;&gt;x[3,2,1]# Tip:如果需要对一个序列进行反向迭代，使用reversed函数，返回一个迭代器对象9.sort -----将列表中的元素按照一定的顺序排列，无副本，只对原列表直接改变&gt;&gt;&gt;x =[2,3,1]&gt;&gt;&gt;x.sort() #虽然sort方法修改了x却返回了空值&gt;&gt;&gt;x[1,2,3]如果需要副本，可以自建&gt;&gt;&gt;x =[2,1,3]&gt;&gt;&gt;y =x[ : ] #这里【 ： 】相当于strcpy，不能直接 y = x如果使用y=x，则改变x的值，也会同时改变y，因为x为y的原列表&gt;&gt;&gt;y.sort()&gt;&gt;&gt;&gt;x[2,1,3]&gt;&gt;&gt;y[1,2,3] #既保留了原列表x,又创建了新列表y倒序 x.sort(reverse=True)10.高级排序cmp 比较&gt;&gt;&gt;x =[2,1,3]&gt;&gt;&gt;x.sort(cmp)&gt;&gt;&gt;x[1,2,3]# 这里sort方法有两个可选参数，也称为关键字参数：key 和 reverse# 此类函数不是直接来确定对象大小，而是为每个元素创建一个键，根据键来排序例：&gt;&gt;&gt;x =['abc','a','ab'] &gt;&gt;&gt;x.sort(key = len ) &gt;&gt;&gt;x ['a','ab',abc']# 另一个关键字参数reverse是布尔值&gt;&gt;&gt;x =[1,2,3]&gt;&gt;&gt;x.sort(reverse =True)&gt;&gt;&gt;x[3,2,1]11.enumerate迭代器# 将列表中的index和value以元组的形式表示出来list(enumerate（x）) 元组1.元组大部分时候通过圆括号括起来2.空元组 &gt;&gt;&gt;()3.一个值的元组 &gt;&gt;&gt;42, #元组加逗号是十分关键的 更新元组x = (1,2)x = x[ :1] +(‘0,’ )+x[1: ]xx = (1,2,3)12#优先级，索引，内容(prioroty,index,item) 构建一键多值123456789#collections模块中的defaultdict类from collections import defaultdictd = defaultdict(list)d['a'].append(1)d['a'].append(2)d = defaultdict(set)d['a'].add(1)d['a'].add(2) 字典1234oni = &#123;"name"="chen","id"=4545&#125;oni.keys() #查看键oni.values() #查看值oni.items() #查看键值 wd 为汉字编码 注意：1.字典中的键不可以重复，会返回后面的值2.字典中的键是任意可hash对象（不可变对象，如数字，元组，字符串） 格式化字符串 format:字符串格式化的一种方式 12345"我是&#123;&#125;会".format(1)"我是&#123;&#125;会".format([1,2,3])"我是&#123;&#125;会".format(&#123;1,2,3&#125;)"我是&#123;&#125;会&#123;&#125;".format(&#123;1,2,3&#125;,[1,2,3])"我是&#123;&#125;会&#123;&#125;".format(&#123;1,2,3&#125;,1) 列表推导式 帮助生成包含一组数据的列表[i+10 for i in range(10)] —&gt; [10,11, ,19] 与字符串一起使用 [&quot;10月{}日&quot;.format(i) for i in range(1,10)]—&gt;[“10月1号”，“10月2号”， ]list[0]将列表第一个元素转换 字典推导式 帮助我们快速生成包含一堆数据的字典12&#123;i+10:i for i in range(10)&#125; #&#123;10:0,11:1, ,19:9&#125;&#123;"a&#123;&#125;".format(i):10 for i in range(3)&#125; #&#123;"a&#123;0&#125;":10,,,,&#125; 三元运算 if 后面的条件成立，就把i前面的结构赋值给a，否则把else后面的结果赋值给a1a=10 if 4&gt;2 else 20 # a = 10 12345678910111213141516"let's learn %r" % "python"#格式化%可以为s,d,r,其中r可以打印任何内容#%r用来调试最好，%s和其他格式符用来向用户显示变量 %c 格式化字符及其ASCII码 %s 格式化字符串 %d 格式化整数 %u 格式化无符号整型 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数（大写） %f 格式化浮点数字，可指定小数点后的精度 %e 用科学计数法格式化浮点数 %E 作用同%e，用科学计数法格式化浮点数 %g %f和%e的简写 %G %f 和 %E 的简写 %p 用十六进制数格式化变量的地址 %.xf 表示将小数中小数点后面的位数固定到x位如果小数的位数比x大，则保留x位小数eg: 12\&gt;&gt;&gt; "%.3f" % 3.1415926'3.142' 如果小数的位数比x小，则用0补足eg:12\&gt;&gt;&gt; "%.4f" % 3.1'3.1000' 浮点数四舍五入 round() :round(1.733) if __name__ == &quot;__main__&quot;作用 让Python知道该模块是作为程序运行还是导入到其他程序中 模块sys 模块 &amp; os模块分别作用 sys模块负责程序与Python解释器的交互提供了一系列函数和变量用于操控Python运行时的环境 os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口 sys模块内容sys.path : 查找模块所在的目录列表. 若要在与解释器不同路径下导入模块，则需要在解释器路径下添加路径sys.path.append(&quot;路径&quot;) sys.argv: 「argv」是「argument variable」参数变量的简写形式，一般在命令行调用的时候由系统传递给程序。这个变量其实是一个List列表，argv[0] 一般是被调用的脚本文件名或全路径，和操作系统有关，argv[1]和以后就是传入的数据了。 os模块内容 命令 命令 作用 os.linesep 在当前平台使用的行终止符 包（package) 创建一个文件夹，用于存放相关的模块，文件夹的名字即为包的名字 在文件夹中创建一个__init__.py的模块文件，内容可以为空 将相关的模块放入文件夹中 调用方法 ：import M1.module 函数1234#运行，调用，使用函数为同一个意思def print_two(*args):#*代表可以接收所有参数def print_two_again(arg1,arg2) eval()eval(): 是程序语言中的函数，功能是获取返回值，不同语言大同小异，函数原型是返回值 = eval( codeString )，如果eval函数在执行时遇到错误，则抛出异常给调用者。 语法eval(expression[, globals[, locals]])有三个参数，表达式字符串，globals变量作用域，locals变量作用域。 其中第二个和第三个参数是可选的。 如果忽略后面两个参数，则eval在当前作用域执行。实例:123a=1eval("a+1")2 如果指定globals参数12345a=1g=&#123;'a':10&#125;eval("a+1",g)11 如果指定locals参数123456a=10b=20c=20g=&#123;'a':6,'b':8&#125;l=&#123;'b':9,'c':10&#125;eval("a+b+c",g,l) Help(模块名) help(模块.函数名) 这是得到模块帮助文档的方式，所谓帮助文档就是定义函数时放在”‘ ‘“之间的东西，也被称为文档注释 name 用于检测主程序代码中的模块是被导入还是被直接执行 如果模块是被导入，则__name__的值为模块名字 如果模块是被直接执行，则__name__的值为&#39;__main__&#39; 类 新式类与旧式类: python的新式类是2.2版本引进来的，官方给的解释是：为了统一类(class)和类型(type)。在2.2之前，比如2.1版本中，类和类型是不同的，如a是ClassA的一个实例，那么a.class返回 ‘ class main.ClassA‘ ，type(a)返回总是。而引入新类后，比如ClassB是个新类，b是ClassB的实例，b.class和type(b)都是返回‘class ‘main.ClassB’ ，这样就统一了。 类的实例化12if __name__ == '__main__':Spider(param) 使用 class 关键字定义类，可以选择提供一个父类或者说基类123456789101112class Filter: def init(self): self.blocked=[] def filter(self,sequence): print ([x for x in sequence if x not in self.blocked])#Spam_Filter是Filter的子类class Spam_Filter(Filter):#重写Filter超类中的init方法 def init(self): #过滤的元素序列 self.blocked = [1] Filter是用于过滤序列的通用类1234&gt;&gt;&gt; f = Spam_Filter()&gt;&gt;&gt; f.init()&gt;&gt;&gt; f.filter([1,2,3])&gt;&gt;&gt; [2,3] Python内建 issubclass :判断一个类是否是另一个类的子类12issubclass(Spam_Filter,Filter)True 查看子类的基类 ： bases 123print (Spam_Filter.__bases__)(&lt;class __main__.Filter at 0x171e40&gt;.)#若无基类，则返回一个空序列 查看对象属于哪一个类 ： class 12print (f.__class__)&lt;class __main__.Spam_Filter at 0x1707c0&gt; 调用绑定类的方法时，使用类名Teacher.say() 继承注意: 若子类继承了父类，但是在子类中，==父类的构造方法被重写==，即__init__内容被改变， 且新的构造方法中==没有任何关于初始化父类构造方法中特性的代码==，则会发生异常 python （未）绑定方法解释 —绑定方法: 在调用一个实例的方法时，该方法的self参数会被自动绑定到实例上 因为绑定方法的缘故，若在子类中使用父类的方法，且在子类中新的构造方法没有关于初始化新特性的代码，故程序会报错 解决方案 在子类函数中直接调用类的方法，例如Bird.__init__(self),则实例就不会被绑定，就可以自由地提供需要的self参数例子 1234class songbird(Bird): def __init__(self): Bird.__init__(self） # 在子类构造函数中使用父类的构造方法 self.sound = ’squawk’ 使用Super函数在子类的构造函数中直接使用Super()函数，在python3.0之后版本中Super中可以不带任何参数 1234class songbird(Bird): def __init__(self): super().__init__() self.sound = ‘squawk’ 接口（“协议”）与内省hasattr(对象名,&#39;方法&amp;特性&#39;,None): 检测特性是否存在 getattr(对象名,&#39;方法&amp;特性&#39;,None): 直接访问特性，若特性不存在，则返回None setattr(对象名,&#39;方法&amp;特性&#39;,&#39;内容&#39;): 设置对象的特性 私有方法(成员) Python的私有不是真的私有，是一种成为name mangling的改名策略可使用对象.__classname_attribuename访问12# 在方法名前加上双下划线__即可def __func(self): 异常处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465try: a = 100 c = a+'a'except TypeError as f: print("出错"，f)except NameError as f: print("出错"，f)# else使你可以编写只有在try子句中没有遇到任何异常时才能运行的代码。# finally使您能够执行应始终运行的代码段，无论是否遇到任何异常。# 捕捉异常#若对异常不进行处理try: a = 100 c = a+'a'except: pass#对所有异常类型的处理except Exception as f: print("Exception",f)finally: print("最终输出")# 打印错误内容except (TypeError,NameError) as e: print(e)# 用一个块来捕捉异常,用元组列出try: a = 100 c = a+'a'except (TypeError,NameError): print('Error')#抛出（制造）异常a = 1b = 2c = a+braise TypeError("你就是错了")raise Exception(' ')# 屏蔽异常class MuffledCalculator: muffled = False def calc(self,expr): try: # eval()是程序语言中的函数，功能是获取返回值，不同语言大同小异 # 函数原型是返回值 = eval( codeString ) # 如果eval函数在执行时遇到错误，则抛出异常给调用者。 return eval(expr) except ZeroDivisionError: # 当给muffled赋值为True时，关闭屏蔽 if self.muffled: print 'Division by zero is illegal' else: raise# 嵌套加入else子句try: print('a')except: print('b')else: print('c')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Compute]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E8%AE%A1%E7%AE%97%2Fpandas%26numpy%2F</url>
    <content type="text"><![CDATA[帮助函数 S.method? Pandas1.什么是Series简单来说：一维带标签（索引）的数组 2.Series的特征 数组中的数据可以是任意的类型，包括整数、浮点数、字符串、列表、字典等python对象 数组中的数据应为同一类型 创建Series一般格式s = pd.Series(data,index = index) 通过列表list创建Series 1234import pandas as pdimport numpy as nps = pd.Series([10,30,20,40])si 通过字典dictionary创建Series 123dict_1 = &#123;"a":10,"c":5,"b":40&#125;s1 = pd.Series(dict_1)s1 字典和Series的区别： 字典是无序的，Series是有序的，通过无序的字典来创建Series后，Series会将字典的键作为自己的索引，并且按升序方式排列 通过数组array创建Series123array_1 = np.arange(10,16)s2 = pd.Series(array_1,index=list("abcdef")) # 设置indexs2 Series的属性 获得索引index12s2.indexIndex(['a', 'b', 'c', 'd', 'e', 'f'], dtype='object') 索引为迭代器 通过赋值整体地修改索引值12s2.index = ["aa","bb","cc","dd","eee","fff"]s2 要点：新设置的索引个数必须与原来索引个数一致值得一提的是：提取单个索引值来修改是不允许的，如果要修改索引值，就得全部重新设置 修改index的名称 12s2.index.name = "banana"s2 修改Series的名称 1s2.name = "length" 获取Series的值values 1s2.values 通过以上我们发现，Series对象本身及其索引都有name属性 Series的索引 index 位置索引 12#得到第一行的数s2[0] 得到最后一行的数 1s2[-1] 得到特定一些行的数(如第1行，第4行，第6行） 1s2[[0,3,5]] *名称索引12#得到索引为aa所对应的数s2["aa"] Series的切片slice 索引位置切片1s2[1:4] 没有包含末端 索引名称切片1s2["aa":"eee"] 包含末端 修改Series的值1234s2[index] = value （index表示需要修改的值所对应的索引）s2[i] = value （i表示需要修改的值所对应的索引位置）s2["aa"] = 100s2[2] = 120 添加Series的值 返回一个新的Series，不修改原来的Series1s2.append(pd.Series([value1,value2,...],index = [index1,index2,...])) 12#添加Series的值,并返回一个新的Seriess2.append(pd.Series([50,60],index=["a1","a2"])) 直接在原来的基础上修改Series1s2["new index"] = value 通过append来添加Series的值，特点是： 返回一个新的Series 批量修改 通过s2[&quot;new index&quot;] = value这种方式来添加的值，特点是: 直接在原来的Series基础上增加值 每次只能增加一个值 删除Series的值del s2[index]12#删除y索引对应的99这个值del s2["y"] 过滤Series的值 通过布尔选择器（条件筛选）来过滤掉一些值，从而得到满足条件的值123456789s2[s2 &lt; value]s2[s2 &gt; value]s2[s2 == value]s2[s2 != value]#单条件筛选s2[s2 &gt; 90]#多条件筛选s2[(s2 &gt; 50) | (s2 &lt; 14)] Series的缺失值处理 创建一个带有缺失值的Series12# np.nans = pd.Series([10,np.nan,15,19,None]) 提示：None值会被当做NA处理* 判断是否有缺失值isnull（） 判断s中的缺失值s.isnull() 如果需要取出这些缺失值，则通过布尔选择器来筛选出来s[s.isnull()] 删除缺失值 123456#dropna()会删除掉所有缺失值NaN，并返回一个新的Series#原有的Series并未发生改变s.dropna()#如果希望原有的Series发生改变，#可以将s.dropna（）返回的新Series直接赋值给原来的Seriess = s.dropna() 此外，我们也可以通过过滤的方式来达到一样的删除效果： 123456789data[~data.isnull()]data[data.notnull()]s = pd.Series([10,np.nan,15,19,None]) #初始化一下s #依然是返回一个新的Series，波浪号~表示否定、非的意思s[~s.isnull()]#也可以使用 s.notnull#通过notnull（）也能实现，同样也是返回一个新的Seriess[s.notnull()] 填充缺失值fillna（） :用指定值或插值的方式填充缺失值 12345678910111213141516171819用指定值填充缺失值#用0填充缺失值,返回的依然是一个新的Seriess.fillna(value=0)#如果希望直接修改原Series#一种方法是之前说的直接赋值，另一种是添加参数inplace=Trues.fillna(value=0,inplace=True)#用插值填充缺失值#初始化一下ss = pd.Series([10,np.nan,15,19,None])#向前填充（ffill，全称是front fill）s.fillna(method="ffill")#向后填充（bfill，全称是back fill）s.fillna(method="bfill")` 排序123456789101112131415161718192021222324#创建一个Seriess3 = pd.Series([10,15,8,4,20],index=list("gadkb"))s3g 10a 15d 8k 4b 20dtype: int64#（1）根据索引排序#sort_index() 默认升序，如果添加参数ascending=False,则降序排列#(2)根据索引升序排列# 根据值排序 sort_valuess3.sort_index()a 15b 20d 8g 10k 4dtype: int64#根据索引降序排列s3.sort_index(ascending=False) 排名1234567891011121314151617181920# rank（）# 创建一个用来排名的Seriess4 = pd.Series([2,5,15,7,1,2])s40 21 52 153 74 15 2# 中国式排名s4.rank(ascending=False,method="dense")0 4.01 3.02 1.03 2.0 4 5.0 5 4.0 Series的描述性统计 值的计数 Series.value_counts（） 123456789101112131415161718192021222324252627282930313233343536373839#创建一个Seriess5 = pd.Series([100,50,100,75,24,100])s5#值的计数 Series.value_counts（）s5.value_counts()100 375 150 124 1#最小值 s5.min（）s5.min()24#最大值 s5.max（）s5.max()100#中位数 s5.median（）s5.median()#均值 s5.mean（）s5.mean()74.83333333333333#求和 s5.sum（）s5.sum()449#标准差 s5.std()s5.std()31.940048006643114#描述性统计 s5.describe（）s5.describe().round(1) # round表示小数点后多少位count 6.0mean 74.8std 31.9min 24.025% 56.250% 87.575% 100.0max 100.0 Series的向量化运算 可对Series进行批量操作，并且返回一个新的Series并不会在原基础上直接修改123s5 + 1000s5 * 2s5 / 10 自动对齐相同索引的数据,不同索引的数据对不上，则显示NaN123456789s6 = pd.Series([35000,40000,71000,5500],index=list("abcd"))s7 = pd.Series([222,35000,4000,2222],index=list(aqtb))s6 + s7a 35222.0b 42222.0c NaNd NaNq NaNt NaN]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_Compute</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_requests]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2Frequests%2F</url>
    <content type="text"><![CDATA[requests 爬取网页的通用代码框架12345678def getHTMLText(url):try:r=requests.get(url,timeout30)r.raise_for_status #如果状态不是200，引发HTTPError异常r.encoding = r.apparent_encoding # 将编码格式转换为响应内容的编码格式return r.textecxept:return #产生异常 1234567891011import requestsfrom requests.exceptions import RequestExceptiondef page_state(rep): url = " " try: rep = requests.get(url) if rep.status_code == 200: # 如果状态码正常，则返回url的内容 return rep.text return None except: return None 解释 requests是python实现的简单易用的HTTP库，使用起来比urllib简洁很多requests.get()用于请求目标网站，类型是一个HTTPresponse类型 基本操作123456789import requestsresponse = requests.get('http://www.baidu.com')print(response.status_code) # 打印状态码print(response.url) # 打印请求urlprint(response.headers) # 打印头信息print(response.cookies) # 打印cookie信息print(response.text) #以文本形式打印网页源码print(response.content) #以字节流形式打印 GET请求相关内容传入参数 第一种直接将参数放在url内 1234import requests#url/get?参数&amp;参数response = requests.get(http://httpbin.org/get?name=gemey&amp;age=22)print(response.text) 第二种先将参数填写在dict中，发起请求时params参数指定为dict 123456789import requestsdata = &#123; 'name': 'Jedieal', 'age': 18&#125;response = requests.get('http://httpbin.org/get', params=data)print(response.text) 案例 百度搜索123import requestskv = &#123;'wd':'python'&#125;r = requests.get("http://www.baidu.com/s",params=kv) 请求添加头信息123456import requestsheads = &#123;&#125;heads['User-Agent'] = 'Mozilla/5.0 ' \ '(Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 ' \ '(KHTML, like Gecko) Version/5.1 Safari/534.50' response = requests.get('http://www.baidu.com',headers=headers) #####访问响应头字段1234567r.headers['Content-Type]'application/json'r.headers.get('content-type')'application/json' 使用代理同添加headers方法，代理参数也要是一个dict: 这里使用requests库爬取了IP代理网站的IP与端口和类型 因为是免费的，使用的代理地址很快就失效了。12345678910111213141516171819202122232425262728293031323334353637import requestsimport redef get_html(url): proxy = &#123; 'http': '120.25.253.234:812', 'https': '163.125.222.244:8123' &#125; heads = &#123;&#125; heads['User-Agent'] = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0' req = requests.get(url, headers=heads,proxies=proxy) html = req.text return html#利用正则匹配IPdef get_ipport(html): regex = r'&lt;td data-title="IP"&gt;(.+)&lt;/td&gt;' iplist = re.findall(regex, html) regex2 = '&lt;td data-title="PORT"&gt;(.+)&lt;/td&gt;' portlist = re.findall(regex2, html) regex3 = r'&lt;td data-title="类型"&gt;(.+)&lt;/td&gt;' typelist = re.findall(regex3, html) sumray = [] for i in iplist: for p in portlist: for t in typelist: pass pass a = t+','+i + ':' + p sumray.append(a) print('高匿代理') print(sumray)if __name__ == '__main__': url = 'http://www.kuaidaili.com/free/' get_ipport(get_html(url)) 获取cookie12345678import requestsresponse = requests.get('http://www.baidu.com')print(response.cookies)print(type(response.cookies))#字典形式，利用items()遍历for k,v in response.cookies.items(): print(k+':'+v) 解析json1234567import requestsresponse = requests.get('http://httpbin.org/get')print(response.text)#response.json()方法同json.loads(response.text)print(response.json())print(type(response.json())) 保存一个二进制文件 二进制内容为response.content123456import requestsresponse = requests.get('http://img.ivsky.com/img/tupian/pre/201708/30/kekeersitao-002.jpg')b = response.contentwith open('F://fengjing.jpg','wb') as f: f.write(b) 超时异常捕获12345678import requestsfrom requests.exceptions import ReadTimeouttry: res = requests.get('http://httpbin.org', timeout=0.1) print(res.status_code)except ReadTimeout: print('timeout') 异常处理使用try…except来捕获异常 Exceptions:123456789101112import requestsfrom requests.exceptions import ReadTimeout,HTTPError,RequestExceptiontry: response = requests.get('http://www.baidu.com',timeout=0.5) print(response.status_code)except ReadTimeout: print('timeout')except HTTPError: print('httperror')except RequestException: print('reqerror') POST 请求 通常，你想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典在发出请求时会自动编码为表单形式：1234payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.post("http://httpbin.org/post", data=payload)print(r.text) 可以为 data 参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式尤其有效：123456789payload = (('key1', 'value1'), ('key1', 'value2'))r = requests.post('http://httpbin.org/post', data=payload)print(r.text)&gt;&gt;&gt;"form": &#123; "key1": [ "value1", "value2" ] &#125; 很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个dict，那么数据会被直接发布出去。可以使用 json 参数直接传递，然后它就会被自动编码。这是 2.4.2 版的新加功能：123url = 'https://api.github.com/some/endpoint'payload = &#123;'some': 'data'&#125;r = requests.post(url, json=payload)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython_Advanced%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B_1%2F</url>
    <content type="text"><![CDATA[函数式编程 原则写代码要遵循==开发封闭==原则，虽然这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即： 封闭：已实现的功能代码块 开放：对扩展开发 内容装饰器12345678910def w1(func): def inner(): # 验证1 # 验证2 # 验证3 return func() return inner@w1 # 相当于执行了 w1(f1())def f1(): print('f1') 当写完这段代码后（函数未被执行、未被执行、未被执行），python解释器就会从上到下解释代码，步骤如下：12def w1(func): ==&gt;将w1函数加载到内存@w1 没错，从表面上看解释器仅仅会解释这两句代码，因为函数在没有被调用之前其内部代码不会被执行。 从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章 @函数名 : 是python的一种语法糖。 如上例 @w1内部会执行以下操作: 执行w1函数，并将 @w1 下面的 函数 作为 w1 函数的参数即：@w1 等价于 w1(f1)。 所以，内部就会去执行：1234567891011121314151617def inner: #验证 return f1() # func是参数，此时 func 等于 f1return inner # 返回的 inner，inner代表的是函数，非执行函数# 其实就是将原来的 f1 函数塞进另外一个函数中。# 将执行完的 w1 函数返回值赋值给@w1下面的函数的函数名# w1函数的返回值是： def inner: #验证 return 原来f1() # 此处的 f1 表示原来的f1函数# 然后，将此返回值再重新赋值给 f1，即：new_f1 = def inner: #验证 return 原来f1() 如此一来， 即执行了验证的功能，又执行了原来 f 函数的内容，并将原 f1 函数返回值, 返回给业务调用着。 参数传递12345678910111213141516171819202122232425 # 一个参数：def w1(func): def inner(arg): # 验证1 # 验证2 # 验证3 return func(arg) return inner@w1def f1(arg): print('f1')# 两个参数：def w1(func): def inner(arg1,arg2): # 验证1 # 验证2 # 验证3 return func(arg1,arg2) return inner@w1def f1(arg1,arg2): print('f1') 问题: 装饰具有处理n个参数的函数的装饰器？12345678910def w1(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return inner@w1def f1(arg1,arg2,arg3): print('f1') 问题：一个函数可以被多个装饰器装饰吗？123456789101112131415161718def w1(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return innerdef w2(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return inner@w1@w2def f1(arg1,arg2,arg3): print('f1') Lambda函数（匿名函数） 函数 ： 最大程度地复用代码 存在问题：若函数很小，很短，则会造成啰嗦，不方便阅读代码 lambda表达式 一个表达式，函数体相对简单 用法 以lambda开头 紧跟一定的参数 参数后面用冒号和表达式主题分开 只是一个表达式，没有return 实例 stm = lambda x: 100 * x stm(89) ==&gt;8900 高阶函数 定义 ： 把函数作为参数使用的函数 注意 函数名称就是一个变量，即函数可以作为参数 举例`pythondef funA(n):return n * 100 def funB(n): return funA(n) * 3]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_Regex]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegex%2F</url>
    <content type="text"><![CDATA[正则表达式 Regex 1.正则表达式定义：正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符和这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑 2.需要取出来的就(.*?) 3.(. ) 贪婪模式———将标签内所有复合内容提取（.？） 非常模式——只提取有用部分 字符 作用 . 匹配所有英文字符 a[bcd]e 匹配字符集 匹配 a()e ()内bcd任意一个都可匹配 \d 匹配数字 “\D”：匹配除数字外 \s 匹配空格，换行符等 “\S”:匹配非空格，换行符 \w 匹配数字和字母 “\W”: 匹配非数字和字母 ^abc 匹配开头 abc$ 匹配结尾 （”abc”,”abcABC”,re.I) 不区分大小写的匹配 （”abc”,”abc\nABC”,re.S) 避免换行符等干扰提取内容 ab? 在a后面匹配一个或0个b ab+ 在a后面匹配至少一个b ab* 在a后面匹配至少0个b 当既要不分大小写，又要去除换行等影响，则(或运算)| re.S)```123456789101112---[TOC]### 匹配模式```Python #匹配模式有：1)re.I(re.IGNORECASE): 忽略大小写2)re.M(MULTILINE): 多行模式，改变’^’和’$’的行为3)re.S(DOTALL): 点任意匹配模式，改变’.’的行为,可匹配换行符4)re.L(LOCALE): 使预定字符类 \w \W \b \B \s \S 取决于当前区域设定5)re.U(UNICODE): 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性6)re.X(VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释 123s= "&lt;div&gt;hello\nworld&lt;/div&gt;"#去除\n的影响m = re.findall(r"&lt;div&gt;(.*)&lt;/div&gt;",s,re.S) re –方法1、findall &amp; find12345678import re# re.findall(pattern, string)# pattern 表示我们希望寻找的子字符串# string 表示我们要在其中查找的主字符串content = re.findall(r'代码内容 .*?代码内容'，url.text，re.S)#若在代码内容中有特殊字符，需要被转义，例如r'&lt;script\(\)&gt;;&lt;/script&gt;'#使用re.S的作用为在代码中有许多回车与换行，若不加，则可能匹配不到内容 注意：至少两个参数，一个为正则表达式，另一个为源代码123456content = requests.get(url).content.decode('gb2312')#转义双引号start = content.find('&lt;map name=\"map_86\" id=\"map_86\"')end = content.find('&lt;/map&gt;')content = content[start:end + len('&lt;/map&gt;')].strip()print (content) 2、re.search()re.search(): 匹配的是一个模式在一个字符串中的第一个实例，然后以 re 匹配对象的形式返回它。 因为 re.search() 返回的是一个 re 匹配对象，所以我们不能直接通过 print 展示其中的内容。我们必须首先为其应用group() 函数。 group()： 函数的作用是将匹配对象转换成字符串。re.search().group() group(0)则是整个匹配的内容，返回一个实体对象group(1)则是匹配第一个括号里面的内容，取出括号里匹配的实体对象group(2)则是匹配第二个括号里面的内容，取出括号里匹配的实体对象group(0,1,2)则返回一个实体对象的元组 3、re.split()分割字符12345678import re#不保留匹配项m = re.split('\d+' , '123abc321cba')print mprint "\n"#保留匹配项,加（）m = re.split('(\d+)' , '123abc321cba')print m 4、re.sub()re.sub(): 是另一个很好用的 re 函数。顾名思义，它的功能是替换一个字符串的一部分。 有三个参数第一个是所要替换的子字符串，第二个是用来替换前者的字符串，第三个是主字符串本身12345sender = re.search("From:.*", fh)address = sender.group()email = re.sub("From", "Email", address)print(address)print(email) 改进123456789#小操作#1.以列表形式储存数据output = []#2.去除空格output.append(content[0].replace("\n",""))#3.设置爬虫休眠时间,防止爬取速度过快而被封import timetime.sleep(1) 1234567891011121314151617#如果是多次调用某个正则，则最好先编译后使用p = re.compile("^abc")m1 = re.findall("abc\nabc")m2 = re.findall("abced\nsdf")m3 = re.findall("dfsfd\nabcdf")#函数re.compile将正则表达式（以字符串书写的）转换为模式对象，可以实现更加有效的匹配。例子：import retext = "JGood is a handsome boy, he is cool, clever, and so on..."re.findall(r'\w*oo\w*', text) #查找所有包含'oo'的单词#使用compile函数：#导入re模块：import retext = “JGood is a handsome boy, he is cool, clever, and so on…”regex = re.compile(r‘’\w*oo\w*’)print regex.findall(text) #查找所有包含’oo’的单词 内容清洗(去空白字符等)123456789import reimport requestsimport html#将编译后的内容去除转义符，即清洗内容url = "www..."response = requests.get(url)pattern = re.compile("div...",re.S)body = html.unescape(response.text).replace("&lt;br/&gt;","\n")m = pattern.findall(body) 详细概念*匹配 0 个或更多个其左侧的模式的实例。也就是说它会查找重复的模式。当我们查找重复模式时，我们说我们的搜索是贪婪匹配。如果我们没有查找重复模式，我们可以说我们的搜索是非贪婪匹配或懒惰匹配。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Chart]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%BB%98%E5%9B%BE%2Fpyecharts%2F</url>
    <content type="text"><![CDATA[1、渲染图表123456from pyecharts import Barbar = Bar("我的第一个图表", "这里是副标题")bar.add("服装", ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", ], [5, 20, 36, 10, 75])# bar.print_echarts_options() # 该行只为了打印配置项，方便调试时使用bar.render() # 生成本地 HTML 文件 解释 add()主要方法，用于添加图表的数据和设置各种配置项 print_echarts_options()打印输出图表的所有配置项 render()默认将会在根目录下生成一个 render.html 的文件，支持 path 参数，设置文件保存位置，如 render(r&quot;e:\my_first_chart.html&quot;)，文件用浏览器打开。Note 可以按右边的下载按钮将图片下载到本地，如果想要提供更多实用工具按钮，请在 add() 中设置 is_more_utils 为 True 2、使用主题 安装主题插件$ pip install echarts-themes-pypkg 设置主题bar.use_theme(&#39;dark&#39;) Noteecharts 自带 dark 主题， pyecharts 也就自带了 dark。 echarts-themes-pypkg 提供了 vintage, macarons, infographic, shine 和 roma 主题。 3、多次显示图表12345678910111213141516from pyecharts import Bar, Linefrom pyecharts.engine import create_default_environmentbar = Bar("我的第一个图表", "这里是副标题")bar.add("服装", ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", ], [5, 20, 36, 10, 75])line = Line("我的第一个图表", "这里是副标题")line.add("服装", ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋"], [5, 20, 36, 10, 75])env = create_default_environment("html")# 为渲染创建一个默认配置环境# create_default_environment(filet_ype)# file_type: 'html', 'svg', 'png', 'jpeg', 'gif' or 'pdf'env.render_chart_to_file(bar, path='bar.html')env.render_chart_to_file(line, path='line.html')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_Draw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_encode]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%2F</url>
    <content type="text"><![CDATA[编码格式a=u&#39;string&#39; :u 代表 unicodea.encode(&#39;utf-8&#39;) : utf-8格式a.decode(&#39;utf-8&#39;) : 从utf-8转至Unicode格式 from sys import argvscript,filename = argv 获取文件信息 ####文件方法f.readline(): f文件会记录每次调用readline()后的读取位置，可以在下次被调用时读取下一行 fileObject.seek(offset[, whence]): offset: 开始的偏移量，也就是代表需要移动偏移的字节数whence：可选，默认值为 0。给offset参数一个定义，表示要从哪个位置开始偏移；0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。 1234fo.seek(0, 0)line = fo.readline()print "读取的数据为: %s" % (line)f.seek(4,1) #1为从当前位置，移动4个字节 文件处理r :只读 f.close(),f.read(),f.readline() w :只写 文件内有内容，则写入内容会覆盖*，若无内容，则会新写入内容-f.write() F.writelines() a :追加 f.write() 写入内容后，f.close()才会保存修改 若要强制修改。则使用 f.flush()rb :读写wb :写读ab :追加及读 方法 | 作用:—: |:—:f.seek(0) | 回到文件开头f.tell(0) |告知当前所在位置f.truncate() |清空文件 123456#只读模式f = file('myfile.txt','r')for line in f.readlines(): # 去除换行符， 将 ： 前后分割 line =line.strip('\n').split(':') print (line) 1234#图片，音频，zip的复制with open("test_01.png","rb") as f1: with open("test_02.png","wb") as f2: f2.write(f1.read()) 123456#例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：&gt;&gt;&gt; from PIL import Image&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; i = Image.open(BytesIO(r.content)) 123456fh = open(r"test_emails.txt", "r").read()# 注意我们直接在目录路径之前使用了 r# 这项技术会将一个字符串转换成一个原始字符串# 这有助于避免由某些机器阅读字符的方式所导致的冲突# 比如 Windows 中目录路径中的反斜杠]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider_Selenium]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2Fselenium%2F</url>
    <content type="text"><![CDATA[##自动化测试 12345678910import selenium.webdriverdriver = selenium.webdriver.'浏览器种类'()url = " "driver.get(url)#向url内发送内容driver.find_element_by_class_name(" ").send_keys(" ")#模拟点击的动作driver.find_element_by_id(" ").click()driver.quit() ####1、声明浏览器对象，访问页面并获取网页html（源代码） 123456from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')# browser.page_source是获取网页的全部html,即获取网页源代码print(browser.page_source)browser.close() 2、查找元素12345678910111213# 单个元素from selenium import webdriverbrowser = webdriver.Chrome()browser.get('https://www.taobao.com')# 三种方式返回的是相同的值input_first = browser.find_element_by_id('q')input_second = browser.find_element_by_css_selector('#q')input_third = browser.find_element_by_xpath('//*[@id="q"]')print(input_first,input_second,input_third)# 多个元素，elements多个sinput_first = browser.find_elements_by_id('q')browser.close() 123456789# 可以使用通用的方法from selenium import webdriverfrom selenium.webdriver.common.by import Bybrowser = webdriver.Chrome()browser.get('https://www.taobao.com')# 第一个参数传入名称，第二个传入具体的参数input_first = browser.find_element(By.ID,'q')print(input_first)browser 3、元素交互操作-搜索框传入关键词进行自动搜索12345678910111213141516171819from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.get('https://www.taobao.com')# 找到搜索框input = browser.find_element_by_id('q')# 传送入关键词input.send_keys('iPhone')time.sleep(5)# 清空搜索框，文本框input.clear()# 传送入关键词input.send_keys('男士内裤')# 找到搜索按钮button = browser.find_element_by_class_name('btn-search')# 点击按钮button.click()# double_click(on_element=None)# 双击Double-clicks an element. 4.截图img.screenshot_as_png 5.动作链123# 前进后退browser.back()browser.forward() 12345678910111213# 调用动作链from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()# 将source元素拖放至target元素处，参数为两个elementObjsource = browser.find_element_by_css_selector('#draggable')target = browser.find_element_by_css_selector('#droppable')# 将动作链实例化action = ActionChains(browser)# drag_and_drop(鼠标拖动)action.drag_and_drop(source,target)# 执行动作链action.perform() 1234567891011121314151617181920# 更多用法# move_to_element 鼠标移动到某一个元素上,结束elementObjActionChains(driver).move_to_element(e)# 鼠标移动到制定的坐标上，参数接受x，yActionChains(driver).move_by_offset(e['x'],e['y'])#Keys 实际是Selenium提供的一个键盘事件模块，在模拟键盘事件时需要导入Keys模块from selenium.webdriver.common.keys import Keys# key_down 模拟键盘摁下某个按键 key_up 松开某个按键，# 与sendkey连用完成一些操作，每次down必须up一次否则将出现异常# 全选&amp;复制# key_down(value, element=None)# element：要发送密钥的元素。如果没有，则将密钥发送给当前有焦点的元素。ActionChains(driver).key_down(Keys.CONTROL,dom).send_keys('a')\.send_keys('c').key_up(Keys.CONTROL)# 黏贴ActionChains(driver).key_down(Keys.CONTROL,dom1).send_keys('v')\.key_up(Keys.CONTROL).perform() 6、获取元素信息切换标签browser.switch_to.frame(&#39;iframe&#39;): switch_to.标签名(‘属性’) 获取属性123456789101112131415from selenium import webdriverfrom selenium.webdriver import ActionChainsbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)logo = browser.find_element_by_id('zh-top-link-logo')#获取网站logoprint(logo)# 获取属性print(logo.get_attribute('class'))# 获取网页的cookiesprint(browser.get_cookies)# 删除所有的cookiesbrowser.delete_all_cookiesbrowser.close() 获取页面源码12345# selenium的page_source方法可以直接返回页面源码from selenium import webdriverdriver = webdriver.Firefox()driver.get("http://www.cnblogs.com/yoyoketang/")page = driver.page_source 获取文本值12345678from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')# 获取文本值print(input.text)browser.close() 获取Id，位置，标签名，大小12345678910from selenium import webdriverbrowser = webdriver.Chrome()url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input.id)#获取idprint(input.location)#获取位置print(input.tag_name)#获取标签名print(input.size)#获取大小browser.close() 7、等待12345678910# 隐式等待from selenium import webdriverbrowser = webdriver.Chrome()# 设置等待时间,browser.implicitly_wait(5)# 当查找元素并没有立即出现时，隐式等待将等待一段时间在查找DOM,默认时间为0url = 'https://www.zhihu.com/explore'browser.get(url)input = browser.find_element_by_class_name('zu-top-add-question')print(input) 123456789101112131415# 显式等待 Explicit Waits¶from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as ECdriver = webdriver.Firefox()driver.get("http://somedomain/url_that_delays_loading")try: element = WebDriverWait(driver, 10).until( # 可以修改By.的选择，“ ”内的对象也可以改变 EC.presence_of_element_located((By.ID, "myDynamicElement")) )finally: driver.quit()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux操作]]></title>
    <url>%2F2018%2F07%2F25%2FLinux%2Flinux%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Linux 创建 README.md 文件并写入内容echo &quot;# 菜鸟教程 Git 测试&quot; &gt;&gt; README.md 设置Linux的IP地址ifconfig eth0 ip地址 添加虚拟网卡 ifconfig eth0:1 198.168.1.1 操作技巧文件部分名称+ tab ： 自动补全文件名 知识概念文件与用户的关系 所有者 u : 只有一个，但可以交换 用户组 g ： 只有一个，可以使用文件，但不是所有者 其他人 o ： 既不属于所有者，又不是用户组 格式 ： 表示文件 d ： 表示目录 l : 表示软连接 例子 ：rw- r– r– rw- : 代表文件的所有者有读写的权限，代表最高权限，不一定需要赋予所有权限，够用就行 r– : 代表赋予用户组的权限 — : 代表赋予其他人的权限 软链接 类似 Windows快捷方式，不决定原文件的权限，只是符号链接 三种用户都有所有权限 rwx ， 文件为 l 开头 ，文件大小较小 硬链接 相当于拷贝 cp -p（保留属性） + 同步更新 一个i节点对应到了两个文件 注意 ： 硬链接不能跨分区 ，而且不能针对目录使用文件操作 r(读) w(写) x(执行) 文件覆盖 y Linux命令 命令格式 命令 -选项 -参数 例子 ： ls -la /etc命令的选项可以同时使用，且不分顺序 文件命令 作用 英文 ls 目录处理命令 list ls -a 查看目录所有文件（含隐藏文件） 可以添加目录参数 ls -l 查看文件的详细信息 ls -lh 人性化显示文件信息 ls -ld /etc 只示目录本身的信息 ls -i 查看文件的i节点 （即为文件的id信息） 目录命令 英文 作用 mkdir make directories 创建新目录 mkdir -p 递归创建新目录，并且在新目录在再进行创建，可同时创建多个 cd change directories 切换目录 . 代表当前目录 ..回到上一级目录 pwd print working directories 显示当前工作目录 rmdir remove directories 删除空目录 cp copy 拷贝目录或文件 cp -rp [原文件或目录] [目标目录] r为复制目录操作 p为保留文件属性 可以同时复制多个 mv move 目录剪切 移动 mv [绝对路径] [目标路径] 若是要剪切当前路径下的文件 可以直接 mv [文件名] [目标目录] rm remove 删除文件或名录 要慎重 rm -f 强制删除 rm -r 删除目录 rm -rf 直接删除目录 文件处理 作用 例子 touch 创建空文件 touch /root/book.list cat 浏览文件内容 可以加 -n 参数 cat -n /etc/issue tac cat 的倒序显示可以倒序显示文件内容 more 分页显示文件，适合查看长文件 less 分页浏览 head 查看文件的前n行,默认为10行 head -n 8 tail 查看文件的末尾n行 tail -f /var/log/message 动态显示问文件 链接处理 作用 例子 ln /etc/issue /tmp 默认创建硬链接 ln -s 软连接 注意事项: touch 若要创建带空格文件名的文件，可touch &quot;my love&quot;,即加上双引号 最好不要在Linux中创建带有特殊符号的文件名 cat 不太适合浏览含有非常多内容的文件 more 按 空格 ： 一页一页浏览 按 回车 ： 一行一行浏览 按 q : 退出浏览 less 可以倒回去浏览内容 pageup : 一页一页往回翻 上箭头 : 一行一行往回翻 /service ： / 斜杠可以用来搜索，按 n 可以翻看下一页 注意 cp -p 该属性可以保持复制文件或目录的信息，如创建和修改的时间等 cp -r 可以在复制文件或目录时，将文件名进行修改 mv 当前目录下的文件名 要修改成的名字 可以作为文件名修改命令 注意事项目录：/proc/ /sys/ : 为系统内存和内核，只可读，写入的数据在重启时会清除，不要往内写入文件 /tmp : 临时目录，存放临时文件，建议不要存放重要文件，重启时最好清除 /var : 动态数据保存位置，注意保存缓存，日志已经软件运行产生的文件 /usr : 系统软件资源目录，为“Unix Software Resource”的缩写，用于存放系统软件资源的目录，系统安装的软件资源基本存放在此目录 服务器： 远程服务器不允许关机，只能重启 重启时应该关闭服务 不要在服务器访问高峰运行高负载命令 ，如对大数据的处理 远程配置防火墙（过滤作用）时，不要把自己踢出服务器 其他： 指定合理的密码规范并定期更新 合理分配权限 – 用户的权限越少越好 定期备份重要数据与日志，多处存储 Linux命令若未指定目录，则默认在当前目录里执行操作]]></content>
      <categories>
        <category>Linux基础</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Spider]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%88%AC%E8%99%AB%2FCrawler_02%2F</url>
    <content type="text"><![CDATA[[TOC] 1.爬取网页 response属性读取数据 1.读取文件的全部内容，会把读取到的数据赋值给一个列表 data = response.readlines()2.读取文件的全部内容，会把读取到的数据赋值给一个字符串 data = response.read() 读取文件的一行data = response.readline()4.encode 将我们看得懂得东西变为看不懂得东西_ decode 将我们看不懂得东西变为看得懂得东西返回当前环境的有关信息data = response.info() 返回状态码data = response.getcode()if response.getcode() ==200 or response.getcode() ==304 返回正在爬取的URL地址data = response.geturl() 编码(解码)，将url中的汉字编码转化为汉字 url=&quot;http://***&quot; newurl = urllib.request.(un)quote(url) 有时候内容编码是Unicode的格式，则需要对其进行编码再解码 content.encode(&#39;latin-1&#39;).decode(&#39;unicode_escape&#39;) 改进 decode(“utf-8”,”ignore”) 2.将网页存取到指定文件中import urllib.requesturllib.request.urlretrieve(&quot;url&quot;,filename=r&quot;存取的文件地址&quot;) 注意:urlretrieve在执行的过程中会产生一些缓存，清除缓存如下操作urllib.request.urlcleanup() 3.模拟浏览器利用User-Agent，添加headers,使得模拟更加真实1234567891011import urllib.requesturl = " "headers = &#123;"User-Agent":" "&#125;#设置一个请求体,构建请求对象req = urllib.request.Request(url,headers=headers)#发起请求response = urllib.request.urlopen(req)data = response.read().decode("utf-8")print (data) 1234567891011#保持模拟浏览器登陆状态--cookies#post请求一般应用在登陆#为保证持续模拟登陆，则需要处理好cookiesreq_attr = urllib.request.Request(url=url,data=encode_data,headers=headers)response_attr = urllib.request.urlopen(req_attr)#read().decode("gbk")#print (response)#获取登陆后获取的响应头，处理相应的cookies以保持登陆状态print(response_attr.headers)#比较两个cookies的不同，将浏览器响应头修改为服务器登陆响应头 123456789101112# 为防止被封IP可以将多个Agent做成列表，多次变换agentlist = ["","",""]agentstr = random.choice(agentlist)req =urllib.request.Request(url)#向请求体里添加了User-Agentreq.add_header("User-Agent",agentstr)response =urllib.request.urlopen(req)print (response.read().decode("utf-8")) - 请求url的错误处理，防止无法请求url而影响程序12345678import requests.exceptions import RequestExceptiondef page_state(rep): try: if rep.status_code == 200: # 如果状态码正常，则返回url的内容 return rep.text return None except: return None 4.设置超时&amp;间隙时间12345678910#在使用urllib或者urllib2时，有可能会等半天资源都下载不下来，#可以通过设置socket的超时时间，来控制下载内容时的等待时间。#如下python代码import sockettimeout = 20socket.setdefaulttimeout(timeout)#这样默认20秒之后就会超时。 123456789101112import urllib.requestimport timetime.sleep(10)#如果网页长时间未反应，系统判断超时for i in range(1,100): #循环次数 try: response = urllib.request.urlopen( "http://www.baidu.com",timeout = 0.5) print (len(response.read().decode("utf-8"))) except: print ("请求超时，继续下一个爬取") 5.HTTP请求1234567891011121314151617181920212223'''使用场景：进行客户端与服务器之间的消息传递时使用Get :通过URL网址传递信息，可以直接在URL地址上传递信息Post :可以向浏览器提交数据，时一种比较流行的比较安全的数据传递。 如密码等,但速度慢Put ：请求服务器存储一个资源，通常要指定存储的位置Delete ：请求服务器删除一个资源Head ：请求获取对应的HTTP报头信息Options :可以获取当前URL所支持的请求类型''' #对于一些既有post请求,又有get请求的网页 #get请求的参数在url地址中 #post请求的参数需要我们单独传递数据，对数据进行编码import urllib.parse #创建请求体的参数内容headers = &#123;&#125;post_data = &#123;&#125; #利用urllib.parse对post_data进行处理 #data参数如果要传必须传bytes（字节流）类型的 #如果是一个字典，先用urllib.parse.urlencode()编码。encode_data = urllib.parse.urlencode(post_data).encode("utf-8")req = urllib.request.Request(url=url,data=encode_data,headers=headers) Https请求123#抓取HTTPS协议import sslssl._create_default_https_context = ssl._create_unverified_context 6.抓取网页动态Ajax请求的数据12345678import ssl #抓取https协议的网页req = urllib.request.Request(url,headers=headers) #使用ssl创建未验证的上下文context = ssl._create_unverified_context()response = urllib.request.urlopen(req.context=context)jsonstr = response.read().decode("utf-8")jsondata = json.loads(jsonstr) 12# 动态数据，在 js文件中有真正的请求url# 爬取静态与动态网页通法 1.建立需求 源代码中没有我们需要的数据原因： 1.Ajax异步加载 ：通过多个请求获取数据（通过XHR筛选出Ajax加载的数据） 2.数据加密 7.保存文件，数据持久化123456789import requestsurl = " "headers = &#123; "User-Agent":" "&#125;response = requests.get(url,headers=headers)with open("demo.zip","wb") as f: #以二进制形式打开文件 f = write(url.content) 1234import os# 导入os模块，为爬取的文件新建文件夹，可进行分类保存os.mkdir("文件夹名称")]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_cookbook]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython%E7%90%86%E8%AE%BA%2Fcookbook%2F</url>
    <content type="text"><![CDATA[解决方案 12345678from collections import deque#deque(maxlen=N)创建一个固定长度的队列#当有新记录加入而队列已满时会自动移除最老的那条记录q = deque(maxlen=3)q.appendleft()q.popleft()#创建无限序列q = deque() 123456789101112131415#寻找集合中最大或最小的N个元素# nlargest(),nsmallest()import heapqnums=[1,8,2,23,7,-4,18,23,42,37,2]print(heapq.nlargest(3,nums)) #print [42,37,23]#将集合转换为堆,堆的特性为heap[0]总是最小的那个元素nums=[1,8,2,23,7,-4,18,23,42,37,2]import heapqheap = list(nums)heapq.heapify(heap)#去除heap中最小值heap.heappop(heap)#插入元素heap.heappush()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Web_Pyquery]]></title>
    <url>%2F2018%2F07%2F25%2FPython%2FPython_Web%2FPyQuery%2F</url>
    <content type="text"><![CDATA[PyQueryclass – .id – # 初始化1、字符串的初始化123456789101112131415from pyquery import PyQuery as pqhtml = '''&lt;div&gt; &lt;ul&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = pq(html)print(doc)print(type(doc))# 提取li标签内所有内容print(doc('li')) 2、URL初始化123from pyquery import PyQuery as pqdoc = pq(url=" ")print(doc("li")) 3、通过文件初始化123from pyquery import PyQuery as pqdoc = pq(filename='demo.html')print(doc('li')) CSS选择器1234567891011121314from pyquery import PyQuery as pqhtml = '''&lt;div&gt; &lt;ul id = 'haha'&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;'''doc = pq(html)print(doc)# id等于haha下面的class等于item-0下的a标签下的span标签#（注意层级关系以空格隔开）print(doc('#haha .item-0 a span')) 查找子标签123456789101112131415161718from pyquery import PyQuery as pqhtml = '''&lt;div&gt; &lt;ul id = 'haha'&gt; &lt;li class="item-0"&gt;first item&lt;/li&gt; &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;''' doc = pq(html) items = doc('.list') # 寻找同时含有Item-0和active属性的list内的标签 # 其中item-0与active并列 itema = doc('.list .item-0.active') print(type(items)) list = items.find('li') print(list) # 查找含有active子元素的标签 lis = items.children('.active') 兄弟元素 1234li = doc('.list .item-0.active')print(li.siblings())# 可再次筛选print(li.siblings('.active'))]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python_web</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F25%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[代码命令 代码 作用 input type=”text” name=”username” value=”” 输入账号 input type=”text”name=”password” value=”” 输入密码 input type=”submit” 提交查询按钮 input type=”reset” 重置]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F25%2FREADME%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F07%2F25%2FGit%2FGithub%2F</url>
    <content type="text"><![CDATA[搜索仓库文件快捷键：T]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hacker_Techo]]></title>
    <url>%2F2018%2F07%2F21%2FHacker%2FHacker-Techo%2F</url>
    <content type="text"><![CDATA[专业术语 脚本 (asp、 php、 jsp) html (css、 js、 html) HTTP协议 CMS (B/S) MD5 肉鸡 ： 被黑客入侵并长期驻扎的计算机或服务器 抓鸡 ： 利用使用量大的程序的漏洞，使用自动化方式获取肉鸡的行为 Webshell : 通过 Web 入侵的一种脚本工具，可以据此对网站服务进行一定程度的控制 漏洞 ： 硬件、软件、协议等可利用安全缺陷，对数据进行篡改、控制等 提权 ： 操作系统低权限的账户将自己提升为管理员权限使用的方法 后门： 黑客为对主机进行长期的控制，在机器上种植的一段程序或留下的一个”入口” 跳板 ： 使用肉鸡IP来实施攻击其他目标，以便更好的隐藏自己的身份信息 旁站 ： 对于一个大的服务器，可以供多个网站使用 旁站入侵 ： 同服务器下的网站入侵，可以通过提权跨目录等手段拿到目标网站的权限。 常见旁站查询工具： WebRoot、御剑、明小子、Web在线查询等。 C段入侵 ： 同C段下服务器入侵。如目标Ip为192.168.1.253入侵192.168.1.*的任意一台机器，然后借助一些黑客工具嗅探获取网络上传输的各种信息。 常见工具： Cain (windows) 、 Sniffit、Snoop、Tcpdump、Dsniff(Unix) 渗透测试 黑盒测试 ： 在未授权的情况下，模拟黑客的攻击方法和思维方式，来评估计算机网络系统可能存在的安全风险 黑盒测试不同于黑客攻击，并不等于黑站。黑盒测试考验的是综合的能力 (OS,Database,Script,code,思路,社工) 思路和经验积累往往决定成败 黑白盒 ： 知道源代码和不知道源代码的渗透测试 黑盒测试为传统的渗透测试，而白盒测试偏向于代码审计 渗透测试与入侵的区别 渗透测试：更全面的找出服务器的问题，倾向于保护 入侵：不择手段的拿到权限 黑客攻击 DDoS 攻击 ： 分布式拒绝服务攻击 (distributed denial-of-service attack) 缺陷： 无法贡献系统 DNS污染 ： DNS (Domain Name System 域名系统) Poisoning 小结 木马： 通过向服务端提交一句简短的代码，配合本地客户端，实现webshell功能的木马 12&lt;%eval request("pass")%&gt;&lt;%execute(request("pass"))%&gt; 解释 request(“pass”) ： 接收客户端提交的数据， pass 为执行命令的参数值 eval/execute : 函数执行客户端命令的内容 黑客之路 一隐写术步骤 准备一个文件 ,如 test.txt (test.txt是需要被隐藏的文件) 将其压缩为zip , 或 rar,直接重命名 打开命令终端，将压缩文件定向到需要被隐写的文件 (可选操作)将被隐写的文件的拓展名修改为 .zip 作用 将test.txt文件定向隐藏至hide.png文件下，即点击图片，其实打开的是test.txt 代码 cat test.txt.zip &gt;&gt; hide.png]]></content>
  </entry>
  <entry>
    <title><![CDATA[Big_Data]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%2FBig-Data%2F</url>
    <content type="text"><![CDATA[大数据 搭配LINUX环境 创建 /usr/local/hadoop 文件夹 下载hadoop，并解压 安装 JDK 环境 生成无密公钥 ssh-keygen -t dsa -P &#39;&#39; -f ~/.ssh/id_dsa 将公钥id_dsa.pub 添加进keys ,保证无密码登录cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys 验证是否成功 ： ssh localhost (第一次登录有询问) 解释 dsa 为生成的密钥类型 -P 为密码 ‘’ 表示无密码 -f 后面为生成要保存的位置 Java1234567891011121314151617181920212223package com.itstar.util;/** * 大数据文件批量检索(豆瓣电影影评)数据抓取核心工具类 * @author * @version v1.0 */public class DataDownUtil &#123; // java 入口 public static void main(Sring[] args)&#123; System.out.println("java爬虫"); &#125;&#125;// 1. 根据网址和页面的编码集获取网页的源代码// 2. 解析源代码，批量采集我们需要的影评数据// 3. 将文字信息转换成文本文件，储存在服务器中// 4. 同步到分布式文件系统中// 5. 计算、处理、可视化public static String getHtmlResource(String url, String encoding)&#123; // 建立网络链接 URL urlObj = new URL(url);&#125; 数据概念大数据是由结构化和非结构化数据组成的 10%的结构化数据，储存在数据库中 90%的非结构化数据，它们与人类信息密切相关 HDFS的底层原理：代理对象与RPCHive什么是Hive？Hadoop : 大数据的第一个框架 框架 作用 HDFS 存储 MapReduce 计算 YARN 调度 解释 ： Hive 是基于 Hadoop 的一个数据仓库工具，可以将结构化(行对行、列对列)的数据文件映射为一张表，并提供一种类SQL(HQL)的功能 优缺点 优点 提供了SQL的查询，提供快速开发的能力 避免了去写 MR(MapReduce)，减少开发人员成本 底层实现是 MR 适合处理大数据量，对于小数据量没有优势，延迟高 缺点 数据挖掘领域不擅长 效率相对较低，MR 不够智能 调优比较困难 Hive 的架构原理Hive 原理架构 Meta store ==&gt; derby | mysql Driver : 解析器 、 编译器 、 优化器 、 执行器 MapReduce HDFS Hive 与数据库比较 查询语言 HQL 与 SQL 、 自定义函数 (UDF、UDAF、UDFF) 数据的储存位置 Hive 存在HDFS 中 数据库： 本地文件系统中、块设备 数据更新 Hive 内容 读多写少 数据库： 增删改查 执行 和 执行延迟 扩展性 Hive 比 Mysql 强 Hive 的数据类型 基本数据类型 Hive 的数据类型 Java 数据类型 Tinyint byte SMALINT short INT int BIGINT long BOOLEAN boolean FLOAT float DOUBLE double STRING string TIMESTAMP 时间类型 BINARY 字节数组 集合数据类型 STRUCT 、 MAP 、 ARRAY 类型转换 和 Java 的类型转换一致，如果是 低 -&gt; 高 自动转 DDL数据定义与DML数据操作小范例 MAP : kv 结构 STRUCT : 不单单只是类型，而且还有类型名 建表语句： Json 格式 1234567891011create table test( name string, friends array&lt;string&gt;, children map&lt;string, int&gt;, address struct&lt;street:string, city:string&gt;)row format delimited fields terminated by "," -- 列分隔符collection items terminated by "_" -- MAP STRUCT 和 ARRAY 的分隔符map keys terminated by ":" -- MAP 中的 key 和 value 的分隔符lines terminated by "n"; --行分隔符 数据操作1. 创建数据库： create database if not exists db_hive; // 默认路径： /user/hive/warehouse create database if no exists jedieal location &apos;/jedieal.db&apos;; // 使用 location 指定路径 2. 修改数据库： alter database jedieal set dbproperties(‘create’=’20180724’); // 加上创建时间，即自定义的元数据(记录了数据的相关信息) desc database extended jedieal; 3. 查询数据库： show database; show database like ‘db_hive*’; 4. 删除数据库： drop database db_hive; 5. 创建数据表： 普通创建表123456create table if not exists student (id int, name string)row format delimited fields terminated by '\t'stored as textfilelocation '/user/hive/warehouse/student' 根据查询结果创建表 (查询的结果会添加搭配新建的表中) `create table if not exists student as select id, name from student;` 根据已经存在的表结构创建表 create table if not exists emp like emp1; Table Type MANAGED_TABLE 内部表 EXTERNAL_TABLE 外部表 外部表与内部表的区别： 删内 ： 会把表结构和表里的数据都删除 删外 ： 只会删除表结构、不会删除表数据 drop table 表名; 6. 分区数据表：12345create external table dept_partition_external (deptno int, dname string, loc string)partitioned by (month string)row format delimited fields terminated by '\t'; 分区及分文件夹 分桶及文件 修改数据表： 删除数据表： 企业级优化Fetch 抓/hive.fetch.task 三个： more minimal none123set hive.fetch.task.conversion=none;set hive.fetch.task.conversion=more; 本地模式12345678#开启本地 MRset hive.exec.mode.local.auto=false;#设置文件大小的最大值set hive.exec.mode.local.auto.inputbytes.max=50000000;#文件个数set hive.exec.mode.local.auto.input.files.max=10; 查询分桶表：select * from emp cluster by deptno; 严格模式1234select * from emp;set hive.mapred.mode = nonstrict (默认)select * from ori_partitioned_target where p_time = '20111230000010'; SQL操作select * from db where ; : 从 db 中查看所有数据, where 为条件查询]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习]]></title>
    <url>%2F2018%2F07%2F12%2F%E5%89%8D%E7%AB%AF%2FCSS%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSS入门学习 CSS 基础CSS 语法CSS定义方式 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 selector {declaration1; declaration2; ... declarationN } CSS 值的写法例 123456789p &#123; color: #ff0000; &#125;p &#123; color: #f00; &#125;p &#123; color: rgb(255,0,0); &#125;p &#123; color: rgb(100%,0%,0%); &#125;p &#123;font-family: "sans serif";&#125; 多重声明 1234567body &#123; color: #000; background: #fff; margin: 0; padding: 0; font-family: Georgia, Palatino, Serif; &#125; 注意 是否包含空格不会影响 CSS 在浏览器的工作效果， 同样，与 XHTML 不同，CSS 对大小写不敏感。不过存在一个例外：如果涉及到与 HTML 文档一起工作的话，class 和 id 名称对大小写是敏感的 CSS 高级语法 根据 CSS，子元素从父元素继承属性.通过 CSS 继承，子元素将继承最高级元素（在本例中是 body）所拥有的属性（这些子元素诸如 p, td, ul, ol, ul, li, dl, dt,和 dd）。对于部分旧式浏览器,它不仅忽略继承，而且也忽略应用于 body 元素的规则。 解决 1234567body &#123; font-family: Verdana, sans-serif; &#125;p, td, ul, ol, li, dl, dt, dd &#123; font-family: Verdana, sans-serif; &#125; 如果不想使某些子类继承父类的属性，可以针对该子类单独设置其属性 1234567body &#123; font-family: Verdana, sans-serif; &#125;p &#123; font-family: Times, "Times New Roman", serif; &#125; CSS派生选择器 派生选择器可以使得根据文档的上下文关系来确定某个标签的样式。通过合理地使用派生选择器，可以使 HTML 代码变得更加整洁。 如将列表中的 strong 元素变为斜体字，可以定义一个派生选择器 123li strong &#123; font-style: italic;&#125; 更多例子 123456h2 strong &#123; color: blue; &#125;strong &#123; color: red;&#125; CSS id 选择器 id选择器可以为标有特定id的HTML元素指定特定的样式 使用 “#”定义 注意 id 属性只能在每个 HTML 文档中出现一次。 一个选择器，多种用法&gt; 即使被标注为 sidebar 的元素只能在文档中出现一次，这个 id 选择器作为派生选择器也可以被使用很多次：12345678#sidebar p&#123; font-style: italic; text-align: center;&#125;#sidebar h&#123; font-size: lem; margin: 0;&#125; 单独的选择器&gt;id 选择器即使不被用来创建派生选择器，它也可以独立发挥作用1234#sidebar &#123; border: 1px dotted #000; padding: 10px; &#125;### CSS 类选择器示例：123.center &#123; text-align: center;&#125;&gt; HTML 中类可以使用多次h1 和 p 元素都有 center 类。这意味着两者都将遵守 “.center” 选择器中的规则。1234567&lt;h1 class="center"&gt;This heading will be center-aligned&lt;/h1&gt;&lt;p class="center"&gt;This paragraph will also be center-aligned.&lt;/p&gt;注意：:类名的第一个字符不能使用数字！### CSS 属性选择器先来看几个例子1. 将所有含有title属性的元素设置颜色123456&lt;style type="text/css"&gt; [title]&#123; color: blue;&#125;&lt;/style&gt;2. 将含有 title 为 keithxodoy 的元素设置颜色123456&lt;style type="text/css" &gt;[title=keithxodoy]&#123; color: blue;&#125; &lt;/style&gt;3. 将含有 title 内容包含 hello 的元素设置颜色 适用于由空格分隔的属性值title=&quot;hello keithxodoy&quot;123456&lt;style type="text/css"&gt;[title~=hello]&#123; color: blue;&#125;&lt;/style&gt; 适用于由连字符分隔的属性值title=&quot;hello-keithxodoy123456&lt;style type="text/css" &gt;[title|=hello] &#123; color: blue;&#125;&lt;/style&gt;其余用法| 选择器 | 功能 ||——–|—–|| [attribute^=value] | 匹配属性值以指定值开头的每个元素|| [attribute$=value] | 匹配属性值以指定值结尾的每个元素|| [attribute=value] | 匹配属性值中包含指定值的每个元素|## CSS 创建样式表### 外部样式表&gt; 背景 ： 当页面所需的css样式过多，而且大多是重复相同的样式时，不易在HTML文件中单独呈现，于是使用 link标签，将外部的一个 css 文件引入至 HTML 中123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="style_set.css" /&gt;&lt;/head&gt;注意:最好不要再属性值和单位之间留有空格，否则会在一些浏览器中无法正常工作### 内部样式表&gt; 背景 ： 当某个文档需要特殊样式时，适合使用内部样式表1234567&lt;head&gt;&lt;style type="text/css"&gt; p &#123; margin-left: 20px; &#125;&lt;/style&gt;&lt;/head&gt;### 内联样式&lt;p style=&quot;color: sienna; margin-left: 20px&quot;&gt;### 背景### 背景色使用 background-color 设置背景色&gt; background-color 不能继承，默认值 transparent 透明### 背景图像使用background-image设置背景图像实例：body {background-image: url(/1.png);}&gt; background-image 不能继承,但是可以为段落、行内元素设置背景### 背景重复&gt;如果需要在页面上对背景图像进行平铺，可以使用 background-repeat 属性。属性值repeat1. repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复2. no-repeat 则不允许图像在任何方向上平铺。示例：12345body &#123; background-image: url('i.png'); background-repeat: repeat-x;&#125;### 背景定位&gt;可以利用 background-position 属性改变图像在背景中的位置。示例：123456p&#123; background-image: url('i.png'); background-repeat: repeat-x; background-position: center;&#125;|位置关键字||——–||center ||top||bottom||right ||left|&gt;同时 background-postion 也可以使用 长度值，百分数值 设置12345body&#123; background-position: 50% 50%; background-position: 50px 50px;&#125;### 背景关联&gt;如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。可以通过 background-attachment 属性防止这种滚动,使图像相对可视区为固定的实例：12345body&#123; background-image: url('i.png'); background-attachment: fixed;&#125;注意:background-attachment 属性的默认值是 scroll，即在默认的情况下，背景会随文档滚动### 总结&gt;可以将所有的 CSS背景属性写在一个申明中123456&lt;style type="text/css"&gt;body&#123; background: #ff0000 url(/i.png) repeat-x center fixed ; &#125;&lt;/style&gt;—## CSS 文本### 缩进文本 text-indent&gt; 通过使用 text-indent 属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值示例：将所有段落的首行缩进 5em:12345p &#123;text-indent: 5em;&#125;p &#123;text-indent: -5em;&#125;p &#123;text-indent: 20%;&#125;注意：1. 一般来说，可以为所有块级元素应用 text-indent，但无法将该属性应用于行内元素，图像之类的替换元素上也无法应用 text-indent 属性。2. 如果一个块级元素(比如段落)的首行中有一个图像，它会随该行的其余文本移动。3. 对于行内元素的第一行“缩进”，可以使用设置左内边距或外边距创造。4. text-indent 属性可以继承### 水平对齐 text-align&gt; text-align 是一个基本的属性，它会影响一个元素中的文本行互相之间的对齐方式。示例：中间对齐1p &#123;text-align: center;&#125;注意：text-align:center 与 &lt;CENTER&gt;区别是&lt;CENTER&gt; 不仅影响文本，还会把整个元素居中;而text-align 不会控制元素的对齐，而只影响内部内容。### 字间隔 word-spacing &amp; 字母间隔 letter-spacing#### 字间隔 word-spacing&gt; word-spacing 属性可以改变字（单词）之间的标准间隔。其默认值 normal 与设置值为 0 是一样的。word-spacing属性接受一个正长度值或负长度值。如果提供一个正长度值，那么字之间的间隔就会增加。为 word-spacing 设置一个负值，会把它拉近示例：设置文本之间距离为负值12p.spacing &#123; word-spacing: -0.5em;&#125;#### 字母间隔 letter-spacing&gt;letter-spacing 属性与 word-spacing的区别在于，字母间隔修改的是字符或字母之间的间隔。示例：设置字母间的间隔123456h1 &#123; letter-spacing: -0.5em;&#125;h2 &#123; letter-spacing: 20px;&#125;### 字符转换| 属性值| 作用||——-|—-|| none | 不对文本做任何改动|| uppercase | 文本转换为全大写|| lowercase | 文本转换为全小写|| capitalize| 每个单词的首字母大写|### 文本装饰| 属性值 | 作用 ||——-|——|| none | 不做处理，也可以使超链接的下划线去除 || underline | 加下划线|| overline | 在文本顶端画一个上划线| line-through | 在文本中间画一个贯穿线|| blink | 使得文本闪烁|注意:可以在一个规则中结合多种装饰,但如果两个不同的装饰都与同一元素匹配，胜出规则的值会完全取代另一个值### 处理空白符 white-space&gt; white-space 属性会影响到用户代理对源文档中的空格、换行和 tab 字符的处理,即各个字之间只会显示一个空格，同时忽略元素中的换行 normal属性示例： 显式设置默认行为，即去除多余空格与换行123p &#123; white-space: normal;&#125; pre属性示例： 浏览器保留额外的空格回车123p &#123; white-space: pre;&#125;注意：:IE 7 以及更早版本的浏览器不支持该值 nowrap属性示例：nowrap会防止元素中的文本换行，除非使用了一个 br 元素123p &#123; white-space: nowrap;&#125;## CSS 样式### CSS 字体#### 5 种通用字体系列： Serif 字体 Sans-serif 字体 Monospace 字体 Cursive 字体 Fantasy 字体 font-family 属性 ： 定义文本的字体系列1body &#123;font-family: sans-serif;&#125;&gt; 注意：只有当字体名中有一个或多个空格（比如 New York），或者如果字体名包括 # 或 $ 之类的符号，才需要在 font-family 声明中加引号#### 字体风格font-style 属性最常用于规定斜体文本。该属性有三个值： normal - 文本正常显示 italic - 文本斜体显示 oblique - 文本倾斜显示&gt; 注意： 斜体（italic）是一种简单的字体风格，对每个字母的结构有一些小改动，来反映变化的外观。与此不同，倾斜（oblique）文本则是正常竖直文本的一个倾斜版本#### 字体加粗font-weight 属性设置文本的粗细。使用 bold 关键字可以将文本设置为粗体。关键字 100 ~ 900 为字体指定了 9 级加粗度。如果一个字体内置了这些加粗级别，那么这些数字就直接映射到预定义的级别，100 对应最细的字体变形，900 对应最粗的字体变形。&gt; 数字 400 等价于 normal，而 700 等价于 bold#### 字体大小font-size 属性设置文本的大小。font-size 值可以是绝对或相对值。绝对值： 将文本设置为指定的大小 不允许用户在所有浏览器中改变文本大小（不利于可用性） 绝对大小在确定了输出的物理尺寸时很有用相对大小： 相对于周围的元素来设置大小 允许用户在浏览器改变文本大小注意：如果您没有规定字体大小，普通文本（比如段落）的默认大小是 16 像素 (16px=1em)12body &#123;font-size:100%;&#125;h1 &#123;font-size:3.75em;&#125;—### CSS 的链接#### 链接样式 a:link - 普通的、未被访问的链接 a:visited - 用户已访问的链接 a:hover - 鼠标指针位于链接的上方* a:active - 链接被点击的时刻，即正在被点击的链接实例：12345678&lt;head&gt; &lt;style&gt; a:link &#123;color:#FF0000;&#125; /* 未被访问的链接 */ a:visited &#123;color:#00FF00;&#125; /* 已被访问的链接 */ a:hover &#123;color:#FF00FF;&#125; /* 鼠标指针移动到链接上 */ a:active &#123;color:#0000FF;&#125; /* 正在被点击的链接 */ &lt;/style&gt;&lt;/head&gt;注意 a:hover 必须位于 a:link 和 a:visited 之后 a:active 必须位于 a:hover 之后 常见链接样式 text-decoration ： 多用于除去链接的下划线 实例：1a:link &#123;text-decoration: none;&#125; background-color : 设定链接的背景色 实例：1a:hover &#123;background-color: #FFFF85;&#125; font-size : 改变链接的字体大小 实例： 设置鼠标悬停在链接上的字体大小变化1a:hover &#123;font-size: 150%;&#125; font-family : 改变链接字体 实例：修改链接字体为微软雅黑1a:link &#123;font-family: '微软雅黑';&#125; font-weight : 设置字体的厚度 实例：1a:active &#123;font-weight: bold;&#125; 高级示例 本例来设置创建链接框 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;test&lt;/title&gt; &lt;style&gt; a:link , a:visited &#123; color: white; background-color: black; display: block; text-align: center; text-decoration: none; font-weight: bold ; width: 120px; padding: 10px; &#125; a:hover , a:active &#123; color: orange; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href="http://www.baidu.com"&gt;百度一下&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; CSS列表无序列表的样式 在一个无序列表中，列表项的标志 (marker) 是出现在各列表项旁边的圆点 修改： 间无序列表的圆点改为方形123ul &#123; list-style-type: square&#125; 任意列表的样式 将列表的标志改为图像 123ul li &#123; list-style-image: url(test.gif)&#125; 使用url来引入图像为标志]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%89%8D%E7%AB%AF%2FPHP%2F</url>
    <content type="text"><![CDATA[PHP入门 What is PHP??? PHP是一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入HTML中使用 是一种创建动态交互性站点的强有力的服务器端脚本语言 PHP： Hypertext Preprocessor –超文本预处理器 DNS DNS (Domin Name System 域名系统) ： 因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能使用户更方便的访问互联网 域名解析 用户通过主机名，最终得到该主机名对应的 IP 地址的过程 步骤： 用户输入域名 localhost –&gt; DNS (localhost 127.0.0.1) –&gt; 服务器电脑 PHP基本语法 php脚本可以放置在文档任意位置 123&lt;?php// PHP代码?&gt; 文本输出命令echo &amp; print 输出字符串可以包含HTML标签 echo 语句echo - 可以输出一个或多个字符串 echo 输出样式 12345678&lt;?php$txt = "学习PHP"；$arr = array('Jan', 'Ame', 'Chi');echo $txt;echo "我要 $txt";echo "想去的国家&#123;$arr[1]&#125;";?&gt; print 语句print - 只允许输出一个字符串，返回值为 1 如果字符串成功显示则返回true，否则返回false。 12345678&lt;?php$txt = "学习PHP"；$arr = array('Jan', 'Ame', 'Chi');print $txt;print "我要 $txt";print "想去的国家&#123;$arr[1]&#125;";?&gt; 比较 echo 输出速度比 print 快，echo 无返回值， print 返回值为 1 print $a 和 print &quot;$a&quot; 效果相同，echo 同理 print &quot;text$a text&quot; 和 print &quot;text $a text&quot; 和 print &quot;text{$a}text&quot; 都可以正常显示 $a 的值，不使用 {} 则 &amp;a 之后必须有一个空格，echo 同理 文本注释123456789&lt;?php// PHP单行注释/*PHP多行注释*/?&gt; 须知 PHP中每个代码行必须以分号结束，以使指令集区分开来 PHP变量 PHP为一门弱类型语言，不必向 PHP 声明该变量的数据类型。 PHP 会根据变量的值，自动把变量转换为正确的数据类型。 1234567&lt;?php$x=5;$y=6;$z=$x+$y;$txt="Hello,World!"echo $z;?&gt; 规则 变量以 $ 符号开始，后面跟着变量的名称 变量名不能包含空格 变量名是区分大小写的（$y 和 $Y 是两个不同的变量） PHP变量作用域 PHP 有四种不同的变量作用域： local global static parameter 局部与全局作用域 实例：12345678910111213141516171819&lt;?php $x=5; // 全局变量 function myTest() &#123; $y=10; // 局部变量 echo "&lt;p&gt;测试函数内变量:&lt;p&gt;"; echo "变量 x 为: $x"; echo "&lt;br&gt;"; echo "变量 y 为: $y"; &#125; myTest(); echo "&lt;p&gt;测试函数外变量:&lt;p&gt;"; echo "变量 x 为: $x"; echo "&lt;br&gt;"; echo "变量 y 为: $y"; ?&gt; global全局变量 函数内访问全局变量需要 global 关键字或者使用 $GLOBALS[index] 数组 global $x,$y; 123456789&lt;?php$x=5;$y=10;function mytest()&#123; $GLOBALS['y']=$GLOBALS['x']+$GLOBALS['y'];&#125;?&gt; 注意 在 php 中函数是有独立的作用域，所以局部变量会覆盖全局变量 Static作用域 当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除 123456function myTest()&#123; static $x=0; echo $x; $x++;&#125; 每次调用该函数时，该变量将会保留着函数前一次被调用时的值,且该变量仍然是函数的局部变量。 参数作用域 参数是通过调用代码将值传递给函数的局部变量,并且在参数列表中声明的:function mytest($x) PHP 字符串变量实例： 创建一个 txt 的字符串变量1234&lt;?php$txt="Hello World!";echo $txt;?&gt; PHP 并置运算符 . 在 PHP 中，只有一个字符串运算符。 并置运算符 (.) 用于把两个字符串值连接起来。 实例：12345&lt;?php$txt1="Hello";$txt2="World";echo $txt1 . " " . $txt2;?&gt; 字符串函数 strlen(&quot;string&quot;):返回字符串的长度 mb_strlen(&quot;字符串&quot;,&quot;utf-8&quot;): 设置指定编码输出中文字符个数 strpos(&quot;string&quot;,&quot;str&quot;):在字符串内查找一个字符或一段指定的文本的位置，若未找到匹配，则返回 FALSE PHP 常量 常量是一个简单值得标识符，不可以在脚本中改变 设置PHP常量语法 bool define ( string $name , mixed $value [, bool $case_insentitive = false ]) 解释 name：必选参数，常量名称，即标志符 value：必选参数，常量的值 case_insensitive：可选参数，如果设置为TRUE，该常量则大小写不敏感。默认是大小写敏感的 示例：12345&lt;?php//不区分大小写的常量define("Hello", "Keithxodoy", True);echo Hello;?&gt; 注意事项 常量在定义后，默认是全局变量，可在任意脚本中使用 PHP EOF (heredoc) PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。 PHP 定界符 EOF 的作用就是按照原样，包括换行格式什么的，输出在其内部的东西 1234567&lt;?phpecho &lt;&lt;&lt;EOF &lt;h1&gt;标题&lt;/h1&gt; &lt;p&gt;段落&lt;/p&gt;EOF;// 结束需要独立一行且前后不能空格?&gt; 1. 以 &lt;&lt;&lt;EOF 开始标记开始，以 EOF 结束标记结束，结束标记必须顶头写，不能有缩进和空格，且在结束标记末尾要有分号2. EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。3. 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。4. 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义。5. 在 heredoc 中，变量不需要用连接符 . 或 , 来拼接 补充:PHP_EOL 是一个换行符，兼容更大平台 PHP 数据类型 String Integer Float Boolean Array Object Null 示例1234567891011121314&lt;?php$x = "Hello ,world!";$y = 520;$z = 52.1;$a = True;$arr = array("1","2","3");class obj&#123; var $color; function what_color() &#123; return $this-&gt;color; &#125;&#125;$b = null; 拓展 判断变量类型：var_dump() 说明：var_dump() 方法，判断一个变量的类型与长度，并输出变量的数值，如果变量有值，则输出是变量的值，并返回数据类型。显示关于一个或多个表达式的结构信息，包括表达式的类型与值. 注意：用保证 var_dump 中的变量必须是存在的，如果变量不存在则返回 NULL. PHP 运算符以例子来理解 123456789101112&lt;?php$x=10;$y=6;echo ($x * $y); // 输出60 ,乘法echo '&lt;br&gt;'; // 换行 echo ($x / $y); // 输出1.6666666666667 ，除法echo '&lt;br&gt;'; // 换行 echo ($x % $y); // 输出4 ，取余echo '&lt;br&gt;'; // 换行?&gt; php7+ 新增整除运算符 示例：123&lt;?phpvar_dump(intdiv(10, 3));?&gt; 赋值运算符与算法运算符用法相同 PHP 递增/递减运算符 运算符 名称 描述 ++$x 预递增 x 加 1，然后返回 x $x++ 后递增 返回 x，然后 x 加 1 PHP 比较运算符 运算符 名称 描述 实例 x &lt;&gt; y 不等于 如果 x 不等于 y，则返回 true 5&lt;&gt;8 返回 true x !== y 绝对不等于 如果 x 不等于 y，或它们类型不相同，则返回 true 5!==”5” 返回 true x === y 绝对等于 如果 x 等于 y，且它们类型相同，则返回 true 5===”5” 返回 false PHP 逻辑运算符 运算符 名称 描述 x and y 与 如果 x 和 y 都为 true，则返回 true x or y 或 如果 x 和 y 至少有一个为 true，则返回 true x xor y 异或 如果 x 和 y 有且仅有一个为 true，则返回 true x &amp;&amp; y 与 如果 x 和 y 都为 true，则返回 true `x y` 或 如果 x 和 y 至少有一个为 true，则返回 true ! x 非 如果x 不为 true，则返回 true 三元运算符 语法格式 (expr1) ? (expr2) : (expr3) 对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。 (exp1)?: (expr3) 自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。 示例：12345&lt;?php$test = "一段字符"；$username = $test ?: 'nobody';echo $username, PHP_EOL;?&gt; ==&gt; 一段字符 组合比较符(PHP7+) PHP7+ 支持组合比较符 示例：比价两个整型数的大小12345&lt;?phpecho 1 &lt;==&gt; 1; // 0echo 1 &lt;==&gt; 2; // -1echo 2 &lt;==&gt; 1; // 1?&gt; 运算优先级 优先级 &amp;&amp; &gt; = &gt; and ` &gt; = &gt; or` 括号优先运算 PHP 条件语句PHp - if 语句 if 语句仅当指定条件成立时执行代码 示例：1234if (condition)&#123; // 条件成立时执行代码块；&#125; PHP - if…else 语句 在条件成立时执行一块代码，条件不成立时执行另一块代码 12345678if (条件)&#123; //条件成立时执行的代码;&#125;else&#123; //条件不成立时执行的代码;&#125; PHP - if…elseif….else 语句 在若干条件之一成立时执行一个代码块 示例：123456789101112if (条件)&#123; //if 条件成立时执行的代码;&#125;elseif (条件)&#123; // elseif 条件成立时执行的代码;&#125;else&#123; //条件不成立时执行的代码;&#125; 注意: elseif 和 else if 完全同效果，elseif 是 PHP 为 else if 专门做到容错版 PHP Switch 语句 如果希望有选择地执行若干代码块之一，可以使用 switch 语句 示例：判断n的值1234567891011121314&lt;?phpswitch (n)&#123; case num1: # code... break; case num2: # code... break; default: # code // 如果 n 即不等于 num1 也不等于 num2 ，此处代码将会被执行；&#125;?&gt; 解释:。代码执行后，使用 break 来阻止代码跳入下一个 case 中继续执行。default 语句用于不存在匹配（即没有 case 为真）时执行]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机科学]]></title>
    <url>%2F2018%2F06%2F29%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%2FComputer%20Science%2F</url>
    <content type="text"><![CDATA[c语言 12345678910111213141516171819202122232425262728293031323334353637383940414243if (condition || condition)&#123; // do this---title: Compute&#125;```r Science date: 2018-07-02 16:05:42tags: "Computer Science"categories: "Basic Knowledge"---# 计算机科学理论&lt;!--more--&gt;## 比特BIT -- binary digit8 BIT -- 1 Byte### 计算机中数的表示例如 7 --二进制 以2的幂计算十进制中 ： 1 2 4 8 ... &lt;br/&gt;二进制中 ： 1 1 1 0 ...即 7 的表示为 `0111`### 硬盘组成&gt;由非常微小的磁性粒子组成，有规定的排列顺序，&lt;br/&gt;就如小磁针，南北指向可以代表比特中的 0 1 ,就由这些磁针来储存数据&lt;br&gt;## C语言```c#include &lt;stdio.h&gt;int main()&#123; printf("Hello,World!\n");&#125; 字符串printf输出实例123456string name = "keithxodoy";float num = 5.264printf("hello,%s！\n", name);printf("%.2f\n", num);printf("%d\n", sizeof(i) ); sizeof ==&gt; 输出数据类型的长度 条件语句 conditions123456789101112if (condition)&#123; // do this&#125;else if (condition)&#123; /* code */&#125;else&#123; //code&#125; “或”、”且” 条件 123456789if (condition || condition)&#123; // do this&#125;if (condition &amp;&amp; condition)&#123; //do this&#125; switch 语句–多重条件,枚举结构 123456789101112131415switch (n)&#123; case 1: case 2: case 3: printf("You picked a small number "); break ; case 4: case 5: case 6: printf("anothor one%% ")； break ; default: printf("the last one ");&#125; 解释 当条件情况case 为 1、2、3时，作case3下的操作，再使用 break 中断循环 使用default处理case以外的情况，可以不使用 break %% 表示 百分比 循环结构12345678910111213#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;intmain()&#123; for (int i = 0; i &lt;= 5; i++) &#123; printf("A test\n"); fflush(stdout); sleep(2); &#125;&#125; 解释 fflush(stdout) : 将循环的进度以类似进度条的形式在一行中显示出来 FAQ 对硬盘或软盘进行格式化时会发生什么？ 解答 不会产生很大改变，对盘进行格式化（分区）只会修改几字节或几千字节的信息，使得电脑无法知道原先的文件或文件夹被存放至哪个位置，但是这些数据仍在原先的位置存储着 编译器作用 ？ 解答 将代码文件编译为二进制文件]]></content>
      <categories>
        <category>Computer Science</category>
      </categories>
      <tags>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keyboard]]></title>
    <url>%2F2018%2F06%2F29%2F%E7%BC%96%E8%BE%91%E5%BF%AB%E6%8D%B7%E9%94%AE%2Fkeyboard%2F</url>
    <content type="text"><![CDATA[CTRL + F 搜索功能CTRL + D 复制一行代码CTRL + Y 删除一行代码在任意位置按住shift + 回车 快速换行CTRL + / 批量注释与取消选中代码 + tab 批量缩进SHIFT + tab 批量取消缩进CTRL + R 代码替换CTRL + - （+）代码折叠（代码展开）CTRL + SHIFT -(+) 代码完全折叠（展开）CTRL + 鼠标左击 查看源代码 TODO 记录要做的事情Ctrl+\ 全屏模式Alt”+”R”运行脚本]]></content>
      <categories>
        <category>keybinding</category>
      </categories>
      <tags>
        <tag>keybinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim]]></title>
    <url>%2F2018%2F06%2F29%2F%E7%BC%96%E8%BE%91%E5%BF%AB%E6%8D%B7%E9%94%AE%2FVim%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[命令 功能 h 向左 j 向下 k 向上 l 向右 行内移动命令 作用 w 向后移动一个单词 b 向前移动一个单词 0 迅速回到行首 ^ 回到行首，第一个不是空白字符的位置 $ 回到行尾 行数移动命令 英文 作用 gg go 回到文件顶部 G GO 回到文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 :数字 移动到 数字 对应行数 屏幕移动 英文 功能 Ctrl+b back 向上翻页 Ctrl+f forwarf 向下翻页 ctrl + H Head 屏幕顶部 ctrl + M Middle 屏幕中间 ctrl + L Low 屏幕底部 编辑命令 英文 作用 i 进入编辑模式 esc 退出 y copy 复制 yy copy 复制一行，多行复制可以nyy,如 2 YY p paste 粘贴 u 撤销上一步的操作 Ctrl+r 恢复上一步被撤销的操作 dd Delete 删除，实际上是剪贴，将删除内容放入文本缓冲区中 缩放命令 ctrl + shift + = 放大 Ctrl + - 缩小 常用Linux命令 英文 作用 ls list 查看当前文件夹下的内容 pwd print work directory 查看当前所在文件夹 cd change directory 切换文件夹 touch touch 新建文件 mkdir make directory 创建目录 rm [-r] remove 删除指定的文件或目录 clear clear 清屏 终端命令格式command [-0ptions] [parameter] command : 命令名，相应功能英语缩写 -Options: 选项，可以对命令进行控制，也可以省略 parameter: 传递给命令的参数，可以为多个]]></content>
      <categories>
        <category>keybinding</category>
      </categories>
      <tags>
        <tag>keybinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm]]></title>
    <url>%2F2018%2F06%2F29%2F%E7%AE%97%E6%B3%95%2FAlgorithm%2F</url>
    <content type="text"><![CDATA[算法 初探算法Question: 猜价格 价格大了 价格小了 猜对了 递推算法顺推法斐波那契数列12345678910long fib[NUM] = &#123;1, 1&#125;;for (i=2; i&lt;num; i++)&#123; fib[i] = fib[i-1] + fib[i-2] ;&#125;for (i=0; i&lt;num; i++)&#123; printf("兔子目前的总数为:%d\n", fib[i]);&#125; 逆推法案例 : 银行存款的提取利息假设第48个月,利息为1000元 12345678910111213141516171819#include &lt;stdio.h&gt;#define Fetch 1000#define Rate 0.0171int main()&#123; double month[49]; //每个月的本利 int i ; month[48] = (double)Fetch; for(i=47; i&gt;0; i--) //由第48月的利息来倒推处第一个月 &#123; month[i] = (month[i+1]+Fetch)/(1+Rate/12); &#125; for(i=48; i&gt;0; i--) &#123; printf("第%d月末的本利合计为:%.2f\n", i, month[i]); &#125; getch(); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm step</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode]]></title>
    <url>%2F2018%2F06%2F29%2F%E7%BC%96%E7%A8%8B%E9%A2%98%E5%BA%93%2F%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[leetcode 刷题心得与题解 15. 3SUM题目：1234567891011121314151617Given an array nums of n integers,are there elements a, b, c in nums such that a + b + c = 0?Find all unique triplets in the array which gives the sum of zero.Note:The solution set must not contain duplicate triplets.Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] O（n3）的时间复杂度经过修改也没啥用 固定i，j、k为双向指针，j从头开始，k从尾开始遍历。当和小于0时，j减1，当和大于0时，k加1当找到一个值时，不能当做此时i的固定结果，因为可能有多个，所以需要再把j、k其中之一改变，j加1或者k减1都可以1234567891011121314151617181920212223class Solution(object): def threeSum(self, nums): length = len(nums) resultList = [] nums.sort() for i in range(0,length-2): j = i + 1 k = length - 1 while (j &lt; k): sum0 = nums[i] + nums[j] + nums[k] if (sum0 == 0): result = [] result.append(nums[i]) result.append(nums[j]) result.append(nums[k]) if result not in resultList: resultList.append(result) j +=1 if (sum0 &lt; 0): j +=1 if (sum0 &gt; 0): k -=1 return resultList]]></content>
      <categories>
        <category>编程题库</category>
      </categories>
      <tags>
        <tag>编程题库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux教程.md]]></title>
    <url>%2F2018%2F06%2F28%2FLinux%2FLinux%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[LINUX 初探 知识概念网络概述1970年 — Linux元年1969年 — Internet元年 局域网(LAN) - Local Area Network : 指范围在几百米到十几公里内办公楼群或校区内的计算机相互连接所构成的计算机网络 城域网(MAN) + Metropolitan Area Network 广域网(WAN)- Wide Area Network : 通常跨接很大的物理范围，如一个国家 网络分类 – 公网 &amp; 内网 公网：上网的计算机得到的 IP 地址是 Internet 上的非保留地址，公网的计算机和 Internet 上的其他计算机可以随意相互访问 IP 地址IP (Internet Protocol) : 网络之间互连的协议，即网络相互连接进行通信而设计的协议 IP 地址类型 ： 公有地址、私有地址 1.0.0.0 - 255.255.255.255 公有地址(Public address) 公有地址由 Inter NIC (Internet Network Information Center 因特网信息中心)负责。这些 IP 地址分配给注册并向 Inter NIC 提出申请的组织机构(免费)，可以通过它直接访问因特网 私有地址(Private address) 私有地址属于 非注册地址，专门为组织机构内部使用，用以分散使用 类别 私有 IP 地址 使用对象 最大主机数 最大网络数 A 类 10.0.0.0 - 10.255.255.255 电信、联通等运营商 16777214 126 (2^7-2) B 类 172.16.0.0 - 172.31.255.255 65534 16384(2^14) C 类 192.168.0.0 - 192.168.255.255 使用最多 254 2097152(2^21) DNSDNS (Domin Name System 域名系统) ： 因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能使用户更方便的访问互联网 域名解析 用户通过主机名，最终得到该主机名对应的 IP 地址的过程 步骤： 用户输入域名 localhost –&gt; DNS (localhost 127.0.0.1) –&gt; 服务器电脑 端口(Port) 端口可以认为是设备与外界通讯交流的出口 端口: 虚拟端口 和 物理端口 虚拟端口 ： 计算机内部或者交换机路由器内的端口，不可见端口 物理端口 ： 如计算机的 80端口、 21端口等，可见端口例如 计算机背板的 RJ45网口 **用户输入域名 localhost：端口 –&gt; DNS (localhost 127.0.0.1) –&gt; 服务器电脑 –&gt; 软件（服务） **文件与用户的关系 所有者 u : 只有一个，但可以交换 用户组 g ： 只有一个，可以使用文件，但不是所有者 其他人 o ： 既不属于所有者，又不是用户组 格式 -： 表示文件 d： 表示目录 l : 表示软连接 例子 ：rw- r– r– rw- : 代表文件的所有者有读写的权限，代表最高权限，不一定需要赋予所有权限，够用就行 r– : 代表赋予用户组的权限 — : 代表赋予其他人的权限 软链接 类似 Windows快捷方式，不决定原文件的权限，只是符号链接 三种用户都有所有权限 rwx ， 文件为 l 开头 ，文件大小较小 硬链接 相当于拷贝 cp -p（保留属性） + 同步更新 一个i节点对应到了两个文件 注意 ： 硬链接不能跨分区 ，而且不能针对目录使用文件操作 r(读) w(写) x(执行) 文件覆盖 y Linux配置设置Linux的IP地址ifconfig eth0 ip地址 添加虚拟网卡 ifconfig eth0:1 198.168.1.1 操作技巧 文件部分名称+ tab ： 自动补全文件名 Ctrl shift = : 放大终端窗口的字体显示 Ctrl - : 缩小终端窗口的字体显示 向上/下箭头:查看历史输入命令 Linux命令查阅命令帮助信息help:command --help : 显示帮助信息man:man command : 查阅使用手册 空格:显示手册下一屏 Enter:下一行 b:回滚一屏 f:前滚一瓶 q:退出 /word:搜索word字符串 命令格式 命令 -选项 -参数 例子 ： ls -la /etc命令的选项可以同时使用，且不分顺序 文件处理命令 文件命令 作用 英文 ls 目录处理命令 list ls -a 查看目录所有文件（含隐藏文件） 可以添加目录参数 ls -l 查看文件的详细信息 ls -lh 人性化显示文件信息,更直观显示文件大小 ls -ld /etc 只示目录本身的信息 ls -i 查看文件的i节点 （即为文件的id信息） 说明 .开头为隐藏文件,需要-a参数查看或者Ubuntu进入目录，按ctrl h就能看见以点号开头的隐藏文件 .当前目录 ..上一级目录 目录命令 英文 作用 mkdir make directories 创建新目录 mkdir -p 递归创建新目录，并且在新目录在再进行创建，可同时创建多个 cd change directories 切换目录 . 代表当前目录 ..回到上一级目录 pwd print working directories 显示当前工作目录 rmdir remove directories 删除空目录 cp copy 拷贝目录或文件 cp -rp [原文件或目录] [目标目录] r为复制目录操作 p为保留文件属性 可以同时复制多个 mv move 目录剪切 移动 mv [绝对路径] [目标路径] 若是要剪切当前路径下的文件 可以直接 mv [文件名] [目标目录] rm remove 删除文件或名录 要慎重 rm -f 强制删除 rm -r 删除目录 rm -rf 直接删除目录 cd 补充 作用 cd ~ 切换到当前用户的主目录 cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 文件处理 作用 例子 touch 创建空文件 touch /root/book.list cat 浏览文件内容 可以加 -n 参数 cat -n /etc/issue tac cat 的倒序显示可以倒序显示文件内容 more 分页显示文件，适合查看长文件 less 分页浏览 head 查看文件的前n行,默认为10行 head -n 8 tail 查看文件的末尾n行 tail -f /var/log/message 动态显示问文件 链接处理 作用 例子 ln /etc/issue /tmp 默认创建硬链接 ln -s 软连接 注意事项: touch 若要创建带空格文件名的文件，可touch &quot;my love&quot;,即加上双引号 最好不要在Linux中创建带有特殊符号的文件名 cat 不太适合浏览含有非常多内容的文件 more 按 空格 ： 一页一页浏览 按 回车 ： 一行一行浏览 按 q : 退出浏览 cp cp -p : 该属性可以保持复制文件或目录的信息，如创建和修改的时间等 cp -r cp -r : 可以在复制文件或目录时，将文件名进行修改 mv mv 当前目录下的文件名 要修改成的名字 : 可以作为文件名修改命令 less 可以倒回去浏览内容 pageup : 一页一页往回翻 上箭头 : 一行一行往回翻 /service ： / 斜杠可以用来搜索，按 n 可以翻看下一页 权限管理命令命令名称： chmod 命令原意： change the permissions mode of a file 所在路径： /bin/chmod 功能描述： 改变文件或目录权限 可以更改权限的对象： root &amp; 所有者 语法 chmod [{ugoa}{+-=}{rwx}] [文件或目录][mode=421] [文件或目录] -R 递归修改 例子 ： chmod u+x myblog.md – 给所有者(u)赋予myblog文件的写(x)的权限 补充 ： 通过”+-=”来修改权限 一般通过权限的数字来表示： r–4 w–2 x–1 rwx : 7 ; rw- : 6 ; r–: 4 例子 ： chmod 640 myblog.md 注意： chmod 默认改变当前指定的文件或目录，对目录下的子目录不进行修改 若需要修改，则可以添加-R属性 正确理解目录rwx权限 注意：r+x 权限是同时出现的 w权限的说明： 对文件的删除是否能进行，是与用户在该文件所在目录被赋予的权限有关 若用户被给予W权限，则可以删除该文件 改变所有者命令 chown 命令名称 ： chown – change file ownership 命令所在路径 : /bin/chown 执行权限 ： root用户 功能描述 ： 改变文件或目录的所有者 语法- 基本语法 : chown [用户][文件或目录] 注意事项 只有root管理员身份才能修改所有者 修改所有者时，要确保新所有者用户存在 创建新用户 useradd 用户名 ,并且谁创建的文件，谁就是所有者 改变文件所有组 chgrp 命令名称 ： chgrp – change file group ownership 命令所在路径 ： /bin/chgrp 执行权限 ： 所有用户 语法 基本语法 ： chgrp [用户组][文件或目录] 范例 : $ chgrp newgroup doc : 将doc文件的所属组改为newgroup 创建新组 ： groupadd 新组名 设置新建文件的缺省权限 umask 命令名称 ： umask – the user file-creation mask 命令所在路径 ： Shell内置命令 执行权限 ： 所有用户 功能描述 ： 显示、设置文件的缺省权限 语法 基本语法 ： umask [-S] S : 以 rwx 形式显示新建文件的缺省权限 范例 ： $ uamsk -S 拓展语法 umask 023 含义 ：所有权限777 ,将 777 - 023 = 754 ,则为新设置的目录权限为 rwx–rx–r 注意 touch 创建新文件是不具有可执行权限的 文件搜索命令文件搜索命令 find 命令名称： find 命令所在路径： /bin/find 执行权限： 所有用户 语法 find [搜索范围][匹配条件] 更多用法 $find /etc -name init :使用-name 精准搜索 粗略搜索 *init* 不分文件名大小写 -iname ：匹配任意字符 ？：匹配单个字符 $find / -size : 使用-size 根据文件大小来查找 find / -size +204800 : 在根目录下查找大于100MB的文件 +n 大于 -n 小于 n 等于 大小说明 1K = 2数据块 1数据块 = 512字节 = 0.5K $find /home -user（-group） yonghu ：根据文件所有者(所属组)来查找 find -type f :根据文件类型查找 – f 文件 d 目录 l 软连接文件 find -inum : 根据i节点查找 ，通过i节点，可删除特殊文件 根据文件信息修改的时间来查找 $find /etc -amin -5:查找5分钟内被访问过的文件和目录 – access $find /etc -cmin -5:查找5分钟内被修改过属性的文件或目录 – change $find /etc -mmin -5:查找5分钟内被修改过内容的文件或目录 – modify 常用连接选项 作用 范例 -a (and) 表示两个条件同时满足 $find /etc +163840 -a -size -204800 -o (or) 表示两个条件满足任意一个即可 $find /etc 163840 -o -size 204800 注意事项 查找文件时，文件名的大小写是区分开来的 文件搜索命令 locate 命令名称： locate 命令所在路径： /usr/bin/locate 执行权限 ： 所有用户 语法 基本语法 locate 文件名 功能 ： 在文件资料库中查找文件 范例：$locate init 文件库： /var/lib/mlocate/mlocate.db 拓展语法 locate -i 文件名 : 不区分大小写来查找文件 注意 当创建的文件没有被存入文件资料库中时，无法使用locate查找到文件 解决方法： $ updatedb 手动更新 文件资料库不会收取 /tmp 临时文件夹下的文件，故使用locate可能无法搜索到该目录下文件 文件搜索命令 which 命令名称： which 命令所在路径 ： /usr/bin/which 执行权限 ： 所有用户 功能描述： 搜索命令所在目录及别名信息 例子 ： $ which ls 文件搜索命令 whereis 命令名称: whereis 命令所在路径： /usr/bin/whereis 执行权限 ： 所有用户 功能描述： 搜索命令所在目录及帮助文档路径 例子： $ whereis ls 文件搜索命令 grep 命令名称 ： grep 命令所在路径： /bin/grep 执行权限: 所有用户 功能描述 : 在文件中搜寻字串匹配的行并输出，即在文件内进行搜索 语法 基本语法 $ grep mysql /root/install.log $ grep + 查找关键词 + 文件所在地址 拓展语法 $ grep -i : 不区分大小写来查找 $ grep -v : 排除指定字串来查找 $ grep -v ^# : 过滤掉位于行首的文件脚本注释行 文件解压操作tar -zxvf 压缩文件名 注意事项目录：/proc/ /sys/ : 为系统内存和内核，只可读，写入的数据在重启时会清除，不要往内写入文件 /tmp : 临时目录，存放临时文件，建议不要存放重要文件，重启时最好清除 /var : 动态数据保存位置，注意保存缓存，日志已经软件运行产生的文件 /usr : 系统软件资源目录，为“Unix Software Resource”的缩写，用于存放系统软件资源的目录，系统安装的软件资源基本存放在此目录 服务器： 远程服务器不允许关机，只能重启 重启时应该关闭服务 不要在服务器访问高峰运行高负载命令 ，如对大数据的处理 远程配置防火墙（过滤作用）时，不要把自己踢出服务器 其他： 指定合理的密码规范并定期更新 合理分配权限 – 用户的权限越少越好 定期备份重要数据与日志，多处存储 Linux命令若未指定目录，则默认在当前目录里执行操作 Linux 新建的文件的 x(可执行)权限会自动去除]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>Linux初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电音入门.md]]></title>
    <url>%2F2018%2F06%2F28%2F%E9%9F%B3%E4%B9%90%2F%E7%94%B5%E9%9F%B3%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一入电音深似海引言 Can u feel the volume of my love for u 电音风格Techno – 高科技舞曲 理解 ： 重复动次打次 House music –舞蹈音乐 场景 ： 各大酒吧 风格 ： 类似Techno, 但高潮部分，会突然爆发不同的旋律 辨别 4/4拍 动次动次 动 ： 大姑 次 ： 镲 BPM(beats per minutes) : 118-135bpm ,最常见的为 128bpm Progressive House 辨别 ： 一层一层的堆叠感 拍数不断堆叠 内容 一定具有VOCAL(人声)，和弦等 Electric House 辨别 ： 电子制作 人造的音色 内容 与鼓点同步的Bass声音(sub) 类似 dong-en “咚-嗯” Big Room House 辨别 ： 单一洗脑 富有侵略性的旋律 内容 一串串 “叭叭叭”的声音 类似喇叭的声音 Melbourne Bounce 辨别 : 慢摇 缩放感 发出”嗯-嘚”的声音 Deep House 辨别 ： 结构稳定 情绪起伏小 速度较慢 120bpm Tropical House 辨别 : 热带感的乐器、音色 有种令人想跳舞的感觉 Future House 辨别 ： 常以 bassline 主旋律 有点空空的感觉 由一条bass的主旋律 Tech House 辨别 ： 碎拍、旋律不明确 打击乐特别多 次次次的声音特别多 Techno &amp; House Dubstep 风格 ： 偏向黑暗系， 嗡嗡嘭嘭感十足 Trap]]></content>
      <categories>
        <category>How to become a DJ</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐理知识.md]]></title>
    <url>%2F2018%2F06%2F28%2F%E9%9F%B3%E4%B9%90%2F%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[乐理入门 泛音 概念：物体局部振动产生的复合音的总和 以弦的振动来说，除了整个弦的振动，其二分之一，三分之一…各段都在振动，共同发音 作用：对音色具有决定性的作用，通过增减泛音的音量，可对音色有明显的改变 音阶 什么是音阶 调式中由高低次序（上下行），由主音到主音排列起来 音级概念乐音体系中的各个音，例如钢琴有88个不同音高的音，则音级为88 基本音级 从 do–si 七个独立音叫做基本音级，并通过字母或唱名标记 钢琴白键便是7个基本音级的循环重复 Do Re Mi Fa Sol La S 对应 C D E F G A B 两个相邻具有相同名称的音级叫做八度, 即相差一个八度，一个八度音阶共有7个基本音级和5个变化音级，共12个音组成（12平均音） 变化音级升高或者降低基本音级而获得的音，钢琴中用黑键表示 变化音级标注法 升 or “#” 降 or “b” 重升 or “x” 重降 or “bb” 其中音高相同而意义和记法不同的音叫做“等音” ，如#C , bD 乐音分组目的: 由于乐音体系中音级会循环出现，于是为了区分音名相同而音高不同，将其分组 以钢琴为例，最中央的12个音级叫做小字一组 音域及音区总音域概念: 指音列的总范围，乐器和人声的音域指能发生出的最高或最低音的范围 不同音区表现不同的音色/情感等特征 五线谱 概念: 通用的标准记谱法，由五条平行横线构成 音符通过在五线谱中记录在线上或间内 作用: 音符位置决定音的高低，形状决定音的长短 注意: 当五线不足以记录时，通过上加或下加线** 来解决 五线谱由自下而上计算，音高也由自下而上由低到高 多声部五线谱 多声部需要数行五线谱来记录，需要使用连谱号连接 连谱号: 包括起线（连接数行五线谱的垂直线）和括线（连接数行五线谱的括弧） 在总谱中，使用小节线连接同种类型的乐器连谱号括弧 花线 钢琴/风琴/手风琴/竖琴 直线 合奏/合唱乐队 有时在直线外还会加上辅助括线， 起线 位置在五线谱的开端，需连接全部的五线谱 音符概念: 记录不同长短的音的进行的符号 成分: 符头/符干/符尾 休止符休止符: 记录音的间断的符号 持续时间: 每个音符的持续时间为倍数减少，如二分音符持续2S.则四分音符持续1S 附点: 记在音符符头或者休止符右边的小圆点，表示增长原有音符或休止符时值得一半，且每增加一个附点，则增长时间为前一个附点值得一半 音符记谱 音符记录在五线谱的线或间上，符头越高，音高越高 五线谱音线有1-5，从下到上 符头方向判断 符头在三线以上，符干朝下，附在符头左边 符头在三线以下，符干朝下，附在符头右边 符头在三线上，则符干可上可下，符干方向随附近音符方向决定 符干 单声部永远使用单符干记谱（独立记谱） 多声部只有在节奏相同时，才用单符干记谱，如“三十二音符” 符尾 符尾在符干右边并且向符头方向弯曲 一符干 多音 同时连接多个音，表示这些音需要同时弹奏 同一符干连接多个音，符干方向以离第三线最远的音符为标准记录，且符尾方向相同 简谱与五线谱大音阶 对应手指 大拇指-小拇指 ： 1-2-3-4-5 C大调 ： 1-2-3-1-2-3-4-5 C 位于 下加一线 G大调 C 位于 第二线]]></content>
      <categories>
        <category>How to become a DJ</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多进程初探]]></title>
    <url>%2F2018%2F06%2F26%2FPython%2FPython%E7%90%86%E8%AE%BA%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%26%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[搞定多进程与多线程 多线程概念程序: 代码以文本的形式存入一个文档 进程: 程序运行的一个状态，包含地址空间、内存、数据栈等 每个进程由自己==完全独立==的运行环境，多进程共享数据 轻量化的进程 一个进程的多个线程间共享数据和上下文运行环境 共享、互斥问题 线程: 一个进程的独立运行片段，一个进程可以由多个线程 全局解释器锁(GIL) Python代码的执行是由python虚拟机进行控制 在主循环中有一个控制线程在执行 Python包thread： 有问题，不好用 python3： _thread* `import _thread as thread ` threading: 通行的包 直接利用threading.Thread生成Thread t = threading.Thread(target=xxx, args=()) t.start(): 启动多线程,可独立于主线程 t.join() : 等待多线程执行完成 守护线程 daemon子线程会在主线程结束后自动退出**，一般认为守护线程不重要或不允许离开主线程独立运行 设置守护线程–在t.start()前* `t.setDaemon(True)` 1234if __name__ == "__main__" main() while True: time.sleep(5) 启动线程–使用多线程执行某个函数thread.start_new_thread(loop,() 理解启动多线程: 相当于给多个工人分配任务，自己可以做别的事情，等自己事情做完了，工人也恰好完工（完成时间非常快） 注意事项 启动多线程函数为 ==start_new_thread== 参数为两个，一个是运行的==函数名==，另一个是==函数参数==作为元组使用，若为空，则使用空元组，若函数只有一个参数，则在参数后需要一个==逗号==，标识为元组启动多线程 ==一定要使用while语句==，因为启动多线程后本程序就作为主线程存在，如果主线程执行完毕，则子线程可能也会没执行完就终止 共享变量共享变量: 当多个线程同时访问一个相同变量时，会产生共享变量问题,即会产生冲突 解决变量锁(Lock)锁: 是一个标志，表示一个线程在占用一些资源 使用方法 上锁 可以放心使用共享资源 取消锁，释放锁 12345678import threadinglock = threading.Lock()# 上锁，申请锁lock.acquire()# 使用结束后，释放锁lock.release() 线程安全问题概念: 如果一个资源/变量，对于多线程来说，不用加锁也不会引起任何问题，则称为线程安全 类型 线程安全变量： queue 线程不安全变量： list 、 set 、 dict 生产者消费问题 一个模型，可以用来搭建消息队列 queue: 一个用来存放变量的数据结构，特点为先进先出，内部元素排队，可以理解为一个特殊的list 方法 queue.Queue() : 生成队列的实例 queue.qsize() : 计算队列的长度 queue.push() : 将数据放入队列中 queue.get() : 从queue中取出一个值 12345# python2from Queue import Queue# python3import queue 123456789101112131415161718import threadingimport time# 直接继承Thread方法class Producer(threading.Thread) def run(self): global queue count = 0 while True: # qsize计算队列的长度 if queue.qsize() &lt; 1000 for i in range(100): count = count + 1 msg = "生产产品" + str(count) # 将数据放入队列中 queue.put(msg) print(msg) time.sleep(0.5) 12345678910class Consumer(threading.Thread) def run(self): global queue while True: if queue.qsize() &gt; 100 for i in range(3): # get是从queue中取出一个值 msg = self.name + "消费了" + queue.get() print(msg) time.sleep(1) 解释: 对于继承Thread,必须重写run(self)函数，run(self)函数为调用Thread时，自动调用的函数 死锁现象解释 集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的 例如，如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1，这样两个线程就发生了死锁现象。 解决 对申请锁的内容设置超时时间 lock.acquire(timeout=2) semaphore 允许一个资源最多由几个多线程同时使用 semaphore = threading.Semaphore(3) : 设置最多3个线程同时使用资源 可重入锁 lock = threading.RLock()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端深似海-HTML]]></title>
    <url>%2F2018%2F06%2F24%2F%E5%89%8D%E7%AB%AF%2FHTML%2F</url>
    <content type="text"><![CDATA[逐步学会HTML URL统一资源定位符 URL URL Uniform Resource Locator URL 格式scheme://host.domain:port/path/filename scheme - 定义因特网服务的类型。最常见的类型是 http host - 定义域主机（http 的默认主机是 www） domain - 定义因特网域名，比如 w3school.com.cn :port - 定义主机上的端口号（http 的默认端口号是 80） path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。 filename - 定义文档/资源的名称 URL 编码 URL 只能使用 ASCII 字符集来通过因特网进行发送。 由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。 URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。 URL 不能包含空格。URL 编码通常使用 + 来替换空格。 DTD文档类型定义(Document Type Definition) 一套为了进行程序间的数据交换而建立的关于标记符的语法规则。使用各类文档类型定义是为了让标准通用标记语言、可扩展标记语言文件能符合规定的数据交换标准 DTD : 严格型、过渡型、框架型 严格型：在整个文档中不能出现任何表现形式的标签，如 粗体、斜体等，要用 CSS ! 过渡型 ： 在文档中可以使用表现形式，也可以用CSS! HTML5 DTD&lt;!DOCTYPE html&gt;—## HTML5### HTML5 简介HTML5 的新的文档类型（DOCTYPE）声明：12&lt;!DOCTYPE html&gt;&lt;meta charset="UTF-8"&gt;实例：123456&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Title of the document&lt;/title&gt;&lt;/head&gt;&gt; 注意 : HTML5中默认字符编码为 UTF-8### meta标签属性 http-equiv - 相当于http的文件头作用，可以向浏览器传回一些有用的信息，以帮助正确和精确的显示网页内容，与之对应的属性值为 content - 实例: Refresh 中的 2表示2秒后刷新页面，URL为刷新后跳转到的页面; X-UA-Compatible 为了兼容 IE浏览器12345&lt;meta http-equiv="content-type" charset="UTF-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7"&gt;&lt;meta http-equiv="Refresh" content="2;URL=https://wwww.baidu.com" &gt; name### 非meta标签 link &amp; script :123&lt;link rel="stylesheet" href="css.css"&gt;&lt;link rel="icon" href="httP://..."&gt;&lt;script src="hello.js"&gt;&lt;/script&gt;解释 : icon 为引入页面的小头像 、 stylesheet 引入外部样式表 、 script 引入 js脚本等—### HTML5 浏览器支持&gt; 所有浏览器，不论新旧，都会自动把未识别元素当做行内元素来处理。&gt; 正因如此，可以使得老式浏览器处理”未知的“ HTML 元素。把 HTML5 元素定义为块级元素HTML5 定义了八个新的语义 HTML 元素。所有都是块级元素。解决方案：把 CSS display 属性设置为 block，以确保老式浏览器中正确的行为：实例：123header, section, footer, aside, nav, main, article, figure &#123; display: block; &#125;Internet Explorer 的问题&gt; 注意：Internet Explorer 8 以及更早的版本，不允许对未知元素添加样式。 解决方案：12345&lt;head&gt;&lt;!--[if lt IE 9]&gt; &lt;script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;&lt;/head&gt;以上代码是一段注释，但是 IE9 的早期版本会读取它（并理解它）—## HTML 文档声明&lt;HTML &lt;!DOCTYPE&gt;&lt;!DOCTYPE&gt;声明帮助浏览器正确地显示网页&gt; &lt;!DOCTYPE&gt; 不是 HTML 标签。它为浏览器提供一项信息（声明），即 HTML 是用什么版本编写的。&lt;!DOCTYPE html&gt; : HTML5 的声明—### HTML 语义#### HTML5 &lt;section&gt; 元素&lt;section&gt; 元素定义文档中的节。&gt; 根据 W3C 的 HTML 文献：“节（section）是有主题的内容组，通常具有标题”。#### HTML5 &lt;article&gt; 元素&lt;article&gt; 元素规定独立的自包含内容。&gt; 文档有其自身的意义，并且可以独立于网站其他内容进行阅读。&lt;article&gt;元素的应用场景： 论坛 博客 新闻##### HTML5 &lt;header&gt; 元素&lt;header&gt;元素为文档或节规定页眉。&lt;header&gt;元素应该被用作介绍性内容的容器。一个文档中可以有多个&lt;header&gt; 元素。实例：1234567&lt;article&gt; &lt;header&gt; &lt;h1&gt;My Title&lt;/h1&gt; &lt;p&gt;SubTitle&lt;/p&gt; &lt;/header&gt; &lt;p&gt;my description ......&lt;/p&gt;&lt;/article&gt;##### HTML5 &lt;footer&gt;元素&lt;footer&gt;元素为文档或节规定页脚。&lt;footer&gt;元素应该提供有关其包含元素的信息。&gt; 页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。实例：为页脚添加联系邮箱,作者1234&lt;footer&gt; &lt;p&gt;Posted by: Keithxodoy&lt;/p&gt; &lt;p&gt;Contact Email: &lt;a href="mailto:someone@example.com"&gt;someone@example.com&lt;/a&gt;&lt;/p&gt;&lt;/footer&gt;#### HTML5 &lt;nav&gt;元素&lt;nav&gt;元素定义导航链接集合。注意:&lt;nav&gt;元素旨在定义大型的导航链接块。然而，并非文档中所有链接都必须位于 &lt;nav&gt;元素中！实例： 创建个人github的nav导航123&lt;nav&gt; &lt;a href="https://github.com"&gt;Github&lt;/a&gt;&lt;/nav&gt;#### HTML5 &lt;aside&gt;元素&lt;aside&gt;元素页面主内容之外的某些内容，例如侧栏。实例：123456&lt;aside&gt; &lt;ul&gt; &lt;li&gt;导航1&lt;/li&gt; &lt;li&gt;导航2&lt;/li&gt; &lt;/ul&gt;&lt;/aside&gt;&gt; aside 内容应该与周围内容相关连。#### HTML5 &lt;figure&gt;和 &lt;figcaption&gt;元素&gt; 在书籍和报纸中，与图片搭配的标题很常见.figcaption可以在图片下方给予图片相关的解释实例：为图片下方标示1234&lt;figure&gt; &lt;img src="test.png" alt="test_pic"&gt; &lt;figcaption&gt;Detail About Picture &lt;/figcaption&gt;&lt;/figure&gt;—## HTML基础标签 添加水平线 &lt;hr/&gt; 内容居中 align=&quot;center&quot; 换行 &lt;br/&gt; 注释 &lt;!-- --&gt; 背景颜色 bgcolor=&quot;blue&quot; 链接 &lt;a href=&quot;http://&quot; &gt; 图像 &lt;img src=&quot; &quot;&gt;—# 个性化设置## HTML属性 style属性 background-color 属性为元素定义了背景颜色 实例：style=&quot;background-color:red&quot; font-family、color 以及 font-size 属性分别定义元素中文本的字体系列、颜色和字体尺寸 实例：style=&quot;font-family:arial;color:red;font-size:20px;&quot; text-align 属性规定了元素中文本的水平对齐方式 实例：style=&quot;text-align:center&quot; color - 设置字体颜色 ： color: red - 特殊用法 : color: rgb(100,200,500); rgb: red green blue text-decoration - 设置文字修饰 - 例如 text-decoration: underline – 设置下划线 text-decoration: none –不设置任何文字修饰—## HTML 颜色&gt;颜色由红色、绿色、蓝色混合而成。颜色名：大多数的浏览器都支持颜色名集合。提示：仅仅有 16 种颜色名被 W3C 的 HTML4.0 标准所支持。它们是：aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, white, yellow。&gt; 如果需要使用其它的颜色，需要使用十六进制的颜色值。—## HTML中的样式 stylesheet123456&lt;style type="text/css"&gt;h1 &#123;color: red&#125;p &#123;color: blue&#125;body &#123;background-color: red&#125;p &#123;margin-left: 20px&#125;&lt;/style&gt;&gt; 添加到部分的样式信息对 HTML 进行格式化### HTML的内容格式化1234&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;meta http-equiv="Content-Language" content="zh-cn" /&gt;&lt;/head&gt;&gt; 当特殊的样式需要应用到个别元素时，就可以使用内联样式123&lt;p style="color: red; margin-left: 20px"&gt;This is a paragraph&lt;/p&gt;### 使用样式属性做一个没有下划线的链接1&lt;a href="/example/html/lastpage.html" style="text-decoration:none"&gt; 自定义下划线链接text-decoration: underline &lt;link&gt; 标签链接到一个外部样式表12&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="/html/css"/&gt;### 设置HTML的aside侧栏的边距1234aside ul &#123; list-style: none; padding-left: 0;&#125;例子12345678910111213141516&lt;div class="wrap"&gt; &lt;h1&gt;mytest&lt;/h1&gt; &lt;p&gt;The cat was fast.&lt;/p&gt; &lt;div class="content"&gt; &lt;h2&gt;content&lt;/h2&gt; &lt;p&gt;paragraph&lt;/p&gt; &lt;/div&gt; &lt;aside&gt; &lt;h2&gt;mysidebar&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;about&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/aside&gt;&lt;/div&gt;1234.wrap &#123; width: 600px; margin: auto;&#125;注意： 为显示aside的侧边效果，首先要对aside所在的div中，设置div的属性 为使得页面更好的附和浏览器，可以设置宽度，高度为百分比，如width: 80%### 设置样式元素的展示方式dispaly| code | function || — | ——– || display : inline | 将样式元素在一条线上显示 || display : block | 将样式元素块显示 |拓展 :hover :hover 选择器鼠标指针在其上浮动的链接设置样式。 hover 选择器可用于 所有元素 ，不只是链接。例：12345li a:hover&#123; text-decoration: underline color: #666; font-size: 60px;&#125; :link 选择器设置指向未被访问页面的链接的样式 :visited 选择器用于设置指向已被访问的页面的链接 :active 选择器用于活动链接。注释：在 CSS 定义中，:hover 必须位于 :link 和 :visited 之后（如果存在的话），这样样式才能生效。——## HTML文本实例化### 基础&lt;b&gt; 粗体 &lt;strong&gt; 字体加强&lt;big&gt; 字体变大 &lt;em&gt; 字体强调&lt;i&gt; 意大利斜体 &lt;small&gt; 字体减小&lt;sub&gt; 字体下放 &lt;sup&gt;字体上放&lt;del&gt; 删除字 &lt;ins&gt; 下划线### 拓展 &lt;pre&gt;&gt; 预格式文本，可以很好的显示计算机代码，可以对空行和空格进行控制。 &lt;code&gt; &lt;var&gt;&gt; 常用于显示计算机/编程代码,变量 &lt;kbd&gt;&gt; 定义键盘代码 &lt;tt&gt;&gt; 定义打字机代码 &lt;font color=&quot;&quot;&gt;&gt; 设置字体颜色 &lt;address&gt;&gt; 可以在 HTML 文件中写地址 &lt;acronym title=&quot;World Wide Web&quot;&gt;WWW&lt;/acronym&gt; &lt;abbr title=&quot;etcetera&quot;&gt;etc.&lt;/abbr&gt;&gt; 可以将 title 里的内容缩写为自己定义的形式&gt; 并且首字母缩写 &lt;bdo dir=&quot;rtl&quot;&gt;&gt; 可以将 中的内容倒序输出 &lt;cite&gt;&gt; 定义引用、引证 &lt;dfn&gt;&gt; 定义一个定义项目 &lt;blockquote&gt;&gt; 可以进行文本的长引用 &lt;q&gt;&gt; 可以进行文本的短引用 使用 blockquote 元素的话，浏览器会插入换行和外边距 而 q 元素不会有任何特殊的呈现。### HTML字符实体#### HTML实体&gt;在 HTML 中，某些字符是预留的。&gt;在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。&gt;如果希望正确地显示预留字符，必须在 HTML 源代码中使用字符实体（character entities）实例123&amp;entity_name; &amp;#entity_number;&lt;!--如需显示小于号，我们必须这样写：--&gt;&amp;lt; &amp;#60;字符实体表格| 显示结果| 描述| 实体名称| 实体编号||———| —–| ——-|———-|| | 空格| &amp;nbsp;| &amp;#160;|| &lt; | 小于号 |&amp;lt; | &amp;#60;|| &gt; | 大于号| &amp;gt;| &amp;#62;|| &amp; | 和号 | &amp;amp;| &amp;#38;|| “ | 引号 |&amp;quot;| |&amp;#34; ||’ |撇号 |&amp;apos; (IE不支持)| &amp;#39;|| ￠ |分（cent） |&amp;cent; |&amp;#162;|| £| 镑（pound）| &amp;pound; |&amp;#163;||¥ | 元（yen） |&amp;yen;|&amp;#165;|| €| 欧元（euro）| &amp;euro; |&amp;#8364;|| §| 小节 | &amp;sect;| &amp;#167;|| ©| 版权（copyright）| &amp;copy;| &amp;#169;||® |注册商标 | &amp;reg; |&amp;#174;||™ |商标 | &amp;trade;| &amp;#8482;||× |乘号 | &amp;times; |&amp;#215;||÷ |除号 |&amp;divide; | &amp;#247;|—#### 不间断空格(non-breaking space)&gt;HTML 中的常用字符实体是不间断空格(&amp;nbsp;)。&gt;浏览器总是会截短 HTML 页面中的空格。—## HTML链接实例### 3种基本方式 &lt;a href=&quot;/index.html&quot;&gt;一个指向本网站中的一个页面的链接 &lt;a href=&quot;http://www.microsoft.com/&quot;&gt;一个指向另一个页面的链接 &lt;a href=&quot; &quot;&gt;&lt;img src=&quot; &quot;/&gt;&lt;/a&gt;将图像用来作链接 &lt;a href=&quot;mailto:someone@microsoft.com?subject=Hello%20again&quot;&gt;发送邮件&lt;/a&gt;使用邮件链接，其中应该使用 ==%20== 来代替单词之间的空格也可以在链接后面传值，即可以添加邮件的内容&amp;subject=Summer%20Party &amp;body=You%20are%20invited%20to%20a%20big%20summer%20party!### 超链接标签的属性 target=&quot;_blank&quot;链接将在新窗口中打开，默认属性是在本窗口打开新网页 &lt;a href=&quot;#C4&quot;&gt;链接将直接跳转至本页面的某个指定位置### 空连接1. &lt;a href=&quot;#&quot;&gt;空链接&lt;/a&gt; : 不推荐使用,会在链接后面添加一个#2. &lt;a href=&quot;javascript:void(0)&quot;&gt;空链接&lt;/a&gt; : 使用 javascript### 图像 定义背景图像&lt;body background=&quot;/i/eg_background.jpg&quot;&gt; 定义图像地图map 替换文本属性（==Alt==）&gt; alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。&lt;img src=&quot;boat.gif&quot; alt=&quot;Big Boat&quot;&gt;&gt;浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息,如图 排列图像位置通过改变&lt;img&gt;的align属性 bottom middle top 实例 ：&lt;img src=&quot;/i/eg_cute.gif&quot; align=&quot;bottom&quot;&gt; 浮动文本 ：align=&quot;left&quot; align=&quot;right&quot; 调整图像尺寸 ： width=&quot;200&quot; height=&quot;200&quot; 为图像添加链接属性 实例 ： 123&lt;a href="/example/html/lastpage.html"&gt;&lt;img border="0" src="/i/eg_buttonnext.gif" /&gt;&lt;/a&gt;### 命名锚的语法：&lt;a name=&quot;label&quot;&gt;锚（显示在页面上的文本）&lt;/a&gt;提示 锚的名称可以是任何你喜欢的名字。 您可以使用 id 属性来替代 name 属性，命名锚同样有效。 id适合对特定需求的进行锚定 class适合对一个组进行整体锚定实例1234567891011121314&lt;!--首先，我们在 HTML 文档中对锚进行命名（创建一个书签）：--&gt;&lt;a name="tips"&gt;基本的注意事项 - 有用的提示&lt;/a&gt;&lt;!--然后，我们在同一个文档中创建指向该锚的链接：--&gt;&lt;a href="#tips"&gt;有用的提示&lt;/a&gt;&lt;!--您也可以在其他页面中创建指向该锚的链接：--&gt;&lt;a href="http://www.w3school.com.cn/html/html_links.asp#tips"&gt;有用的提示&lt;/a&gt;&lt;!--在上面的代码中，我们将 # 符号和锚名称添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。--&gt;12345&lt;a name="top"&gt;&lt;/a&gt;&lt;p&gt; 内容&lt;/p&gt;&lt;a href="#top"&gt;回到顶部&lt;/a&gt;实现回到顶部1. 直接添加 # ,瞬间回到顶部1234&lt;body&gt; &lt;p&gt;内容&lt;/p&gt; &lt;a href="#"&gt;回到顶部&lt;/a&gt;&lt;/body&gt;—## HTML背景1. 背景颜色（Bgcolor）&gt; 背景颜色属性将背景设置为某种颜色。属性值可以是十六进制数、RGB 值或颜色名。123&lt;body bgcolor="#000000"&gt;&lt;body bgcolor="rgb(0,0,0)"&gt;&lt;body bgcolor="black"&gt;2. 背景（Background）背景属性将背景设置为图像。 属性值可以为图像的URL，可可以是相对路径* gif 和 jpg 文件均可用作 HTML 背景1&lt;body background="clouds.gif"&gt;注意： 如果图像尺寸小于浏览器窗口，那么图像将在整个浏览器窗口进行复制。 使用背景图片应考虑是否增加了页面的加载速度，大小不应超过10kb 背景图片应与页面的各种元素搭配，如文字等 背景图片不应太华丽，可能会导致主次不分 HTML 列表 –可嵌套 种类 &lt;ul&gt; 无序列表 &lt;li&gt; 扩展 添加type属性 type =&quot;disc/circle/square&quot; &lt;ol&gt; 有序列表 1. 2. 扩展 添加type属性 type =&quot;a/A/I/i&quot; &lt;dl&gt; 自定义列表 &lt;dt&gt; : 项目的定义 definiton term &lt;dd&gt; : 自定义列表项的内容 definition detail 更多方法样式style中的技巧 li:nth-child(3){ color: red; } : 将每个li列表中的第3个的字体颜色修改为红色 注意： 此修改为对全体列表的第3个进行操作，若需要单独操作，可在代码前加上ul:first-of-type HTML块&amp;内联元素使用&lt;style&gt;定制样式12345678&lt;style&gt;.cities&#123; background-color:balck; color:white; margin:20px; padding:20px;&#125;&lt;/style&gt; 解释 .cites : 设置cities类的样式 margin : 设置页外边距 auto ： 设置页面左右间距相同 padding ： 设置页内边距 块级元素 –在前后显示折行block level element 块级 &lt;h1&gt; &lt;p&gt; &lt;ur&gt; &lt;table&gt; &lt;div&gt; : 如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性 HTML&lt;div&gt;: 是块级元素。它能够用作其他 HTML 元素的容器。 设置 &lt;div&gt; 元素的类，使我们能够为相同的&lt;div&gt; 元素设置相同的类： 12345678&lt;div class="cities"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt; div属性 min-width ： 设置最小页面宽度 注意： 为防止出现div标签中出现背景颜色的空白，可使用footer文档来解决另一方案：overflow: hidden#### footer定义和用法&lt;footer&gt; 标签定义文档或节的页脚。&lt;footer&gt; 元素应当含有其包含元素的信息。&gt;页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。&gt;您可以在一个文档中使用多个 &lt;footer&gt; 元素。 footer样式属性 clean: both; : 可以去除div中的背景空隙解释—### 内联元素 –通常不以新行开始inline element 内联元素 &lt;b&gt; &lt;td&gt; &lt;a&gt; &lt;img&gt; &lt;span&gt; :当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性HTML &lt;span&gt;: 是行内元素，能够用作文本的容器。 设置 &lt;span&gt; 元素的类，能够为相同的 &lt;span&gt; 元素设置相同的样式。123456789101112&lt;style&gt;span.red &#123; color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;我的&lt;span class="red"&gt;重要的&lt;/span&gt;标题&lt;/h1&gt;&lt;/body&gt;—## HTML表格 HTML | 用途—| —&lt;thead&gt;|表格的页眉，可以对表格内容分类&lt;tbody&gt; | 定义表格的主体内容 &lt;tfoot&gt;|定义表格的页脚，可统计数据 每个表格由 table 标签开始。 每个表格行由 tr 标签开始，thead标签必须有tr标签 每个表格数据由 td 标签开始。 实例1234567891011&lt;!--两行两列表格--&gt;&lt;table border="1"&gt;&lt;tr&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;200&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;300&lt;/td&gt; &lt;td&gt;400&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表格的背景颜色与图像 设置整个表格12345&lt;table border="1"bgcolor="red"&gt;&lt;table border="1"background=""&gt; 设置个别格子12345&lt;table&gt;&lt;tr&gt; &lt;td bgcolor="1"&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 表格和边框属性 border=&quot;&quot; 如果不定义边框属性，表格将不显示边框。有时这很有用，但是大多数时候，我们希望显示边框。 表格的标题 &lt;caption&gt;我的标题&lt;/caption&gt; &lt;caption&gt;&lt;h2&gt;标题&lt;/h2&gt;&lt;/caption&gt; 自动为表格生成 tbody标签 表格的表头 表格的表头使用 &lt;th&gt; 标签进行定义。 大多数浏览器会把表头显示为粗体居中的文本 实例12345&lt;table border="1"&gt;&lt;tr&gt; &lt;th&gt;这是表头&lt;/th&gt;&lt;/tr&gt;&lt;/table&gt;注意: 为了避免空的单元格的边框没有被显示出来。这种情况，在空单元格中添加一个空格占位符，就可以将边框显示出来。 &lt;td&gt;&amp;nbsp;&lt;/td&gt; 空格由和号开始 (“&amp;”)，然后是字符”nbsp”，并以分号结尾(“;”) 设置跨越多行或多列的表格 &lt;th colspan=&quot;2&quot;&gt; &lt;th rowspan=&quot;2&quot;&gt; 设置单元格内文字的位置 &lt;td align=&quot;left&quot;&gt; FIFT &lt;/td&gt; 表格内也可以设置标签 实例123456789101112131415161718192021222324252627282930&lt;table border="1"&gt;&lt;tr&gt; &lt;td&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另一个段落。&lt;/p&gt; &lt;/td&gt; &lt;td&gt;这个单元包含一个表格： &lt;table border="1"&gt; &lt;tr&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;B&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;C&lt;/td&gt; &lt;td&gt;D&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;这个单元包含一个列表： &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;菠萝&lt;/li&gt; &lt;/ul&gt; &lt;/td&gt; &lt;td&gt;HELLO&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 创建单元格内容与其边框之间的空白 cellpadding 增加单元格之间的距离。 cellspacing1234567891011121314&lt;table border="1" cellpadding="10"&gt;&lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt; &lt;table border="1" cellspacing="10"&gt;&lt;tr&gt; &lt;td&gt;First&lt;/td&gt; &lt;td&gt;Row&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;—## HTML5的网站布局HTML5 提供的新语义元素来定义网页的不同部分：### HTML5布局语义元素| HTML5 | 语义元素 ||——-| ——–|| header | 定义文档或节的页眉|| nav | 定义导航链接的容器|| section | 定义文档中的节 ||article | 定义独立的自包含文章|| aside | 定义内容之外的内容（比如侧栏）|| footer | 定义文档或节的页脚|| details | 定义额外的细节|| summary | 定义 details 元素的标题|### 例子 可以直接配合样式定义块123456789101112&lt;style&gt;#header &#123; background-color:black; color:white; text-align:center; padding:5px;&#125;&lt;/style&gt;&lt;div id="header"&gt;&lt;h1&gt;City Gallery&lt;/h1&gt;&lt;/div&gt; 可以直接使用布局标签123456789101112&lt;style&gt; header &#123; background-color:black; color:white; text-align:center; padding:5px; &#125;&lt;/style&gt;&lt;header&gt;&lt;h1&gt;City Gallery&lt;/h1&gt;&lt;/header&gt;#### 注意事项 &lt;table&gt; 元素不是作为布局工具而设计的。 &lt;table&gt;元素的作用是显示表格化的数据。—## HTML 表单### 账号信息12345678&lt;form action="HTML_submit" method="get" &gt; &lt;label for="name"&gt;Enter your name&lt;/label&gt; &lt;input type="text" id="name" name="name" /&gt; &lt;textarea name="" id="" cols="30" rows="10"&gt; 这是文本输入框，可以输入内容 &lt;/textarea&gt; &lt;input type="submit"/&gt;&lt;/form&gt;解释 设置GET可以在URL中显示传值内容test.html?name=陈俊杰&amp;comment=这是测试&gt; 其中name、comment 均为id属性的内容#### &lt;form&gt; 标签##### autocomplete 属性&gt;autocomplete 属性规定表单或输入字段是否应该自动完成。&gt; 当自动完成开启，浏览器会基于用户之前的输入值自动填写值。提示：可以把表单的 autocomplete 设置为 on，同时把特定的输入字段设置为 off示例 ： 表单信息自动填写，而E-mail信息特定输入123456&lt;form action="action_page.php" autocomplete="on"&gt; First name:&lt;input type="text" name="fname"&gt;&lt;br&gt; Last name: &lt;input type="text" name="lname"&gt;&lt;br&gt; E-mail: &lt;input type="email" name="email" autocomplete="off"&gt;&lt;br&gt; &lt;input type="submit"&gt;&lt;/form&gt;##### novalidate 属性&gt;novalidate 属性属于 &lt;form&gt; 属性。&gt;如果设置，则 novalidate 规定在提交表单时不对表单数据进行验证。示例：指示表单在被提交时不进行验证：1234&lt;form action="action_page.php" novalidate&gt; E-mail: &lt;input type="email" name="user_email"&gt; &lt;input type="submit"&gt;&lt;/form&gt;—#### label : 标签 设置输入信息 属性 + for : 将label与input连接起来，可点击label直接选中输入框—#### input 属性 input ： 输入框，可以根据不同的type类型，变化为多种形态 - 类型type： - text : 文本输入 - submit : 提交框 - value : 设置文本值 - name : 规定 input 元素的名称 - reset : 重置输入框 - hidden ： 隐藏密码显示 - password : 字符密码会被掩码处理，定义密码字段 - image : 以图像作为提交图形 - file : 用户进行选择本地文件的操作补充 input 属性 readonly 属性 ：规定输入字段为只读（不能修改）,readonly 属性不需要值。它等同于 readonly=”readonly”。示例：设置固定只读的用户名1234&lt;form &gt; username:&lt;br&gt; &lt;input type="text" name="username" value="Keithxodoy" readonly&gt;&lt;/form&gt; disabled 属性 :规定输入字段是禁用的,被禁用的元素是不可用和不可点击的1234&lt;form &gt; username:&lt;br&gt; &lt;input type="text" name="username" value="Keithxodoy" disabled&gt;&lt;/form&gt; autofocus 属性:是布尔属性。如果设置，则规定当页面加载时 &lt;input&gt;元素应该自动获得焦点。示例：使 “First name” 输入字段在页面加载时自动获得焦点，即鼠标自动点击输入框1First name:&lt;input type="text" name="fname" autofocus&gt; height 和 width 属性&gt;height 和 width 属性规定 &lt;input&gt; 元素的高度和宽度。&gt;height 和 width 属性仅用于 &lt;input type=&quot;image&quot;&gt;,且需要始终规定图像的尺寸123&lt;form&gt; &lt;input type="image" src="/i.jpg" alt="Submit" width="128" height="128"/&gt;&lt;/form&gt; multiple 属性&gt;multiple 属性是布尔属性。&gt;如果设置，则规定允许用户在 &lt;input&gt; 元素中输入一个以上的值。multiple 属性适用于以下输入类型：email 和 file。示例： 选择本地图片上传1234&lt;form action="/example/html5/demo_form.asp" method="get"&gt;选择图片：&lt;input type="file" name="img" multiple="multiple" /&gt;&lt;input type="submit" /&gt;&lt;/form&gt; step 属性&gt; step 属性规定 &lt;input&gt; 元素的合法数字间隔。示例：如果 step=”3”，则合法数字应该是 -3、0、3、6、等等。提示：step 属性可与 max 以及 min 属性一同使用，来创建合法值的范围。 required 属性&gt; required 属性是布尔属性。&gt; 如果设置，则规定在提交表单之前必须填写输入字段。示例： 用户必须输入名称1234&lt;form action="/example/html5/demo_form.asp" method="get"&gt; Name: &lt;input type="text" name="Username" required="required" /&gt; &lt;input type="submit" value="submit"&gt;&lt;form&gt; 输入字段长度的一些属性| 属性值 | 作用 | 注意事项 ||——|—–| ——–|| size 属性 |规定输入字段的尺寸| || maxlength 属性|规定输入字段允许的最大长度| 该属性不会提供任何反馈。如果需要提醒用户，则必须编写 JavaScript 代码|—### 设置账户密码12&lt;input type="text" name="username"&gt;&lt;input type="password" name="psw"&gt;### select : 设置下拉列表 option元素设置待选择的选项 可以通过添加selected属性来定义预定义选项 - 例子：&lt;option value=&quot;BWM&quot; selected&gt;BWM&lt;/option&gt;示例：12345&lt;select name="cars"&gt;&lt;option value="volvo"&gt;Volvo&lt;/option&gt;&lt;option value="fiat"&gt;Fiat&lt;/option&gt;&lt;option value="audi"&gt;Audi&lt;/option&gt;&lt;/select&gt; textarea : 文本输入区域 + 可以输入文本 + rows cols 设置输入框的长宽 (同时也可以使用CSS来设置) button ： 设置可点击的按钮 + 示例：&lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;Hello World&#39;)&quot;&gt;Button&lt;/button&gt; + 解释： onclick=&quot;alert(&#39;&#39;)&quot;:设置点击完后,显示的文本内容优化123456789101112&lt;form action="" method="get"&gt; &lt;p&gt; &lt;label for="name"&gt;Enter Your Name&lt;/label&gt; &lt;input type="text" id="name" name="name" /&gt; &lt;/p&gt; &lt;p&gt; &lt;label for="comment"&gt;You Comment &lt;/label&gt; &lt;textarea id="comment" name="comment"&gt;&lt;/textarea&gt; &lt;/p&gt; &lt;p&gt;&lt;input type="submit" value="go" /&gt;&lt;/p&gt;&lt;/form&gt;12345678910111213&lt;form action="" method="get"&gt; &lt;ul&gt; &lt;li&gt; &lt;label for="name"&gt;Enter Your Name&lt;/label&gt; &lt;input type="text" id="name" name="name" /&gt; &lt;/li&gt; &lt;li&gt; &lt;label for="comment"&gt;You Comment &lt;/label&gt; &lt;textarea id="comment" name="comment" rows="10" cols="10"&gt;&lt;/textarea&gt; &lt;/li&gt; &lt;li&gt;&lt;input type="submit" value="go" /&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/form&gt;123456789101112form ul &#123; list-style: none; margin-bottom: 20px; padding-left: 0px;&#125;label &#123; display: block; cursor: pointer; color: #292929; font-family: sans-serif; padding-bottom: 8px;&#125;注释： 只有设置了 name 属性的表单元素才能在提交表单时传递它们的值。 name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据。 for - name - id 搭配使用 cursor 属性规定要显示的光标的类型（形状）。 cursor: pointer 光标呈现为指示链接的指针（一只手）### 复选框123&lt;label for="css"&gt;Do You Like Css&lt;/label&gt;&lt;input type="checkbox" name="css" id="css" /&gt;&lt;input type="radio" name="css" id="css"/&gt;复选框类型 checkbox ： 方形复选框允许用户在有限数量的选项中选择零个或多个选项 radio ： 圆形,只能进行单选实例：12345&lt;form &gt; &lt;input type="checkbox" name="country" value="China"&gt;China &lt;br&gt; &lt;input type="checkbox" name="country" value="USA"&gt;USA&lt;/form&gt;12345&lt;form&gt;&lt;input type="radio" name="sex" value="male" checked="checked"&gt;Male&lt;br&gt;&lt;input type="radio" name="sex" value="female"&gt;Female&lt;/form&gt;效果：也可以设置多个复选框123456789&lt;input type="radio" name="css" id="css"/&gt;HTML&lt;input type="radio" name="css" id="css"/&gt;CSS&lt;input type="radio" name="css" id="css"/&gt;PYTOHN&lt;!--这类复选框一旦选中，就不能取消--&gt;&lt;input type="radio" /&gt;HTML&lt;input type="radio"/&gt;CSS&lt;input type="radio" /&gt;PYTOHN—上下拉动的复选框&gt; 首选进行上下框的选择范例12345&lt;select&gt;&lt;option&gt;Apples&lt;option selected&gt;Bananas&lt;option&gt;Cherries&lt;/select&gt;—数字类型的复选框&lt;input type=&quot;number&quot;&gt;:用于应该包含数字值的输入字段示例：设置数字限制在1-5的字段123&lt;form&gt; &lt;input type="number" name="quanlity" min="1" max="5"&gt;&lt;/form&gt;其他输入限制1. required : 规定输入字段是必需的（必需填写）2. maxlength : 规定输入字段的最大字符数。3. disabled : 规定输入字段应该被禁用。—设置日期的输入字段&lt;input type=&quot;date&quot;&gt;:根据浏览器支持，日期选择器出现输入字段123&lt;form&gt; &lt;input type="date" name="bday"&gt;&lt;/form&gt;同时也可以为输入添加限制：1234&lt;form&gt; 输入一个日期大于2000年1月2号 &lt;input type="date" name="bday" min="2000-01-02"&gt;&lt;/form&gt;注释:Firefox 或者 Internet Explorer 11 以及更早版本不支持 type=”date”—设置输入包含颜色的输入字段&lt;input type=&quot;color&quot;&gt; : 根据浏览器支持，可以在输入字段中出现颜色选择器示例： 在输入框中出现颜色选择器12345&lt;form&gt; 可选择喜欢的颜色 &lt;input type="color" name="favcolor" value="#ff0000"&gt; &lt;input type="submit"&gt;&lt;/form&gt;注释: Internet Explorer 不支持 type=”color”—其余类型| 输入类型 | 用处 ||———|——|| type=”range”|输入字段可以显示滑块控件|| type=”month”| 输入日期选择器|| type=”week”| 输入用户选择周和年|| type=”time”| 输入用户选择时间|| type=”datetime”| 输入用户选择日期和时间|| type=”email”| 输入包含电子邮件地址的字段|| type=”search”| 用于搜索字段（搜索表现类似的常规文本字段）|—### 上传表单#### Action 属性&gt; action 属性定义在提交表单时执行的动作,表示提交表单数据至表单处理程序的按钮。&gt;&gt;向服务器提交表单的通常做法是使用提交按钮。&gt;通常，表单会被提交到 web 服务器上的网页。实例：&lt;form action=&quot;action_page.php&quot;&gt; :指定了某个服务器脚本来处理被提交表单注意如果省略 action 属性，则 action 会被设置为当前页面。#### Method 属性&gt;method 属性规定在提交表单时所用的 HTTP 方法（GET 或 POST）：实例： get&gt;get常见于搜索引擎，适合少量数据提交，一般浏览器会设定容量限制，不含敏感信息&lt;form action=&quot;action_page.php&quot; method=&quot;GET&quot;&gt; post&gt;post适合更新数据，包含敏感信息（例如密码），post安全性更高，因为页面提交的数据不会在页面地址栏显示&lt;form action=&quot;action_page.php&quot; method=&quot;POST&quot;&gt;#### Name 属性如果要正确地被提交，每个输入字段必须设置一个 name 属性。例如：&lt;input type=&quot;text&quot; value=&quot;info&quot;&gt;因为不含name属性而无法正常提交正确做法： &lt;input type=&quot;text&quot; name=&quot;information&quot; value=&quot;info&quot; &gt;#### 用 &lt;fieldset&gt; 组合表单数据实例：123456789101112&lt;form action="action_page.php"&gt;&lt;fieldset&gt;&lt;legend&gt;Personal information:&lt;/legend&gt;name:&lt;br&gt;&lt;input type="text" name="name" value="Your name"&gt;&lt;br&gt;password:&lt;br&gt;&lt;input type="text" name="pwd" value="Your pwd"&gt;&lt;br&gt;&lt;br&gt;&lt;input type="submit" value="Submit"&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;fieldset&gt; 元素组合表单中的相关数据&lt;legend&gt; 元素为 &lt;fieldset&gt; 元素定义标题。#### &lt;datalist&gt;元素设置预定义选项列表&gt;用户在输入数据时可以看到预定义选项的下拉列表示例：12345678910&lt;form action="action_page.php"&gt;&lt;input list="browsers"&gt;&lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt;&lt;/datalist&gt; &lt;/form&gt;注意事项1. Safari 或者 IE9及之前版本不支持datalist标签2. input 元素的list属性必须引用 datalist 元素的 id属性—## HTML 脚本### 解释与基本语法&gt; JavaScript 使 HTML 页面具有更强的动态和交互性。。 语法 基本语法 ： &lt;script type=&quot;text/javascript&quot;&gt; 对于不支持Javascript的浏览器 ： &lt;noscript&gt;&lt;/noscript&gt; 解释 &lt;script&gt;标签用于定义客户端脚本，可以包含脚本语言，也可以通过src属性指向外部脚本文件 只有在浏览器不支持脚本或者禁用脚本时，才会显示 noscript 元素中的内容范例123&lt;script type="text/javascript"&gt;document.write("Hello World!")&lt;/script&gt;注意如何应付老式的浏览器&gt;如果浏览器无法识别 &lt;script&gt;标签，那么&lt;script&gt;标签所包含的内容将以文本方式显示在页面上。 解决办法：将脚本隐藏在注释标签当中。 解释： 对于无法识别 &lt;script&gt; 标签的浏览器将忽略这些注释，所以不会将标签的内容显示到页面上。而那些新的浏览器将读懂这些脚本并执行它们，即使代码被嵌套在注释标签内。范例12345&lt;script type="text/javascript"&gt;&lt;!--document.write("Hello World!")//--&gt;&lt;/script&gt;### 弹出框&gt; alert()为弹出框(js)123&lt;script&gt; alert()&lt;/script&gt;—## HTML头部元素头部基础信息123&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;meta http-equiv="Content-Language" content="zh-cn" /&gt;&lt;title&gt;定义标题&lt;/title&gt;### &lt;head&gt;元素&gt;标签都可以添加到 head 部分：&lt;title&gt;、&lt;base&gt;、&lt;link&gt;、&lt;meta&gt;、&lt;script&gt; 以及 &lt;style&gt;### meta属性&gt; 元数据metadata提供数据的信息，元数据不会显示在页面上，但是机器是可读的&gt; meta属性标识了创作者和编辑软件、文档和它的关键词&gt; meta属性始终位于 head 元素中12345678910111213141516&lt;meta http-equiv="Content-Type" content="text/html; charset=gb2312" /&gt;&lt;meta name="author"content="地址内容"&gt;&lt;meta name="revised"content="Keithxodoy,10/7/18"&gt;&lt;meta name="generator"content="Sublime"&gt;&lt;meta name="description"content="HTML examples"&gt;&lt;meta name="keywords"content="HTML, DHTML, CSS, XHTML, JAVAScript, VBScript"&gt; 重新定向新地址12345678910111213&lt;head&gt;&lt;meta http-equiv="Refresh" content="5;url=网页地址" /&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;URL 是 &lt;a href="http://www.地址.com"&gt;http://www.地址.com&lt;/a&gt;&lt;/p&gt;&lt;p&gt;您将在 5 秒内被重定向到新的地址。&lt;/p&gt;&lt;p&gt;如果超过 5 秒后您仍然看到本消息，请点击上面的链接。&lt;/p&gt;&lt;/body&gt;解释 针对搜索引擎的定义页面的描述： &lt;meta name=&quot;description&quot; content=&quot;HTML examples&quot;&gt; 针对搜索引擎的定义页面的关键词：&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML&quot; /&gt;—### base标签 使用 base标签使页面中的所有标签在新窗口中打开123&lt;head&gt;&lt;base target="_blank" /&gt;&lt;/head&gt;* 使用base标签使得页面上的所有链接规定默认地址123&lt;head&gt; &lt;base href="http://" /&gt;&lt;/head&gt;### style元素123456&lt;head&gt; &lt;style type="text/css"&gt; body &#123;background-color: yellow&#125; p &#123;color: blue&#125; &lt;/style&gt;&lt;/head&gt;—## HTML 框架### 框架理解框架通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。每份HTML文档称为一个框架，并且每个框架都独立于其他的框架。 使用框架的坏处： 开发人员必须同时跟踪更多的HTML文档 很难打印整张页面 框架相关标签 frameset 标签也被某些文章和书籍译为框架集 框架结构标签（&lt;frameset&gt;） 定义如何将窗口分割为框架 注意不能将 &lt;body&gt;&lt;/body&gt; 标签与 &lt;frameset&gt;&lt;/frameset&gt; 标签同时使用！ 框架标签（frame） Frame 标签定义了放置在每个框架中的 HTML 文档,一个窗口应该用一个 frame 标签表示， frame 标签不能分割，只能表示小窗口 frame标签属性 scrolling=&quot;no&quot;: 规定是否在框架中显示滚动条 src=&quot;文件地址&quot; ： 设定框架的内容 实例：将一个框架内容导入另一个框架，将menu.html内容导入至main.html内 12345&lt;ul&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;&lt;a href="info.html" target="main"&gt;需要导入的文档&lt;/a&gt;&lt;/li&gt; &lt;li&gt;管理&lt;/li&gt;&lt;/ul&gt; 1234&lt;frame src="menu.html" name="menu" /&gt;&lt;frameset&gt; &lt;frame src="main.html" name="main" /&gt;&lt;/frameset&gt; 问题对于页面的index.html文件，若向main框架内导入index.html，则会导致框架内嵌重复框架 解决12345&lt;ul&gt; &lt;li&gt;&lt;a href="index.html" target="_top"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="info.html" target="main"&gt;需要导入的文档&lt;/a&gt;&lt;/li&gt; &lt;li&gt;管理&lt;/li&gt;&lt;/ul&gt; 注意为了避免框架有可见边框,用户可以拖动边框来改变它的大小 在 &lt;frame&gt; 标签中加入：noresize=&quot;noresize&quot; 实例123&lt;frameset cols="50%,*,25%"&gt; &lt;frame src="/example/html/frame_a.html" noresize="noresize" /&gt;&lt;/frameset&gt; noresize 也可以在 frameset中使用，则整个框架集都不能拖动 框架类型垂直框架1234&lt;frameset cols="25%,50%,25%"&gt; &lt;frame src="/example/html/frame_a.html"&gt; &lt;frame src="/example/html/frame_b.html"&gt; &lt;frame src="/example/html/frame_c.html"&gt; 水平框架1234&lt;frameset rows="25%,50%,25%"&gt; &lt;frame src="/example/html/frame_a.html"&gt; &lt;frame src="/example/html/frame_b.html"&gt; &lt;frame src="/example/html/frame_c.html"&gt; noframes框架noframes 元素可为那些不支持框架的浏览器显示文本。 noframes 元素位于 frameset 元素内部。 重要事项：如果您希望 frameset 添加 &lt;noframes&gt; 标签，就必须把其中的文本包装在&lt;body&gt;&lt;/body&gt;标签中！ 实例 12345678910&lt;frameset cols="25%,50%,25%"&gt; &lt;frame src="/example/html/frame_a.html"&gt; &lt;frame src="/example/html/frame_b.html"&gt; &lt;frame src="/example/html/frame_c.html"&gt;&lt;noframes&gt;&lt;body&gt;您的浏览器无法处理框架！&lt;/body&gt;&lt;/noframes&gt;&lt;/frameset&gt; 混合框架实例 12345678910&lt;frameset rows="50%,50%"&gt;&lt;frame src="/example/html/frame_a.html"&gt;&lt;frameset cols="25%,75%"&gt;&lt;frame src="/example/html/frame_b.html"&gt;&lt;frame src="/example/html/frame_c.html"&gt;&lt;/frameset&gt;&lt;/frameset&gt; 导航框架实例 导航框架包含一个将第二个框架作为目标的链接列表。123456&lt;frameset cols="120,*"&gt; &lt;frame src="/example/html/html_contents.html"&gt; &lt;frame src="/example/html/frame_a.html" name="showframe"&gt;&lt;/frameset&gt; 内联框架（HTML 页中的框架） 应用 ： iframe 用于在网页内显示网页 语法 ： &lt;iframe src=&quot;URL&gt;&lt;/frame&gt; 其中URL指向隔离页面的位置 拓展属性 height=&quot;200&quot; width=&quot;200 : 定义iframe的高度与宽度，默认单位为像素 frameborder=&quot;0 : 用于规定是否显示iframe周围的边框，为”0”即可移除边框 实例1&lt;iframe src="/html/index.asp" height="300px" width="99%" style="margin-top:15px;"&gt;&lt;/iframe&gt; 使用 iframe 作为链接的目标iframe 可用作链接的目标（target）。 链接的 target 属性必须引用 iframe 的 name 属性 实例12&lt;iframe src="demo_iframe.html" name="iframe_a"&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href="http://www.w3school.com.cn" target="iframe_a"&gt;w3school&lt;/a&gt;&lt;/p&gt; 解释 使用iframe的name属性，与a的target关联，使其指向a中的超链接 表格中的框架 分别设置 上 ， 下 ，上下 ，两侧 的表格框线 1234567891011&lt;table frame="above"&gt;&lt;tableframe="below"&gt;&lt;tableframe="hsides"&gt;&lt;table frame="vsides"&gt; 框架属性 noresize=&quot;noresize&quot; 添加该属性后，框架是不可调整尺寸的 设置指向另一个文件内指定的节的链接 &lt;frame src=&quot;/example/html/link.html#C6&quot;&gt; 使用框架导航跳转至指定的节 123456&lt;frameset cols="180,*"&gt;&lt;frame src="/example/html/content.html"&gt;&lt;frame src="/example/html/link.html" name="showframe"&gt;&lt;/frameset&gt; target=&quot;_top&quot; ：跳出被锁定的框架 高级用法–HTML5图像使用JS的图像绘制标签： &lt;canvas&gt; 使用SVG的图像绘制标签：&lt;svg&gt; 高级用法–HTML5媒介元素HTML5视频 标签 描述 &lt;embed&gt; 定义外部应用程序的容器（比如插件）。 &lt;source&gt; 定义 &lt;video&gt; 和 &lt;audio&gt; 的来源。 &lt;track&gt; 定义 &lt;video&gt;和 &lt;audio&gt; 的轨道。 &lt;video&gt; 定义视频或影片内容。 HTML5音频 标签 描述 &lt;audio&gt; 定义声音或音乐内容。 HTML响应式WEB设计概念 什么是响应式 Web 设计？RWD 指的是响应式 Web 设计（Responsive Web Design） RWD 能够以可变尺寸传递网页 RWD 对于平板和移动设备是必需的 创建方法 手工搭建，设置样式 使用现成的 CSS 框架使用 Bootstrap Bootstrap 是最流行的开发响应式 web 的 HTML, CSS, 和 JS 框架。Bootstrap 帮助您开发在任何尺寸都外观出众的站点：显示器、笔记本电脑、平板电脑或手机 XHTML基础XHTML : EXtensible HyperText Markup Language 疑问： XHTML 中有哪些不同的 DTD ？Strict, Transitional, Frameset （其中Transitional最常用） 诞生原因 由于互联网存在一些不同的浏览器技术。其中一些在计算机上运行，而另一些可能在移动电话或其他小型设备上运行。小型设备往往缺乏解释“糟糕”的标记语言的资源和能力。所以 - 通过结合 XML 和 HTML 的长处，开发出了 XHTML，即XHTML 是作为 XML 被重新设计的 HTML。 由 HTML –&gt; XHTML步骤： 向每张页面的第一行添加 XHTML &lt;!DOCTYPE&gt; 向每张页面的 html 元素添加 xmlns 属性 把所有元素名改为小写 关闭所有空元素 把所有属性名改为小写 为所有属性值加引号 须知：HTML 会被 XHTML 取代。 XHTML 的注意事项文档结构 XHTML DOCTYPE 是强制性的 &lt;html&gt; 中的 XML namespace属性是强制性的 &lt;html&gt;、&lt;head&gt;、&lt;title&gt; 以及 &lt;body&gt; 也是强制性的 元素语法 XHTML 元素必须正确嵌套,而在 HTML 中，某些元素可以不正确地彼此嵌套在一起 XHTML 元素必须始终关闭 XHTML 元素必须小写 XHTML 文档必须有一个根元素 属性语法 XHTML 属性必须使用小写 XHTML 属性值必须用引号包围 XHTML 属性最小化也是禁止的 语法： XHTML 中不允许简写属性 Web Server个人服务器网站搭建 使用因特网服务提供商(ISP) 优点 连接速度快，拥有连接因特网的高速连接 硬件强大，最好查看 ISP 是否提供高效的负载平衡，以及必要的备份服务器 安全性、可靠性高 选择 ISP 的注意事项 24小时支持服务(免费电话服务等) 确保 ISP 执行每日备份的工作 ISP 的流量限制，避免因为网站访问人数激增而引起预料外的支付费用 ISP 的带宽与内容限制，确保可以发布图片或视频、音频等 ISP 支持所需的 e-mail 功能 ISP 确保可以支持个人所需访问的数据库 FAQ HTML 的框架是什么? —见HTML框架 如何解决使用div时，设置背景出现空白间隙？ —见块级元素的div]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶]]></title>
    <url>%2F2018%2F06%2F24%2FPython%2FPython_Advanced%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程 原则写代码要遵循==开发封闭==原则，虽然这个原则是用的面向对象开发，但是也适用于函数式编程，简单来说，它规定已经实现的功能代码不允许被修改，但可以被扩展，即： 封闭：已实现的功能代码块 开放：对扩展开发 内容装饰器12345678910def w1(func): def inner(): # 验证1 # 验证2 # 验证3 return func() return inner@w1 # 相当于执行了 w1(f1())def f1(): print('f1') 当写完这段代码后（函数未被执行、未被执行、未被执行），python解释器就会从上到下解释代码，步骤如下：12def w1(func): ==&gt;将w1函数加载到内存@w1 没错，从表面上看解释器仅仅会解释这两句代码，因为函数在没有被调用之前其内部代码不会被执行。 从表面上看解释器着实会执行这两句，但是 @w1 这一句代码里却有大文章 @函数名 : 是python的一种语法糖。 如上例 @w1内部会执行以下操作: 执行w1函数，并将 @w1 下面的 函数 作为 w1 函数的参数即：@w1 等价于 w1(f1)。 所以，内部就会去执行：1234567891011121314151617def inner: #验证 return f1() # func是参数，此时 func 等于 f1return inner # 返回的 inner，inner代表的是函数，非执行函数# 其实就是将原来的 f1 函数塞进另外一个函数中。# 将执行完的 w1 函数返回值赋值给@w1下面的函数的函数名# w1函数的返回值是： def inner: #验证 return 原来f1() # 此处的 f1 表示原来的f1函数# 然后，将此返回值再重新赋值给 f1，即：new_f1 = def inner: #验证 return 原来f1() 如此一来， 即执行了验证的功能，又执行了原来 f 函数的内容，并将原 f1 函数返回值, 返回给业务调用着。 参数传递12345678910111213141516171819202122232425 # 一个参数：def w1(func): def inner(arg): # 验证1 # 验证2 # 验证3 return func(arg) return inner@w1def f1(arg): print('f1')# 两个参数：def w1(func): def inner(arg1,arg2): # 验证1 # 验证2 # 验证3 return func(arg1,arg2) return inner@w1def f1(arg1,arg2): print('f1') 问题: 装饰具有处理n个参数的函数的装饰器？12345678910def w1(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return inner@w1def f1(arg1,arg2,arg3): print('f1') 问题：一个函数可以被多个装饰器装饰吗？123456789101112131415161718def w1(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return innerdef w2(func): def inner(*args,**kwargs): # 验证1 # 验证2 # 验证3 return func(*args,**kwargs) return inner@w1@w2def f1(arg1,arg2,arg3): print('f1') Lambda函数（匿名函数） 函数 ： 最大程度地复用代码 存在问题：若函数很小，很短，则会造成啰嗦，不方便阅读代码 lambda表达式 一个表达式，函数体相对简单 用法 以lambda开头 紧跟一定的参数 参数后面用冒号和表达式主题分开 只是一个表达式，没有return 实例 stm = lambda x: 100 * x stm(89) ==&gt;8900 高阶函数 定义 ： 把函数作为参数使用的函数 注意 函数名称就是一个变量，即函数可以作为参数 举例12345def funA(n): return n * 100def funB(n): return funA(n) * 3 map函数 对队列里的每个元素进行操作，即映射操作 map函数是系统提供的具有映射功能的函数，返回值是一个迭代对象,类型为map类 注意：若用列表生成式得到的结果为空 格式： map(func, *iterables) 12345678910111213141516# map举例# 列表里的每个元素都乘以10l1 = [ i for i in range(10)]print(l1)for i in li: l2.append(i*10)# 利用map来实现def multen(n): return n*10l2 = map(multen, l1 ) # multen函数作为map函数的一个参数for x in l2: print(l2) reduce函数 作用： 归并，缩减 ，把可迭代对象最后归并为一个结果 作为参数的函数要求： 必须有两个参数 必须有返回结果 理解 ：reduce([1,2,3]) == f(f(f(1),2),3) 即函数嵌套 注意： reduce需要导入functools包 1234567891011from functools import reduce# 定义一个操作函数# 加入操作函数来相加def add(x,y): return x + y## 对列表[1,2,3]执行add的reduce操作rst = reduce(add, [1,2,3])print(rst) filter 函数 过滤函数：对一组数据进行过滤，符合条件的数据会产生一个新的列表返回 与map函数比较 相同 ： 都对列表的每个元素逐一进行操作 不同 ： map 会生成一个跟原来数据相对应的新队列 filter 不一定，只有符合条件的才会进入新队列 filter函数写法 利用给定函数进行判断 返回值为一个布尔值 调用格式 ： filter(f,data) f 为过滤函数 data 为数据 12345678910# 案例 过滤偶数数据形成新列表def isEven(a): return a%2 ==0list = [3,4,56,3,455,67,4,4]rst = filter(isEven, l)print([i for i in rst]) 注意事项 返回的filter内容是一个可迭代对象,需要逐个输出 排序 把一个序列按照给定算法进行排序 key : 在排序前，对每一个元素进行 key 函数运算，可理解为按照 key 函数定义的逻辑进行排序 (key函数为排序函数的内嵌参数) python2 python3 的差别较大 12345678910111213141516# 排序案例1a = [21,5,7,456,45,66]al = sorted(a, reverse=True)print (al)# 排序案例2a = [4.-45.457.74.7.5]# 按照数据的绝对值进行排序 # abs 为求绝对值的函数al = sorted(a, key=abs, reverse=True)print (al)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
